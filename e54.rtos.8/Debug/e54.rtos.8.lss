
e54.rtos.8.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00009abc  00000000  00000000  00010000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.exidx    00000008  00009abc  00009abc  00019abc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .relocate     0000009c  20000000  00009ac4  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bkupram      00000000  47000000  47000000  0002009c  2**0
                  CONTENTS
  4 .qspi         00000000  04000000  04000000  0002009c  2**0
                  CONTENTS
  5 .bss          00002330  200000a0  00009b68  000200a0  2**3
                  ALLOC
  6 .stack        00010000  200023d0  0000be98  000200a0  2**0
                  ALLOC
  7 .ARM.attributes 0000002e  00000000  00000000  0002009c  2**0
                  CONTENTS, READONLY
  8 .comment      00000059  00000000  00000000  000200ca  2**0
                  CONTENTS, READONLY
  9 .debug_info   0005ce04  00000000  00000000  00020123  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 0000868e  00000000  00000000  0007cf27  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00024459  00000000  00000000  000855b5  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_aranges 00001938  00000000  00000000  000a9a0e  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00002588  00000000  00000000  000ab346  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_macro  0004222b  00000000  00000000  000ad8ce  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   0002b9dc  00000000  00000000  000efaf9  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    00133693  00000000  00000000  0011b4d5  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_frame  00004814  00000000  00000000  0024eb68  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <exception_table>:
       0:	d0 23 01 20 f9 02 00 00 f5 02 00 00 f5 02 00 00     .#. ............
      10:	f5 02 00 00 f5 02 00 00 f5 02 00 00 00 00 00 00     ................
	...
      2c:	21 6d 00 00 f5 02 00 00 00 00 00 00 c1 6d 00 00     !m...........m..
      3c:	25 6e 00 00 f5 02 00 00 f5 02 00 00 f5 02 00 00     %n..............
      4c:	f5 02 00 00 f5 02 00 00 f5 02 00 00 f5 02 00 00     ................
      5c:	f5 02 00 00 f5 02 00 00 f5 02 00 00 f5 02 00 00     ................
      6c:	89 38 00 00 c5 35 00 00 d1 35 00 00 dd 35 00 00     .8...5...5...5..
      7c:	e9 35 00 00 f5 02 00 00 f5 02 00 00 f5 02 00 00     .5..............
      8c:	f5 02 00 00 f5 02 00 00 f5 02 00 00 f5 02 00 00     ................
      9c:	f5 02 00 00 f5 02 00 00 f5 02 00 00 f5 02 00 00     ................
      ac:	f5 02 00 00 f5 02 00 00 f5 02 00 00 f5 02 00 00     ................
      bc:	f5 02 00 00 f5 02 00 00 f5 02 00 00 f5 02 00 00     ................
      cc:	f5 02 00 00 f5 02 00 00 f5 02 00 00 f5 02 00 00     ................
      dc:	f5 02 00 00 f5 02 00 00 f5 02 00 00 f5 02 00 00     ................
      ec:	f5 02 00 00 00 00 00 00 8d 37 00 00 8d 41 00 00     .........7...A..
      fc:	a1 41 00 00 b5 41 00 00 c9 41 00 00 f5 02 00 00     .A...A...A......
     10c:	f5 02 00 00 f5 02 00 00 f5 02 00 00 f5 02 00 00     ................
     11c:	f5 02 00 00 f5 02 00 00 f5 02 00 00 f5 02 00 00     ................
     12c:	f5 02 00 00 f5 02 00 00 f5 02 00 00 f5 02 00 00     ................
     13c:	f5 02 00 00 f5 02 00 00 f5 02 00 00 f5 02 00 00     ................
     14c:	f5 02 00 00 f5 02 00 00 f5 02 00 00 f5 02 00 00     ................
     15c:	f5 02 00 00 f5 02 00 00 f5 02 00 00 f5 02 00 00     ................
     16c:	f5 02 00 00 f5 02 00 00 f5 02 00 00 f5 02 00 00     ................
     17c:	f5 02 00 00 f5 59 00 00 01 5a 00 00 0d 5a 00 00     .....Y...Z...Z..
     18c:	19 5a 00 00 f5 02 00 00 f5 02 00 00 f5 02 00 00     .Z..............
     19c:	f5 02 00 00 f5 02 00 00 f5 02 00 00 f5 02 00 00     ................
     1ac:	f5 02 00 00 f5 02 00 00 f5 02 00 00 f5 02 00 00     ................
     1bc:	f5 02 00 00 f5 02 00 00 f5 02 00 00 f5 02 00 00     ................
     1cc:	f5 02 00 00 f5 02 00 00 f5 02 00 00 f5 02 00 00     ................
     1dc:	f5 02 00 00 f5 02 00 00 f5 02 00 00 f5 02 00 00     ................
     1ec:	f5 02 00 00 f5 02 00 00 f5 02 00 00 f5 02 00 00     ................
     1fc:	99 47 00 00 ad 47 00 00 f5 02 00 00 f5 02 00 00     .G...G..........
     20c:	11 37 00 00 f5 02 00 00 f5 02 00 00 f5 02 00 00     .7..............
     21c:	f5 02 00 00 f5 02 00 00 f5 02 00 00 f5 02 00 00     ................
     22c:	f5 02 00 00 f5 02 00 00 f5 02 00 00 f5 02 00 00     ................
     23c:	f5 02 00 00 f5 02 00 00 f5 02 00 00 f5 02 00 00     ................
     24c:	f5 02 00 00 f5 02 00 00 f5 02 00 00 f5 02 00 00     ................
     25c:	f5 02 00 00 f5 02 00 00                             ........

00000264 <__do_global_dtors_aux>:
     264:	b510      	push	{r4, lr}
     266:	4c05      	ldr	r4, [pc, #20]	; (27c <__do_global_dtors_aux+0x18>)
     268:	7823      	ldrb	r3, [r4, #0]
     26a:	b933      	cbnz	r3, 27a <__do_global_dtors_aux+0x16>
     26c:	4b04      	ldr	r3, [pc, #16]	; (280 <__do_global_dtors_aux+0x1c>)
     26e:	b113      	cbz	r3, 276 <__do_global_dtors_aux+0x12>
     270:	4804      	ldr	r0, [pc, #16]	; (284 <__do_global_dtors_aux+0x20>)
     272:	f3af 8000 	nop.w
     276:	2301      	movs	r3, #1
     278:	7023      	strb	r3, [r4, #0]
     27a:	bd10      	pop	{r4, pc}
     27c:	200000a0 	.word	0x200000a0
     280:	00000000 	.word	0x00000000
     284:	00009ac4 	.word	0x00009ac4

00000288 <frame_dummy>:
     288:	4b0c      	ldr	r3, [pc, #48]	; (2bc <frame_dummy+0x34>)
     28a:	b143      	cbz	r3, 29e <frame_dummy+0x16>
     28c:	480c      	ldr	r0, [pc, #48]	; (2c0 <frame_dummy+0x38>)
     28e:	490d      	ldr	r1, [pc, #52]	; (2c4 <frame_dummy+0x3c>)
     290:	b510      	push	{r4, lr}
     292:	f3af 8000 	nop.w
     296:	480c      	ldr	r0, [pc, #48]	; (2c8 <frame_dummy+0x40>)
     298:	6803      	ldr	r3, [r0, #0]
     29a:	b923      	cbnz	r3, 2a6 <frame_dummy+0x1e>
     29c:	bd10      	pop	{r4, pc}
     29e:	480a      	ldr	r0, [pc, #40]	; (2c8 <frame_dummy+0x40>)
     2a0:	6803      	ldr	r3, [r0, #0]
     2a2:	b933      	cbnz	r3, 2b2 <frame_dummy+0x2a>
     2a4:	4770      	bx	lr
     2a6:	4b09      	ldr	r3, [pc, #36]	; (2cc <frame_dummy+0x44>)
     2a8:	2b00      	cmp	r3, #0
     2aa:	d0f7      	beq.n	29c <frame_dummy+0x14>
     2ac:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
     2b0:	4718      	bx	r3
     2b2:	4b06      	ldr	r3, [pc, #24]	; (2cc <frame_dummy+0x44>)
     2b4:	2b00      	cmp	r3, #0
     2b6:	d0f5      	beq.n	2a4 <frame_dummy+0x1c>
     2b8:	4718      	bx	r3
     2ba:	bf00      	nop
     2bc:	00000000 	.word	0x00000000
     2c0:	00009ac4 	.word	0x00009ac4
     2c4:	200000a4 	.word	0x200000a4
     2c8:	00009ac4 	.word	0x00009ac4
     2cc:	00000000 	.word	0x00000000

000002d0 <atmel_start_init>:

/**
 * Initializes MCU, drivers and middleware in the project
**/
void atmel_start_init(void)
{
     2d0:	b508      	push	{r3, lr}
	system_init();
     2d2:	4b04      	ldr	r3, [pc, #16]	; (2e4 <atmel_start_init+0x14>)
     2d4:	4798      	blx	r3
	usb_init();
     2d6:	4b04      	ldr	r3, [pc, #16]	; (2e8 <atmel_start_init+0x18>)
     2d8:	4798      	blx	r3
	sd_mmc_stack_init();
     2da:	4b04      	ldr	r3, [pc, #16]	; (2ec <atmel_start_init+0x1c>)
     2dc:	4798      	blx	r3
	diskio_init();
     2de:	4b04      	ldr	r3, [pc, #16]	; (2f0 <atmel_start_init+0x20>)
     2e0:	4798      	blx	r3
     2e2:	bd08      	pop	{r3, pc}
     2e4:	00000b9d 	.word	0x00000b9d
     2e8:	00009331 	.word	0x00009331
     2ec:	00006a81 	.word	0x00006a81
     2f0:	00000589 	.word	0x00000589

000002f4 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
     2f4:	e7fe      	b.n	2f4 <Dummy_Handler>
	...

000002f8 <Reset_Handler>:
{
     2f8:	b508      	push	{r3, lr}
        if (pSrc != pDest) {
     2fa:	4b1c      	ldr	r3, [pc, #112]	; (36c <Reset_Handler+0x74>)
     2fc:	4a1c      	ldr	r2, [pc, #112]	; (370 <Reset_Handler+0x78>)
     2fe:	429a      	cmp	r2, r3
     300:	d010      	beq.n	324 <Reset_Handler+0x2c>
                for (; pDest < &_erelocate;) {
     302:	4b1c      	ldr	r3, [pc, #112]	; (374 <Reset_Handler+0x7c>)
     304:	4a19      	ldr	r2, [pc, #100]	; (36c <Reset_Handler+0x74>)
     306:	429a      	cmp	r2, r3
     308:	d20c      	bcs.n	324 <Reset_Handler+0x2c>
     30a:	3b01      	subs	r3, #1
     30c:	1a9b      	subs	r3, r3, r2
     30e:	f023 0303 	bic.w	r3, r3, #3
     312:	3304      	adds	r3, #4
     314:	4413      	add	r3, r2
     316:	4916      	ldr	r1, [pc, #88]	; (370 <Reset_Handler+0x78>)
                        *pDest++ = *pSrc++;
     318:	f851 0b04 	ldr.w	r0, [r1], #4
     31c:	f842 0b04 	str.w	r0, [r2], #4
                for (; pDest < &_erelocate;) {
     320:	429a      	cmp	r2, r3
     322:	d1f9      	bne.n	318 <Reset_Handler+0x20>
        for (pDest = &_szero; pDest < &_ezero;) {
     324:	4b14      	ldr	r3, [pc, #80]	; (378 <Reset_Handler+0x80>)
     326:	4a15      	ldr	r2, [pc, #84]	; (37c <Reset_Handler+0x84>)
     328:	429a      	cmp	r2, r3
     32a:	d20a      	bcs.n	342 <Reset_Handler+0x4a>
     32c:	3b01      	subs	r3, #1
     32e:	1a9b      	subs	r3, r3, r2
     330:	f023 0303 	bic.w	r3, r3, #3
     334:	3304      	adds	r3, #4
     336:	4413      	add	r3, r2
                *pDest++ = 0;
     338:	2100      	movs	r1, #0
     33a:	f842 1b04 	str.w	r1, [r2], #4
        for (pDest = &_szero; pDest < &_ezero;) {
     33e:	4293      	cmp	r3, r2
     340:	d1fb      	bne.n	33a <Reset_Handler+0x42>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
     342:	4b0f      	ldr	r3, [pc, #60]	; (380 <Reset_Handler+0x88>)
     344:	4a0f      	ldr	r2, [pc, #60]	; (384 <Reset_Handler+0x8c>)
     346:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
     34a:	609a      	str	r2, [r3, #8]
        SCB->CPACR |=  (0xFu << 20);
     34c:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
     350:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
     354:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
     358:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
     35c:	f3bf 8f6f 	isb	sy
        __libc_init_array();
     360:	4b09      	ldr	r3, [pc, #36]	; (388 <Reset_Handler+0x90>)
     362:	4798      	blx	r3
        main();
     364:	4b09      	ldr	r3, [pc, #36]	; (38c <Reset_Handler+0x94>)
     366:	4798      	blx	r3
     368:	e7fe      	b.n	368 <Reset_Handler+0x70>
     36a:	bf00      	nop
     36c:	20000000 	.word	0x20000000
     370:	00009ac4 	.word	0x00009ac4
     374:	2000009c 	.word	0x2000009c
     378:	200023d0 	.word	0x200023d0
     37c:	200000a0 	.word	0x200000a0
     380:	e000ed00 	.word	0xe000ed00
     384:	00000000 	.word	0x00000000
     388:	0000964d 	.word	0x0000964d
     38c:	00009235 	.word	0x00009235

00000390 <sd_mmc_test_unit_ready>:
 *
 * \return CTRL_GOOD or card status like CTRL_NO_PRESENT, CTRL_BUSY, CTRL_FAIL.
 *
 */
static ctrl_status_t sd_mmc_test_unit_ready(uint8_t slot)
{
     390:	b510      	push	{r4, lr}
     392:	4604      	mov	r4, r0
	switch (sd_mmc_check(slot)) {
     394:	4b0a      	ldr	r3, [pc, #40]	; (3c0 <sd_mmc_test_unit_ready+0x30>)
     396:	4798      	blx	r3
     398:	2801      	cmp	r0, #1
     39a:	d00f      	beq.n	3bc <sd_mmc_test_unit_ready+0x2c>
     39c:	b120      	cbz	r0, 3a8 <sd_mmc_test_unit_ready+0x18>
		return CTRL_BUSY;

	case SD_MMC_ERR_NO_CARD:
		return CTRL_NO_PRESENT;
	default:
		return CTRL_FAIL;
     39e:	2802      	cmp	r0, #2
     3a0:	bf0c      	ite	eq
     3a2:	2002      	moveq	r0, #2
     3a4:	2001      	movne	r0, #1
     3a6:	bd10      	pop	{r4, pc}
		if (sd_mmc_get_type(slot) & (CARD_TYPE_SD | CARD_TYPE_MMC)) {
     3a8:	4620      	mov	r0, r4
     3aa:	4b06      	ldr	r3, [pc, #24]	; (3c4 <sd_mmc_test_unit_ready+0x34>)
     3ac:	4798      	blx	r3
     3ae:	f000 0003 	and.w	r0, r0, #3
			return CTRL_NO_PRESENT;
     3b2:	2800      	cmp	r0, #0
     3b4:	bf14      	ite	ne
     3b6:	2000      	movne	r0, #0
     3b8:	2002      	moveq	r0, #2
     3ba:	bd10      	pop	{r4, pc}
		return CTRL_BUSY;
     3bc:	2003      	movs	r0, #3
	}
}
     3be:	bd10      	pop	{r4, pc}
     3c0:	00006091 	.word	0x00006091
     3c4:	000066d9 	.word	0x000066d9

000003c8 <sd_mmc_read_capacity>:
 *
 * \return CTRL_GOOD or card status like CTRL_NO_PRESENT, CTRL_BUSY, CTRL_FAIL.
 *
 */
static ctrl_status_t sd_mmc_read_capacity(uint8_t slot, uint32_t *nb_sector)
{
     3c8:	b538      	push	{r3, r4, r5, lr}
     3ca:	4604      	mov	r4, r0
     3cc:	460d      	mov	r5, r1
	// Return last sector address (-1)
	*nb_sector = (sd_mmc_get_capacity(slot) * 2) - 1;
     3ce:	4b04      	ldr	r3, [pc, #16]	; (3e0 <sd_mmc_read_capacity+0x18>)
     3d0:	4798      	blx	r3
     3d2:	0040      	lsls	r0, r0, #1
     3d4:	3801      	subs	r0, #1
     3d6:	6028      	str	r0, [r5, #0]
	return sd_mmc_test_unit_ready(slot);
     3d8:	4620      	mov	r0, r4
     3da:	4b02      	ldr	r3, [pc, #8]	; (3e4 <sd_mmc_read_capacity+0x1c>)
     3dc:	4798      	blx	r3
}
     3de:	bd38      	pop	{r3, r4, r5, pc}
     3e0:	000066fd 	.word	0x000066fd
     3e4:	00000391 	.word	0x00000391

000003e8 <disk_initialize>:
 *
 * \return 0 or disk status in combination of DSTATUS bits
 *         (STA_NOINIT, STA_PROTECT).
 */
dstatus_t disk_initialize(uint8_t drv)
{
     3e8:	b510      	push	{r4, lr}
     3ea:	4604      	mov	r4, r0
	int           i;
	ctrl_status_t mem_status;

	/* Check LUN ready (USB disk report CTRL_BUSY then CTRL_GOOD) */
	for (i = 0; i < 2; i++) {
		mem_status = sd_mmc_test_unit_ready(drv);
     3ec:	4b0a      	ldr	r3, [pc, #40]	; (418 <disk_initialize+0x30>)
     3ee:	4798      	blx	r3
		if (CTRL_BUSY != mem_status) {
     3f0:	2803      	cmp	r0, #3
     3f2:	d106      	bne.n	402 <disk_initialize+0x1a>
		mem_status = sd_mmc_test_unit_ready(drv);
     3f4:	4620      	mov	r0, r4
     3f6:	4b08      	ldr	r3, [pc, #32]	; (418 <disk_initialize+0x30>)
     3f8:	4798      	blx	r3
		if (CTRL_BUSY != mem_status) {
     3fa:	2803      	cmp	r0, #3
     3fc:	d101      	bne.n	402 <disk_initialize+0x1a>
			break;
		}
	}
	if (mem_status != CTRL_GOOD) {
		return STA_NOINIT;
     3fe:	2001      	movs	r0, #1
     400:	bd10      	pop	{r4, pc}
	if (mem_status != CTRL_GOOD) {
     402:	b938      	cbnz	r0, 414 <disk_initialize+0x2c>
	}

	/* Check Write Protection Status */
	if (sd_mmc_is_write_protected(drv)) {
     404:	4620      	mov	r0, r4
     406:	4b05      	ldr	r3, [pc, #20]	; (41c <disk_initialize+0x34>)
     408:	4798      	blx	r3
     40a:	2800      	cmp	r0, #0
		return STA_PROTECT;
	}

	/* The memory should already be initialized */
	return 0;
     40c:	bf14      	ite	ne
     40e:	2004      	movne	r0, #4
     410:	2000      	moveq	r0, #0
     412:	bd10      	pop	{r4, pc}
		return STA_NOINIT;
     414:	2001      	movs	r0, #1
}
     416:	bd10      	pop	{r4, pc}
     418:	00000391 	.word	0x00000391
     41c:	00006721 	.word	0x00006721

00000420 <disk_status>:
 *
 * \return 0 or disk status in combination of DSTATUS bits
 *         (STA_NOINIT, STA_NODISK, STA_PROTECT).
 */
dstatus_t disk_status(uint8_t drv)
{
     420:	b508      	push	{r3, lr}
	switch (sd_mmc_test_unit_ready(drv)) {
     422:	4b05      	ldr	r3, [pc, #20]	; (438 <disk_status+0x18>)
     424:	4798      	blx	r3
     426:	b120      	cbz	r0, 432 <disk_status+0x12>
	case CTRL_GOOD:
		return ERR_NONE;
	case CTRL_NO_PRESENT:
		return STA_NOINIT | STA_NODISK;
	default:
		return STA_NOINIT;
     428:	2802      	cmp	r0, #2
     42a:	bf0c      	ite	eq
     42c:	2003      	moveq	r0, #3
     42e:	2001      	movne	r0, #1
     430:	bd08      	pop	{r3, pc}
		return ERR_NONE;
     432:	2000      	movs	r0, #0
	}
}
     434:	bd08      	pop	{r3, pc}
     436:	bf00      	nop
     438:	00000391 	.word	0x00000391

0000043c <disk_read>:
 * \param count Number of sectors to read (1..255).
 *
 * \return ERR_NONE for success, otherwise DRESULT error code.
 */
dstatus_t disk_read(uint8_t drv, uint8_t *buff, uint32_t sector, uint8_t count)
{
     43c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     440:	b083      	sub	sp, #12
     442:	4683      	mov	fp, r0
     444:	4688      	mov	r8, r1
     446:	4614      	mov	r4, r2
     448:	461d      	mov	r5, r3
	uint8_t  uc_sector_size = SECTOR_SIZE_512;
	uint32_t i;
	uint32_t ul_last_sector_num;

	/* Check valid address */
	sd_mmc_read_capacity(drv, &ul_last_sector_num);
     44a:	a901      	add	r1, sp, #4
     44c:	4b17      	ldr	r3, [pc, #92]	; (4ac <disk_read+0x70>)
     44e:	4798      	blx	r3
	if ((sector + count * uc_sector_size) > (ul_last_sector_num + 1) * uc_sector_size) {
     450:	192e      	adds	r6, r5, r4
     452:	9b01      	ldr	r3, [sp, #4]
     454:	3301      	adds	r3, #1
     456:	429e      	cmp	r6, r3
     458:	d901      	bls.n	45e <disk_read+0x22>
		return ERR_INVALID_ARG;
     45a:	20f3      	movs	r0, #243	; 0xf3
     45c:	e01f      	b.n	49e <disk_read+0x62>
	}

	/* Read the data */
	for (i = 0; i < count; i++) {
     45e:	b30d      	cbz	r5, 4a4 <disk_read+0x68>
	switch (sd_mmc_init_read_blocks(slot, addr, 1)) {
     460:	4f13      	ldr	r7, [pc, #76]	; (4b0 <disk_read+0x74>)
		if (SD_MMC_OK != sd_mmc_start_read_blocks(ram, 1))
     462:	f8df 9050 	ldr.w	r9, [pc, #80]	; 4b4 <disk_read+0x78>
		if (SD_MMC_OK != sd_mmc_wait_end_of_read_blocks(false))
     466:	f8df a050 	ldr.w	sl, [pc, #80]	; 4b8 <disk_read+0x7c>
     46a:	e00f      	b.n	48c <disk_read+0x50>
		if (SD_MMC_OK != sd_mmc_start_read_blocks(ram, 1))
     46c:	2101      	movs	r1, #1
     46e:	4640      	mov	r0, r8
     470:	47c8      	blx	r9
     472:	b998      	cbnz	r0, 49c <disk_read+0x60>
		if (SD_MMC_OK != sd_mmc_wait_end_of_read_blocks(false))
     474:	47d0      	blx	sl
		return CTRL_NO_PRESENT;
     476:	3000      	adds	r0, #0
     478:	bf18      	it	ne
     47a:	2001      	movne	r0, #1
     47c:	e000      	b.n	480 <disk_read+0x44>
     47e:	2002      	movs	r0, #2
		if (sd_mmc_mem_2_ram(drv, sector + uc_sector_size * i, buff + uc_sector_size * SECTOR_SIZE_DEFAULT * i)
     480:	b990      	cbnz	r0, 4a8 <disk_read+0x6c>
     482:	3401      	adds	r4, #1
     484:	f508 7800 	add.w	r8, r8, #512	; 0x200
	for (i = 0; i < count; i++) {
     488:	42a6      	cmp	r6, r4
     48a:	d008      	beq.n	49e <disk_read+0x62>
	switch (sd_mmc_init_read_blocks(slot, addr, 1)) {
     48c:	2201      	movs	r2, #1
     48e:	4621      	mov	r1, r4
     490:	4658      	mov	r0, fp
     492:	47b8      	blx	r7
     494:	2800      	cmp	r0, #0
     496:	d0e9      	beq.n	46c <disk_read+0x30>
     498:	2802      	cmp	r0, #2
     49a:	d0f0      	beq.n	47e <disk_read+0x42>
		    != CTRL_GOOD) {
			return ERR_INVALID_DATA;
     49c:	20ff      	movs	r0, #255	; 0xff
		}
	}

	return ERR_NONE;
}
     49e:	b003      	add	sp, #12
     4a0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	return ERR_NONE;
     4a4:	2000      	movs	r0, #0
     4a6:	e7fa      	b.n	49e <disk_read+0x62>
			return ERR_INVALID_DATA;
     4a8:	20ff      	movs	r0, #255	; 0xff
     4aa:	e7f8      	b.n	49e <disk_read+0x62>
     4ac:	000003c9 	.word	0x000003c9
     4b0:	00006799 	.word	0x00006799
     4b4:	00006871 	.word	0x00006871
     4b8:	000068bd 	.word	0x000068bd

000004bc <disk_write>:
 * \param count Number of sectors to read (1..255).
 *
 * \return ERR_NONE for success, otherwise DRESULT error code.
 */
dstatus_t disk_write(uint8_t drv, uint8_t const *buff, uint32_t sector, uint8_t count)
{
     4bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     4c0:	b083      	sub	sp, #12
     4c2:	4683      	mov	fp, r0
     4c4:	4688      	mov	r8, r1
     4c6:	4614      	mov	r4, r2
     4c8:	461d      	mov	r5, r3
	uint8_t  uc_sector_size = SECTOR_SIZE_512;
	uint32_t i;
	uint32_t ul_last_sector_num;

	/* Check valid address */
	sd_mmc_read_capacity(drv, &ul_last_sector_num);
     4ca:	a901      	add	r1, sp, #4
     4cc:	4b17      	ldr	r3, [pc, #92]	; (52c <disk_write+0x70>)
     4ce:	4798      	blx	r3
	if ((sector + count * uc_sector_size) > (ul_last_sector_num + 1) * uc_sector_size) {
     4d0:	192e      	adds	r6, r5, r4
     4d2:	9b01      	ldr	r3, [sp, #4]
     4d4:	3301      	adds	r3, #1
     4d6:	429e      	cmp	r6, r3
     4d8:	d901      	bls.n	4de <disk_write+0x22>
		return ERR_INVALID_ARG;
     4da:	20f3      	movs	r0, #243	; 0xf3
     4dc:	e01f      	b.n	51e <disk_write+0x62>
	}

	/* Write the data */
	for (i = 0; i < count; i++) {
     4de:	b30d      	cbz	r5, 524 <disk_write+0x68>
	switch (sd_mmc_init_write_blocks(slot, addr, 1)) {
     4e0:	4f13      	ldr	r7, [pc, #76]	; (530 <disk_write+0x74>)
		if (SD_MMC_OK != sd_mmc_start_write_blocks(ram, 1))
     4e2:	f8df 9050 	ldr.w	r9, [pc, #80]	; 534 <disk_write+0x78>
		if (SD_MMC_OK != sd_mmc_wait_end_of_write_blocks(false))
     4e6:	f8df a050 	ldr.w	sl, [pc, #80]	; 538 <disk_write+0x7c>
     4ea:	e00f      	b.n	50c <disk_write+0x50>
		if (SD_MMC_OK != sd_mmc_start_write_blocks(ram, 1))
     4ec:	2101      	movs	r1, #1
     4ee:	4640      	mov	r0, r8
     4f0:	47c8      	blx	r9
     4f2:	b998      	cbnz	r0, 51c <disk_write+0x60>
		if (SD_MMC_OK != sd_mmc_wait_end_of_write_blocks(false))
     4f4:	47d0      	blx	sl
		return CTRL_NO_PRESENT;
     4f6:	3000      	adds	r0, #0
     4f8:	bf18      	it	ne
     4fa:	2001      	movne	r0, #1
     4fc:	e000      	b.n	500 <disk_write+0x44>
     4fe:	2002      	movs	r0, #2
		if (sd_mmc_ram_2_mem(drv, sector + uc_sector_size * i, buff + uc_sector_size * SECTOR_SIZE_DEFAULT * i)
     500:	b990      	cbnz	r0, 528 <disk_write+0x6c>
     502:	3401      	adds	r4, #1
     504:	f508 7800 	add.w	r8, r8, #512	; 0x200
	for (i = 0; i < count; i++) {
     508:	42a6      	cmp	r6, r4
     50a:	d008      	beq.n	51e <disk_write+0x62>
	switch (sd_mmc_init_write_blocks(slot, addr, 1)) {
     50c:	2201      	movs	r2, #1
     50e:	4621      	mov	r1, r4
     510:	4658      	mov	r0, fp
     512:	47b8      	blx	r7
     514:	2800      	cmp	r0, #0
     516:	d0e9      	beq.n	4ec <disk_write+0x30>
     518:	2802      	cmp	r0, #2
     51a:	d0f0      	beq.n	4fe <disk_write+0x42>
		    != CTRL_GOOD) {
			return ERR_INVALID_DATA;
     51c:	20ff      	movs	r0, #255	; 0xff
		}
	}

	return ERR_NONE;
}
     51e:	b003      	add	sp, #12
     520:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	return ERR_NONE;
     524:	2000      	movs	r0, #0
     526:	e7fa      	b.n	51e <disk_write+0x62>
			return ERR_INVALID_DATA;
     528:	20ff      	movs	r0, #255	; 0xff
     52a:	e7f8      	b.n	51e <disk_write+0x62>
     52c:	000003c9 	.word	0x000003c9
     530:	0000692d 	.word	0x0000692d
     534:	000069cd 	.word	0x000069cd
     538:	00006a19 	.word	0x00006a19

0000053c <disk_ioctl>:
 * \param buff Buffer to send/receive control data.
 *
 * \return ERR_NONE for success, otherwise DRESULT error code.
 */
dstatus_t disk_ioctl(uint8_t drv, uint8_t ctrl, void *buff)
{
     53c:	b510      	push	{r4, lr}
     53e:	b082      	sub	sp, #8
     540:	4614      	mov	r4, r2
	dstatus_t res = ERR_INVALID_ARG;

	switch (ctrl) {
     542:	2903      	cmp	r1, #3
     544:	d81a      	bhi.n	57c <disk_ioctl+0x40>
     546:	e8df f001 	tbb	[pc, r1]
     54a:	0712      	.short	0x0712
     54c:	020f      	.short	0x020f
	case GET_BLOCK_SIZE:
		*(unsigned long *)buff = 1;
     54e:	2301      	movs	r3, #1
     550:	6013      	str	r3, [r2, #0]
		res                    = ERR_NONE;
     552:	2000      	movs	r0, #0
	default:
		res = ERR_INVALID_ARG;
	}

	return res;
}
     554:	b002      	add	sp, #8
     556:	bd10      	pop	{r4, pc}
		sd_mmc_read_capacity(drv, &ul_last_sector_num);
     558:	a901      	add	r1, sp, #4
     55a:	4b09      	ldr	r3, [pc, #36]	; (580 <disk_ioctl+0x44>)
     55c:	4798      	blx	r3
		*(unsigned long *)buff = ul_last_sector_num + 1;
     55e:	9b01      	ldr	r3, [sp, #4]
     560:	3301      	adds	r3, #1
     562:	6023      	str	r3, [r4, #0]
		res = ERR_NONE;
     564:	2000      	movs	r0, #0
	} break;
     566:	e7f5      	b.n	554 <disk_ioctl+0x18>
		*(uint8_t *)buff = uc_sector_size * SECTOR_SIZE_DEFAULT;
     568:	2000      	movs	r0, #0
     56a:	7010      	strb	r0, [r2, #0]
	} break;
     56c:	e7f2      	b.n	554 <disk_ioctl+0x18>
		if (sd_mmc_test_unit_ready(drv) == CTRL_GOOD) {
     56e:	4b05      	ldr	r3, [pc, #20]	; (584 <disk_ioctl+0x48>)
     570:	4798      	blx	r3
     572:	2800      	cmp	r0, #0
			res = ERR_NOT_READY;
     574:	bf0c      	ite	eq
     576:	2000      	moveq	r0, #0
     578:	20e3      	movne	r0, #227	; 0xe3
     57a:	e7eb      	b.n	554 <disk_ioctl+0x18>
		res = ERR_INVALID_ARG;
     57c:	20f3      	movs	r0, #243	; 0xf3
     57e:	e7e9      	b.n	554 <disk_ioctl+0x18>
     580:	000003c9 	.word	0x000003c9
     584:	00000391 	.word	0x00000391

00000588 <diskio_init>:
 */

#include "diskio_start.h"

void diskio_init(void)
{
     588:	4770      	bx	lr
	...

0000058c <EXTERNAL_IRQ_0_init>:
struct pwm_descriptor PWM_0;

struct pwm_descriptor PWM_1;

void EXTERNAL_IRQ_0_init(void)
{
     58c:	b508      	push	{r3, lr}
}

static inline void hri_gclk_write_PCHCTRL_reg(const void *const hw, uint8_t index, hri_gclk_pchctrl_reg_t data)
{
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->PCHCTRL[index].reg = data;
     58e:	2240      	movs	r2, #64	; 0x40
     590:	4b3b      	ldr	r3, [pc, #236]	; (680 <EXTERNAL_IRQ_0_init+0xf4>)
     592:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
}

static inline void hri_mclk_set_APBAMASK_EIC_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_EIC;
     596:	4a3b      	ldr	r2, [pc, #236]	; (684 <EXTERNAL_IRQ_0_init+0xf8>)
     598:	6953      	ldr	r3, [r2, #20]
     59a:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
     59e:	6153      	str	r3, [r2, #20]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = ~data;
}

static inline void hri_port_clear_DIR_reg(const void *const hw, uint8_t submodule_index, hri_port_dir_reg_t mask)
{
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     5a0:	4b39      	ldr	r3, [pc, #228]	; (688 <EXTERNAL_IRQ_0_init+0xfc>)
     5a2:	f44f 3280 	mov.w	r2, #65536	; 0x10000
     5a6:	605a      	str	r2, [r3, #4]

static inline void hri_port_write_WRCONFIG_reg(const void *const hw, uint8_t submodule_index,
                                               hri_port_wrconfig_reg_t data)
{
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     5a8:	4938      	ldr	r1, [pc, #224]	; (68c <EXTERNAL_IRQ_0_init+0x100>)
     5aa:	6299      	str	r1, [r3, #40]	; 0x28
     5ac:	f102 4240 	add.w	r2, r2, #3221225472	; 0xc0000000
     5b0:	f102 1201 	add.w	r2, r2, #65537	; 0x10001
     5b4:	629a      	str	r2, [r3, #40]	; 0x28
}

static inline void hri_port_clear_PINCFG_PULLEN_bit(const void *const hw, uint8_t submodule_index, uint8_t index)
{
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     5b6:	f893 2050 	ldrb.w	r2, [r3, #80]	; 0x50
     5ba:	f002 02fb 	and.w	r2, r2, #251	; 0xfb
     5be:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     5c2:	f893 2050 	ldrb.w	r2, [r3, #80]	; 0x50
	tmp &= ~PORT_PINCFG_PMUXEN;
     5c6:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     5ca:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     5ce:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     5d2:	f893 2038 	ldrb.w	r2, [r3, #56]	; 0x38
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     5d6:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     5da:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     5de:	f44f 3200 	mov.w	r2, #131072	; 0x20000
     5e2:	605a      	str	r2, [r3, #4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     5e4:	6299      	str	r1, [r3, #40]	; 0x28
     5e6:	4a2a      	ldr	r2, [pc, #168]	; (690 <EXTERNAL_IRQ_0_init+0x104>)
     5e8:	629a      	str	r2, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     5ea:	f893 2051 	ldrb.w	r2, [r3, #81]	; 0x51
     5ee:	f002 02fb 	and.w	r2, r2, #251	; 0xfb
     5f2:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     5f6:	f893 2051 	ldrb.w	r2, [r3, #81]	; 0x51
	tmp &= ~PORT_PINCFG_PMUXEN;
     5fa:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     5fe:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     602:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     606:	f893 2038 	ldrb.w	r2, [r3, #56]	; 0x38
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     60a:	f002 020f 	and.w	r2, r2, #15
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     60e:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     612:	f44f 2280 	mov.w	r2, #262144	; 0x40000
     616:	605a      	str	r2, [r3, #4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     618:	6299      	str	r1, [r3, #40]	; 0x28
     61a:	4a1e      	ldr	r2, [pc, #120]	; (694 <EXTERNAL_IRQ_0_init+0x108>)
     61c:	629a      	str	r2, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     61e:	f893 2052 	ldrb.w	r2, [r3, #82]	; 0x52
     622:	f002 02fb 	and.w	r2, r2, #251	; 0xfb
     626:	f883 2052 	strb.w	r2, [r3, #82]	; 0x52
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     62a:	f893 2052 	ldrb.w	r2, [r3, #82]	; 0x52
	tmp &= ~PORT_PINCFG_PMUXEN;
     62e:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     632:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     636:	f883 2052 	strb.w	r2, [r3, #82]	; 0x52
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     63a:	f893 2039 	ldrb.w	r2, [r3, #57]	; 0x39
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     63e:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     642:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     646:	f44f 2200 	mov.w	r2, #524288	; 0x80000
     64a:	605a      	str	r2, [r3, #4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     64c:	6299      	str	r1, [r3, #40]	; 0x28
     64e:	4a12      	ldr	r2, [pc, #72]	; (698 <EXTERNAL_IRQ_0_init+0x10c>)
     650:	629a      	str	r2, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     652:	f893 2053 	ldrb.w	r2, [r3, #83]	; 0x53
     656:	f002 02fb 	and.w	r2, r2, #251	; 0xfb
     65a:	f883 2053 	strb.w	r2, [r3, #83]	; 0x53
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     65e:	f893 2053 	ldrb.w	r2, [r3, #83]	; 0x53
	tmp &= ~PORT_PINCFG_PMUXEN;
     662:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     666:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     66a:	f883 2053 	strb.w	r2, [r3, #83]	; 0x53
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     66e:	f893 2039 	ldrb.w	r2, [r3, #57]	; 0x39
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     672:	f002 020f 	and.w	r2, r2, #15
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     676:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(PA19, PINMUX_PA19A_EIC_EXTINT3);

	ext_irq_init();
     67a:	4b08      	ldr	r3, [pc, #32]	; (69c <EXTERNAL_IRQ_0_init+0x110>)
     67c:	4798      	blx	r3
     67e:	bd08      	pop	{r3, pc}
     680:	40001c00 	.word	0x40001c00
     684:	40000800 	.word	0x40000800
     688:	41008000 	.word	0x41008000
     68c:	40020000 	.word	0x40020000
     690:	c0020002 	.word	0xc0020002
     694:	c0020004 	.word	0xc0020004
     698:	c0020008 	.word	0xc0020008
     69c:	00002429 	.word	0x00002429

000006a0 <CALENDER_INTERFACE_CLOCK_init>:
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_RTC;
     6a0:	4a02      	ldr	r2, [pc, #8]	; (6ac <CALENDER_INTERFACE_CLOCK_init+0xc>)
     6a2:	6953      	ldr	r3, [r2, #20]
     6a4:	f443 7300 	orr.w	r3, r3, #512	; 0x200
     6a8:	6153      	str	r3, [r2, #20]
     6aa:	4770      	bx	lr
     6ac:	40000800 	.word	0x40000800

000006b0 <CALENDER_INTERFACE_init>:
{
	hri_mclk_set_APBAMASK_RTC_bit(MCLK);
}

void CALENDER_INTERFACE_init(void)
{
     6b0:	b508      	push	{r3, lr}
	CALENDER_INTERFACE_CLOCK_init();
     6b2:	4b03      	ldr	r3, [pc, #12]	; (6c0 <CALENDER_INTERFACE_init+0x10>)
     6b4:	4798      	blx	r3
	calendar_init(&CALENDER_INTERFACE, RTC);
     6b6:	4903      	ldr	r1, [pc, #12]	; (6c4 <CALENDER_INTERFACE_init+0x14>)
     6b8:	4803      	ldr	r0, [pc, #12]	; (6c8 <CALENDER_INTERFACE_init+0x18>)
     6ba:	4b04      	ldr	r3, [pc, #16]	; (6cc <CALENDER_INTERFACE_init+0x1c>)
     6bc:	4798      	blx	r3
     6be:	bd08      	pop	{r3, pc}
     6c0:	000006a1 	.word	0x000006a1
     6c4:	40002400 	.word	0x40002400
     6c8:	20001640 	.word	0x20001640
     6cc:	00002359 	.word	0x00002359

000006d0 <SPI_0_PORT_init>:
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     6d0:	4b36      	ldr	r3, [pc, #216]	; (7ac <SPI_0_PORT_init+0xdc>)
     6d2:	2210      	movs	r2, #16
     6d4:	609a      	str	r2, [r3, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     6d6:	4936      	ldr	r1, [pc, #216]	; (7b0 <SPI_0_PORT_init+0xe0>)
     6d8:	6299      	str	r1, [r3, #40]	; 0x28
     6da:	f04f 4140 	mov.w	r1, #3221225472	; 0xc0000000
     6de:	6299      	str	r1, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     6e0:	615a      	str	r2, [r3, #20]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     6e2:	f893 2044 	ldrb.w	r2, [r3, #68]	; 0x44
	tmp &= ~PORT_PINCFG_PMUXEN;
     6e6:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     6ea:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     6ee:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     6f2:	f893 2032 	ldrb.w	r2, [r3, #50]	; 0x32
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     6f6:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXE(data);
     6fa:	f042 0203 	orr.w	r2, r2, #3
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     6fe:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     702:	2220      	movs	r2, #32
     704:	605a      	str	r2, [r3, #4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     706:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
     70a:	f502 3200 	add.w	r2, r2, #131072	; 0x20000
     70e:	629a      	str	r2, [r3, #40]	; 0x28
     710:	4828      	ldr	r0, [pc, #160]	; (7b4 <SPI_0_PORT_init+0xe4>)
     712:	6298      	str	r0, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     714:	f893 2045 	ldrb.w	r2, [r3, #69]	; 0x45
     718:	f002 02fb 	and.w	r2, r2, #251	; 0xfb
     71c:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     720:	f893 2045 	ldrb.w	r2, [r3, #69]	; 0x45
	tmp &= ~PORT_PINCFG_PMUXEN;
     724:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     728:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     72c:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     730:	f893 2032 	ldrb.w	r2, [r3, #50]	; 0x32
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     734:	f002 020f 	and.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
     738:	f042 0230 	orr.w	r2, r2, #48	; 0x30
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     73c:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     740:	2240      	movs	r2, #64	; 0x40
     742:	605a      	str	r2, [r3, #4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     744:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
     748:	f502 3200 	add.w	r2, r2, #131072	; 0x20000
     74c:	629a      	str	r2, [r3, #40]	; 0x28
     74e:	6298      	str	r0, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     750:	f893 2046 	ldrb.w	r2, [r3, #70]	; 0x46
     754:	f002 02fb 	and.w	r2, r2, #251	; 0xfb
     758:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     75c:	f893 2046 	ldrb.w	r2, [r3, #70]	; 0x46
	tmp &= ~PORT_PINCFG_PMUXEN;
     760:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     764:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     768:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     76c:	f893 2033 	ldrb.w	r2, [r3, #51]	; 0x33
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     770:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXE(data);
     774:	f042 0203 	orr.w	r2, r2, #3
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     778:	f883 2033 	strb.w	r2, [r3, #51]	; 0x33
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     77c:	2280      	movs	r2, #128	; 0x80
     77e:	609a      	str	r2, [r3, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     780:	480d      	ldr	r0, [pc, #52]	; (7b8 <SPI_0_PORT_init+0xe8>)
     782:	6298      	str	r0, [r3, #40]	; 0x28
     784:	6299      	str	r1, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     786:	615a      	str	r2, [r3, #20]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     788:	f893 2047 	ldrb.w	r2, [r3, #71]	; 0x47
	tmp &= ~PORT_PINCFG_PMUXEN;
     78c:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     790:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     794:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     798:	f893 2033 	ldrb.w	r2, [r3, #51]	; 0x33
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     79c:	f002 020f 	and.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
     7a0:	f042 0230 	orr.w	r2, r2, #48	; 0x30
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     7a4:	f883 2033 	strb.w	r2, [r3, #51]	; 0x33
     7a8:	4770      	bx	lr
     7aa:	bf00      	nop
     7ac:	41008000 	.word	0x41008000
     7b0:	40000010 	.word	0x40000010
     7b4:	c0020000 	.word	0xc0020000
     7b8:	40000080 	.word	0x40000080

000007bc <SPI_0_CLOCK_init>:
     7bc:	4b06      	ldr	r3, [pc, #24]	; (7d8 <SPI_0_CLOCK_init+0x1c>)
     7be:	2240      	movs	r2, #64	; 0x40
     7c0:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
     7c4:	2243      	movs	r2, #67	; 0x43
     7c6:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
}

static inline void hri_mclk_set_APBAMASK_SERCOM0_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_SERCOM0;
     7ca:	4a04      	ldr	r2, [pc, #16]	; (7dc <SPI_0_CLOCK_init+0x20>)
     7cc:	6953      	ldr	r3, [r2, #20]
     7ce:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
     7d2:	6153      	str	r3, [r2, #20]
     7d4:	4770      	bx	lr
     7d6:	bf00      	nop
     7d8:	40001c00 	.word	0x40001c00
     7dc:	40000800 	.word	0x40000800

000007e0 <SPI_0_init>:

	hri_mclk_set_APBAMASK_SERCOM0_bit(MCLK);
}

void SPI_0_init(void)
{
     7e0:	b510      	push	{r4, lr}
	SPI_0_CLOCK_init();
     7e2:	4b05      	ldr	r3, [pc, #20]	; (7f8 <SPI_0_init+0x18>)
     7e4:	4798      	blx	r3
	spi_s_async_init(&SPI_0, SERCOM0, (uint8_t *)SPI_0_buf, 32);
     7e6:	2320      	movs	r3, #32
     7e8:	4a04      	ldr	r2, [pc, #16]	; (7fc <SPI_0_init+0x1c>)
     7ea:	4905      	ldr	r1, [pc, #20]	; (800 <SPI_0_init+0x20>)
     7ec:	4805      	ldr	r0, [pc, #20]	; (804 <SPI_0_init+0x24>)
     7ee:	4c06      	ldr	r4, [pc, #24]	; (808 <SPI_0_init+0x28>)
     7f0:	47a0      	blx	r4
	SPI_0_PORT_init();
     7f2:	4b06      	ldr	r3, [pc, #24]	; (80c <SPI_0_init+0x2c>)
     7f4:	4798      	blx	r3
     7f6:	bd10      	pop	{r4, pc}
     7f8:	000007bd 	.word	0x000007bd
     7fc:	200000bc 	.word	0x200000bc
     800:	40003000 	.word	0x40003000
     804:	200015dc 	.word	0x200015dc
     808:	00002ae1 	.word	0x00002ae1
     80c:	000006d1 	.word	0x000006d1

00000810 <IO_BUS_PORT_init>:
}

void IO_BUS_PORT_init(void)
{
     810:	b4f0      	push	{r4, r5, r6, r7}
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     812:	4b5e      	ldr	r3, [pc, #376]	; (98c <IO_BUS_PORT_init+0x17c>)
     814:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
     818:	6098      	str	r0, [r3, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     81a:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
     81e:	629a      	str	r2, [r3, #40]	; 0x28
     820:	4c5b      	ldr	r4, [pc, #364]	; (990 <IO_BUS_PORT_init+0x180>)
     822:	629c      	str	r4, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     824:	6158      	str	r0, [r3, #20]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     826:	f893 1055 	ldrb.w	r1, [r3, #85]	; 0x55
     82a:	f001 01fb 	and.w	r1, r1, #251	; 0xfb
     82e:	f883 1055 	strb.w	r1, [r3, #85]	; 0x55
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     832:	f893 1055 	ldrb.w	r1, [r3, #85]	; 0x55
	tmp &= ~PORT_PINCFG_PMUXEN;
     836:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     83a:	f041 0101 	orr.w	r1, r1, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     83e:	f883 1055 	strb.w	r1, [r3, #85]	; 0x55
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     842:	f893 103a 	ldrb.w	r1, [r3, #58]	; 0x3a
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     846:	f001 010f 	and.w	r1, r1, #15
	tmp |= PORT_PMUX_PMUXO(data);
     84a:	f041 0180 	orr.w	r1, r1, #128	; 0x80
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     84e:	f883 103a 	strb.w	r1, [r3, #58]	; 0x3a
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     852:	f44f 1580 	mov.w	r5, #1048576	; 0x100000
     856:	609d      	str	r5, [r3, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     858:	629a      	str	r2, [r3, #40]	; 0x28
     85a:	4e4e      	ldr	r6, [pc, #312]	; (994 <IO_BUS_PORT_init+0x184>)
     85c:	629e      	str	r6, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     85e:	615d      	str	r5, [r3, #20]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     860:	f893 1054 	ldrb.w	r1, [r3, #84]	; 0x54
     864:	f001 01fb 	and.w	r1, r1, #251	; 0xfb
     868:	f883 1054 	strb.w	r1, [r3, #84]	; 0x54
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     86c:	f893 1054 	ldrb.w	r1, [r3, #84]	; 0x54
	tmp &= ~PORT_PINCFG_PMUXEN;
     870:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     874:	f041 0101 	orr.w	r1, r1, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     878:	f883 1054 	strb.w	r1, [r3, #84]	; 0x54
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     87c:	f893 103a 	ldrb.w	r1, [r3, #58]	; 0x3a
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     880:	f001 01f0 	and.w	r1, r1, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXE(data);
     884:	f041 0108 	orr.w	r1, r1, #8
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     888:	f883 103a 	strb.w	r1, [r3, #58]	; 0x3a
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     88c:	f44f 2180 	mov.w	r1, #262144	; 0x40000
     890:	f8c3 1088 	str.w	r1, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     894:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
     898:	4f3f      	ldr	r7, [pc, #252]	; (998 <IO_BUS_PORT_init+0x188>)
     89a:	f8c3 70a8 	str.w	r7, [r3, #168]	; 0xa8
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     89e:	f8c3 1094 	str.w	r1, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     8a2:	f893 10d2 	ldrb.w	r1, [r3, #210]	; 0xd2
     8a6:	f001 01fb 	and.w	r1, r1, #251	; 0xfb
     8aa:	f883 10d2 	strb.w	r1, [r3, #210]	; 0xd2
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     8ae:	f893 10d2 	ldrb.w	r1, [r3, #210]	; 0xd2
	tmp &= ~PORT_PINCFG_PMUXEN;
     8b2:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     8b6:	f041 0101 	orr.w	r1, r1, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     8ba:	f883 10d2 	strb.w	r1, [r3, #210]	; 0xd2
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     8be:	f893 10b9 	ldrb.w	r1, [r3, #185]	; 0xb9
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     8c2:	f001 01f0 	and.w	r1, r1, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXE(data);
     8c6:	f041 0108 	orr.w	r1, r1, #8
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     8ca:	f883 10b9 	strb.w	r1, [r3, #185]	; 0xb9
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     8ce:	f44f 2100 	mov.w	r1, #524288	; 0x80000
     8d2:	f8c3 1088 	str.w	r1, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     8d6:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
     8da:	3704      	adds	r7, #4
     8dc:	f8c3 70a8 	str.w	r7, [r3, #168]	; 0xa8
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     8e0:	f8c3 1094 	str.w	r1, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     8e4:	f893 10d3 	ldrb.w	r1, [r3, #211]	; 0xd3
     8e8:	f001 01fb 	and.w	r1, r1, #251	; 0xfb
     8ec:	f883 10d3 	strb.w	r1, [r3, #211]	; 0xd3
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     8f0:	f893 10d3 	ldrb.w	r1, [r3, #211]	; 0xd3
	tmp &= ~PORT_PINCFG_PMUXEN;
     8f4:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     8f8:	f041 0101 	orr.w	r1, r1, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     8fc:	f883 10d3 	strb.w	r1, [r3, #211]	; 0xd3
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     900:	f893 10b9 	ldrb.w	r1, [r3, #185]	; 0xb9
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     904:	f001 010f 	and.w	r1, r1, #15
	tmp |= PORT_PMUX_PMUXO(data);
     908:	f041 0180 	orr.w	r1, r1, #128	; 0x80
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     90c:	f883 10b9 	strb.w	r1, [r3, #185]	; 0xb9
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     910:	f8c3 5088 	str.w	r5, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     914:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
     918:	f8c3 60a8 	str.w	r6, [r3, #168]	; 0xa8
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     91c:	f8c3 5094 	str.w	r5, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     920:	f893 10d4 	ldrb.w	r1, [r3, #212]	; 0xd4
     924:	f001 01fb 	and.w	r1, r1, #251	; 0xfb
     928:	f883 10d4 	strb.w	r1, [r3, #212]	; 0xd4
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     92c:	f893 10d4 	ldrb.w	r1, [r3, #212]	; 0xd4
	tmp &= ~PORT_PINCFG_PMUXEN;
     930:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     934:	f041 0101 	orr.w	r1, r1, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     938:	f883 10d4 	strb.w	r1, [r3, #212]	; 0xd4
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     93c:	f893 10ba 	ldrb.w	r1, [r3, #186]	; 0xba
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     940:	f001 01f0 	and.w	r1, r1, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXE(data);
     944:	f041 0108 	orr.w	r1, r1, #8
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     948:	f883 10ba 	strb.w	r1, [r3, #186]	; 0xba
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     94c:	f8c3 0088 	str.w	r0, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     950:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
     954:	f8c3 40a8 	str.w	r4, [r3, #168]	; 0xa8
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     958:	f8c3 0094 	str.w	r0, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     95c:	f893 20d5 	ldrb.w	r2, [r3, #213]	; 0xd5
     960:	f002 02fb 	and.w	r2, r2, #251	; 0xfb
     964:	f883 20d5 	strb.w	r2, [r3, #213]	; 0xd5
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     968:	f893 20d5 	ldrb.w	r2, [r3, #213]	; 0xd5
	tmp &= ~PORT_PINCFG_PMUXEN;
     96c:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     970:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     974:	f883 20d5 	strb.w	r2, [r3, #213]	; 0xd5
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     978:	f893 20ba 	ldrb.w	r2, [r3, #186]	; 0xba
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     97c:	f002 020f 	and.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
     980:	f042 0280 	orr.w	r2, r2, #128	; 0x80
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     984:	f883 20ba 	strb.w	r2, [r3, #186]	; 0xba
	                      // <GPIO_PIN_FUNCTION_K"> K
	                      // <GPIO_PIN_FUNCTION_L"> L
	                      // <GPIO_PIN_FUNCTION_M"> M
	                      // <GPIO_PIN_FUNCTION_N"> N
	                      PINMUX_PB21I_SDHC1_SDDAT3);
}
     988:	bcf0      	pop	{r4, r5, r6, r7}
     98a:	4770      	bx	lr
     98c:	41008000 	.word	0x41008000
     990:	c0000020 	.word	0xc0000020
     994:	c0000010 	.word	0xc0000010
     998:	c0000004 	.word	0xc0000004

0000099c <IO_BUS_CLOCK_init>:
	((Mclk *)hw)->AHBMASK.reg |= MCLK_AHBMASK_SDHC1;
     99c:	4a05      	ldr	r2, [pc, #20]	; (9b4 <IO_BUS_CLOCK_init+0x18>)
     99e:	6913      	ldr	r3, [r2, #16]
     9a0:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
     9a4:	6113      	str	r3, [r2, #16]
     9a6:	4b04      	ldr	r3, [pc, #16]	; (9b8 <IO_BUS_CLOCK_init+0x1c>)
     9a8:	2240      	movs	r2, #64	; 0x40
     9aa:	f8c3 2138 	str.w	r2, [r3, #312]	; 0x138
     9ae:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
     9b2:	4770      	bx	lr
     9b4:	40000800 	.word	0x40000800
     9b8:	40001c00 	.word	0x40001c00

000009bc <IO_BUS_init>:
	hri_gclk_write_PCHCTRL_reg(GCLK, SDHC1_GCLK_ID, CONF_GCLK_SDHC1_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SDHC1_GCLK_ID_SLOW, CONF_GCLK_SDHC1_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
}

void IO_BUS_init(void)
{
     9bc:	b508      	push	{r3, lr}
	IO_BUS_CLOCK_init();
     9be:	4b05      	ldr	r3, [pc, #20]	; (9d4 <IO_BUS_init+0x18>)
     9c0:	4798      	blx	r3
	mci_sync_init(&IO_BUS, SDHC1);
     9c2:	f04f 418c 	mov.w	r1, #1174405120	; 0x46000000
     9c6:	4804      	ldr	r0, [pc, #16]	; (9d8 <IO_BUS_init+0x1c>)
     9c8:	4b04      	ldr	r3, [pc, #16]	; (9dc <IO_BUS_init+0x20>)
     9ca:	4798      	blx	r3
	IO_BUS_PORT_init();
     9cc:	4b04      	ldr	r3, [pc, #16]	; (9e0 <IO_BUS_init+0x24>)
     9ce:	4798      	blx	r3
     9d0:	bd08      	pop	{r3, pc}
     9d2:	bf00      	nop
     9d4:	0000099d 	.word	0x0000099d
     9d8:	20001628 	.word	0x20001628
     9dc:	000025a1 	.word	0x000025a1
     9e0:	00000811 	.word	0x00000811

000009e4 <PWM_0_PORT_init>:
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     9e4:	4a08      	ldr	r2, [pc, #32]	; (a08 <PWM_0_PORT_init+0x24>)
     9e6:	f892 30c9 	ldrb.w	r3, [r2, #201]	; 0xc9
	tmp &= ~PORT_PINCFG_PMUXEN;
     9ea:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     9ee:	f043 0301 	orr.w	r3, r3, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     9f2:	f882 30c9 	strb.w	r3, [r2, #201]	; 0xc9
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     9f6:	f892 30b4 	ldrb.w	r3, [r2, #180]	; 0xb4
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     9fa:	f003 030f 	and.w	r3, r3, #15
	tmp |= PORT_PMUX_PMUXO(data);
     9fe:	f043 0340 	orr.w	r3, r3, #64	; 0x40
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     a02:	f882 30b4 	strb.w	r3, [r2, #180]	; 0xb4
     a06:	4770      	bx	lr
     a08:	41008000 	.word	0x41008000

00000a0c <PWM_0_CLOCK_init>:
}

static inline void hri_mclk_set_APBCMASK_TC4_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBCMASK.reg |= MCLK_APBCMASK_TC4;
     a0c:	4a04      	ldr	r2, [pc, #16]	; (a20 <PWM_0_CLOCK_init+0x14>)
     a0e:	69d3      	ldr	r3, [r2, #28]
     a10:	f043 0320 	orr.w	r3, r3, #32
     a14:	61d3      	str	r3, [r2, #28]
     a16:	2240      	movs	r2, #64	; 0x40
     a18:	4b02      	ldr	r3, [pc, #8]	; (a24 <PWM_0_CLOCK_init+0x18>)
     a1a:	f8c3 20f8 	str.w	r2, [r3, #248]	; 0xf8
     a1e:	4770      	bx	lr
     a20:	40000800 	.word	0x40000800
     a24:	40001c00 	.word	0x40001c00

00000a28 <PWM_0_init>:
	hri_mclk_set_APBCMASK_TC4_bit(MCLK);
	hri_gclk_write_PCHCTRL_reg(GCLK, TC4_GCLK_ID, CONF_GCLK_TC4_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
}

void PWM_0_init(void)
{
     a28:	b508      	push	{r3, lr}
	PWM_0_CLOCK_init();
     a2a:	4b06      	ldr	r3, [pc, #24]	; (a44 <PWM_0_init+0x1c>)
     a2c:	4798      	blx	r3
	PWM_0_PORT_init();
     a2e:	4b06      	ldr	r3, [pc, #24]	; (a48 <PWM_0_init+0x20>)
     a30:	4798      	blx	r3
	pwm_init(&PWM_0, TC4, _tc_get_pwm());
     a32:	4b06      	ldr	r3, [pc, #24]	; (a4c <PWM_0_init+0x24>)
     a34:	4798      	blx	r3
     a36:	4602      	mov	r2, r0
     a38:	4905      	ldr	r1, [pc, #20]	; (a50 <PWM_0_init+0x28>)
     a3a:	4806      	ldr	r0, [pc, #24]	; (a54 <PWM_0_init+0x2c>)
     a3c:	4b06      	ldr	r3, [pc, #24]	; (a58 <PWM_0_init+0x30>)
     a3e:	4798      	blx	r3
     a40:	bd08      	pop	{r3, pc}
     a42:	bf00      	nop
     a44:	00000a0d 	.word	0x00000a0d
     a48:	000009e5 	.word	0x000009e5
     a4c:	00004793 	.word	0x00004793
     a50:	42001400 	.word	0x42001400
     a54:	200015c0 	.word	0x200015c0
     a58:	0000284d 	.word	0x0000284d

00000a5c <PWM_1_PORT_init>:
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     a5c:	4a08      	ldr	r2, [pc, #32]	; (a80 <PWM_1_PORT_init+0x24>)
     a5e:	f892 30cf 	ldrb.w	r3, [r2, #207]	; 0xcf
	tmp &= ~PORT_PINCFG_PMUXEN;
     a62:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     a66:	f043 0301 	orr.w	r3, r3, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     a6a:	f882 30cf 	strb.w	r3, [r2, #207]	; 0xcf
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     a6e:	f892 30b7 	ldrb.w	r3, [r2, #183]	; 0xb7
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     a72:	f003 030f 	and.w	r3, r3, #15
	tmp |= PORT_PMUX_PMUXO(data);
     a76:	f043 0340 	orr.w	r3, r3, #64	; 0x40
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     a7a:	f882 30b7 	strb.w	r3, [r2, #183]	; 0xb7
     a7e:	4770      	bx	lr
     a80:	41008000 	.word	0x41008000

00000a84 <PWM_1_CLOCK_init>:
}

static inline void hri_mclk_set_APBCMASK_TC5_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBCMASK.reg |= MCLK_APBCMASK_TC5;
     a84:	4a04      	ldr	r2, [pc, #16]	; (a98 <PWM_1_CLOCK_init+0x14>)
     a86:	69d3      	ldr	r3, [r2, #28]
     a88:	f043 0340 	orr.w	r3, r3, #64	; 0x40
     a8c:	61d3      	str	r3, [r2, #28]
     a8e:	2240      	movs	r2, #64	; 0x40
     a90:	4b02      	ldr	r3, [pc, #8]	; (a9c <PWM_1_CLOCK_init+0x18>)
     a92:	f8c3 20f8 	str.w	r2, [r3, #248]	; 0xf8
     a96:	4770      	bx	lr
     a98:	40000800 	.word	0x40000800
     a9c:	40001c00 	.word	0x40001c00

00000aa0 <PWM_1_init>:
	hri_mclk_set_APBCMASK_TC5_bit(MCLK);
	hri_gclk_write_PCHCTRL_reg(GCLK, TC5_GCLK_ID, CONF_GCLK_TC5_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
}

void PWM_1_init(void)
{
     aa0:	b508      	push	{r3, lr}
	PWM_1_CLOCK_init();
     aa2:	4b06      	ldr	r3, [pc, #24]	; (abc <PWM_1_init+0x1c>)
     aa4:	4798      	blx	r3
	PWM_1_PORT_init();
     aa6:	4b06      	ldr	r3, [pc, #24]	; (ac0 <PWM_1_init+0x20>)
     aa8:	4798      	blx	r3
	pwm_init(&PWM_1, TC5, _tc_get_pwm());
     aaa:	4b06      	ldr	r3, [pc, #24]	; (ac4 <PWM_1_init+0x24>)
     aac:	4798      	blx	r3
     aae:	4602      	mov	r2, r0
     ab0:	4905      	ldr	r1, [pc, #20]	; (ac8 <PWM_1_init+0x28>)
     ab2:	4806      	ldr	r0, [pc, #24]	; (acc <PWM_1_init+0x2c>)
     ab4:	4b06      	ldr	r3, [pc, #24]	; (ad0 <PWM_1_init+0x30>)
     ab6:	4798      	blx	r3
     ab8:	bd08      	pop	{r3, pc}
     aba:	bf00      	nop
     abc:	00000a85 	.word	0x00000a85
     ac0:	00000a5d 	.word	0x00000a5d
     ac4:	00004793 	.word	0x00004793
     ac8:	42001800 	.word	0x42001800
     acc:	2000165c 	.word	0x2000165c
     ad0:	0000284d 	.word	0x0000284d

00000ad4 <USB_DEVICE_INSTANCE_PORT_init>:
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     ad4:	4b1e      	ldr	r3, [pc, #120]	; (b50 <USB_DEVICE_INSTANCE_PORT_init+0x7c>)
     ad6:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
     ada:	609a      	str	r2, [r3, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     adc:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
     ae0:	6299      	str	r1, [r3, #40]	; 0x28
     ae2:	481c      	ldr	r0, [pc, #112]	; (b54 <USB_DEVICE_INSTANCE_PORT_init+0x80>)
     ae4:	6298      	str	r0, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     ae6:	615a      	str	r2, [r3, #20]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     ae8:	f893 2058 	ldrb.w	r2, [r3, #88]	; 0x58
     aec:	f002 02fb 	and.w	r2, r2, #251	; 0xfb
     af0:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     af4:	f893 2058 	ldrb.w	r2, [r3, #88]	; 0x58
	tmp &= ~PORT_PINCFG_PMUXEN;
     af8:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     afc:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     b00:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     b04:	f893 203c 	ldrb.w	r2, [r3, #60]	; 0x3c
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     b08:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXE(data);
     b0c:	f042 0207 	orr.w	r2, r2, #7
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     b10:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     b14:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
     b18:	609a      	str	r2, [r3, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     b1a:	6299      	str	r1, [r3, #40]	; 0x28
     b1c:	490e      	ldr	r1, [pc, #56]	; (b58 <USB_DEVICE_INSTANCE_PORT_init+0x84>)
     b1e:	6299      	str	r1, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     b20:	615a      	str	r2, [r3, #20]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     b22:	f893 2059 	ldrb.w	r2, [r3, #89]	; 0x59
     b26:	f002 02fb 	and.w	r2, r2, #251	; 0xfb
     b2a:	f883 2059 	strb.w	r2, [r3, #89]	; 0x59
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     b2e:	f893 2059 	ldrb.w	r2, [r3, #89]	; 0x59
	tmp &= ~PORT_PINCFG_PMUXEN;
     b32:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     b36:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     b3a:	f883 2059 	strb.w	r2, [r3, #89]	; 0x59
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     b3e:	f893 203c 	ldrb.w	r2, [r3, #60]	; 0x3c
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     b42:	f002 020f 	and.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
     b46:	f042 0270 	orr.w	r2, r2, #112	; 0x70
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     b4a:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
     b4e:	4770      	bx	lr
     b50:	41008000 	.word	0x41008000
     b54:	c0000100 	.word	0xc0000100
     b58:	c0000200 	.word	0xc0000200

00000b5c <USB_DEVICE_INSTANCE_CLOCK_init>:
     b5c:	2241      	movs	r2, #65	; 0x41
     b5e:	4b07      	ldr	r3, [pc, #28]	; (b7c <USB_DEVICE_INSTANCE_CLOCK_init+0x20>)
     b60:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	((Mclk *)hw)->AHBMASK.reg |= MCLK_AHBMASK_USB;
     b64:	f5a3 53a0 	sub.w	r3, r3, #5120	; 0x1400
     b68:	691a      	ldr	r2, [r3, #16]
     b6a:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
     b6e:	611a      	str	r2, [r3, #16]
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_USB;
     b70:	699a      	ldr	r2, [r3, #24]
     b72:	f042 0201 	orr.w	r2, r2, #1
     b76:	619a      	str	r2, [r3, #24]
     b78:	4770      	bx	lr
     b7a:	bf00      	nop
     b7c:	40001c00 	.word	0x40001c00

00000b80 <USB_DEVICE_INSTANCE_init>:
	hri_mclk_set_AHBMASK_USB_bit(MCLK);
	hri_mclk_set_APBBMASK_USB_bit(MCLK);
}

void USB_DEVICE_INSTANCE_init(void)
{
     b80:	b508      	push	{r3, lr}
	USB_DEVICE_INSTANCE_CLOCK_init();
     b82:	4b03      	ldr	r3, [pc, #12]	; (b90 <USB_DEVICE_INSTANCE_init+0x10>)
     b84:	4798      	blx	r3
	usb_d_init();
     b86:	4b03      	ldr	r3, [pc, #12]	; (b94 <USB_DEVICE_INSTANCE_init+0x14>)
     b88:	4798      	blx	r3
	USB_DEVICE_INSTANCE_PORT_init();
     b8a:	4b03      	ldr	r3, [pc, #12]	; (b98 <USB_DEVICE_INSTANCE_init+0x18>)
     b8c:	4798      	blx	r3
     b8e:	bd08      	pop	{r3, pc}
     b90:	00000b5d 	.word	0x00000b5d
     b94:	00002eb9 	.word	0x00002eb9
     b98:	00000ad5 	.word	0x00000ad5

00000b9c <system_init>:
}

void system_init(void)
{
     b9c:	b538      	push	{r3, r4, r5, lr}
 * Currently the following initialization functions are supported:
 *  - System clock initialization
 */
static inline void init_mcu(void)
{
	_init_chip();
     b9e:	4b23      	ldr	r3, [pc, #140]	; (c2c <system_init+0x90>)
     ba0:	4798      	blx	r3
	init_mcu();

	USB_DEVICE_INSTANCE_init();
     ba2:	4b23      	ldr	r3, [pc, #140]	; (c30 <system_init+0x94>)
     ba4:	4798      	blx	r3
	EXTERNAL_IRQ_0_init();
     ba6:	4b23      	ldr	r3, [pc, #140]	; (c34 <system_init+0x98>)
     ba8:	4798      	blx	r3

	CALENDER_INTERFACE_init();
     baa:	4b23      	ldr	r3, [pc, #140]	; (c38 <system_init+0x9c>)
     bac:	4798      	blx	r3

	SPI_0_init();
     bae:	4b23      	ldr	r3, [pc, #140]	; (c3c <system_init+0xa0>)
     bb0:	4798      	blx	r3

	IO_BUS_init();
     bb2:	4b23      	ldr	r3, [pc, #140]	; (c40 <system_init+0xa4>)
     bb4:	4798      	blx	r3

	PWM_0_init();
     bb6:	4b23      	ldr	r3, [pc, #140]	; (c44 <system_init+0xa8>)
     bb8:	4798      	blx	r3

	PWM_1_init();
     bba:	4b23      	ldr	r3, [pc, #140]	; (c48 <system_init+0xac>)
     bbc:	4798      	blx	r3
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     bbe:	4b23      	ldr	r3, [pc, #140]	; (c4c <system_init+0xb0>)
     bc0:	f44f 2180 	mov.w	r1, #262144	; 0x40000
     bc4:	f8c3 1108 	str.w	r1, [r3, #264]	; 0x108
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     bc8:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
     bcc:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
     bd0:	4a1f      	ldr	r2, [pc, #124]	; (c50 <system_init+0xb4>)
     bd2:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     bd6:	f893 2152 	ldrb.w	r2, [r3, #338]	; 0x152
	tmp &= ~PORT_PINCFG_PMUXEN;
     bda:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     bde:	f883 2152 	strb.w	r2, [r3, #338]	; 0x152
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     be2:	2410      	movs	r4, #16
     be4:	f8c3 4088 	str.w	r4, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     be8:	4a1a      	ldr	r2, [pc, #104]	; (c54 <system_init+0xb8>)
     bea:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
     bee:	f04f 4540 	mov.w	r5, #3221225472	; 0xc0000000
     bf2:	f8c3 50a8 	str.w	r5, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     bf6:	f893 20c4 	ldrb.w	r2, [r3, #196]	; 0xc4
	tmp &= ~PORT_PINCFG_PMUXEN;
     bfa:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     bfe:	f883 20c4 	strb.w	r2, [r3, #196]	; 0xc4
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     c02:	2020      	movs	r0, #32
     c04:	f8c3 0088 	str.w	r0, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     c08:	4a13      	ldr	r2, [pc, #76]	; (c58 <system_init+0xbc>)
     c0a:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
     c0e:	f8c3 50a8 	str.w	r5, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     c12:	f893 20c5 	ldrb.w	r2, [r3, #197]	; 0xc5
	tmp &= ~PORT_PINCFG_PMUXEN;
     c16:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     c1a:	f883 20c5 	strb.w	r2, [r3, #197]	; 0xc5
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     c1e:	f8c3 4094 	str.w	r4, [r3, #148]	; 0x94
     c22:	f8c3 0094 	str.w	r0, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     c26:	f8c3 1118 	str.w	r1, [r3, #280]	; 0x118
     c2a:	bd38      	pop	{r3, r4, r5, pc}
     c2c:	00003365 	.word	0x00003365
     c30:	00000b81 	.word	0x00000b81
     c34:	0000058d 	.word	0x0000058d
     c38:	000006b1 	.word	0x000006b1
     c3c:	000007e1 	.word	0x000007e1
     c40:	000009bd 	.word	0x000009bd
     c44:	00000a29 	.word	0x00000a29
     c48:	00000aa1 	.word	0x00000aa1
     c4c:	41008000 	.word	0x41008000
     c50:	c0000004 	.word	0xc0000004
     c54:	40000010 	.word	0x40000010
     c58:	40000020 	.word	0x40000020

00000c5c <mem_cpy>:
		d += sizeof(int);
		s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
     c5c:	b13a      	cbz	r2, c6e <mem_cpy+0x12>
     c5e:	3801      	subs	r0, #1
     c60:	188a      	adds	r2, r1, r2
		*d++ = *s++;
     c62:	f811 3b01 	ldrb.w	r3, [r1], #1
     c66:	f800 3f01 	strb.w	r3, [r0, #1]!
	while (cnt--)
     c6a:	4291      	cmp	r1, r2
     c6c:	d1f9      	bne.n	c62 <mem_cpy+0x6>
     c6e:	4770      	bx	lr

00000c70 <mem_set>:
/* Fill memory */
static void mem_set(void *dst, int val, UINT cnt)
{
	BYTE *d = (BYTE *)dst;

	while (cnt--)
     c70:	b122      	cbz	r2, c7c <mem_set+0xc>
     c72:	1882      	adds	r2, r0, r2
		*d++ = (BYTE)val;
     c74:	f800 1b01 	strb.w	r1, [r0], #1
	while (cnt--)
     c78:	4282      	cmp	r2, r0
     c7a:	d1fb      	bne.n	c74 <mem_set+0x4>
     c7c:	4770      	bx	lr

00000c7e <ld_clust>:
                      const BYTE *dir /* Pointer to the SFN entry */
                      )
{
	DWORD cl;

	cl = LD_WORD(dir + DIR_FstClusLO);
     c7e:	7eca      	ldrb	r2, [r1, #27]
     c80:	7e8b      	ldrb	r3, [r1, #26]
     c82:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	if (fs->fs_type == FS_FAT32)
     c86:	7802      	ldrb	r2, [r0, #0]
     c88:	2a03      	cmp	r2, #3
     c8a:	d001      	beq.n	c90 <ld_clust+0x12>
		cl |= (DWORD)LD_WORD(dir + DIR_FstClusHI) << 16;

	return cl;
}
     c8c:	4618      	mov	r0, r3
     c8e:	4770      	bx	lr
		cl |= (DWORD)LD_WORD(dir + DIR_FstClusHI) << 16;
     c90:	7d48      	ldrb	r0, [r1, #21]
     c92:	7d0a      	ldrb	r2, [r1, #20]
     c94:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
     c98:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
	return cl;
     c9c:	e7f6      	b.n	c8c <ld_clust+0xe>
	...

00000ca0 <get_ldnumber>:
/*-----------------------------------------------------------------------*/

static int get_ldnumber(                   /* Returns logical drive number (-1:invalid drive) */
                        const TCHAR **path /* Pointer to pointer to the path name */
                        )
{
     ca0:	b410      	push	{r4}
	const char *             sp;
	char                     c;
	TCHAR                    tc;
#endif

	if (*path) { /* If the pointer is not a null */
     ca2:	6804      	ldr	r4, [r0, #0]
     ca4:	b1f4      	cbz	r4, ce4 <get_ldnumber+0x44>
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++)
     ca6:	7821      	ldrb	r1, [r4, #0]
     ca8:	2920      	cmp	r1, #32
     caa:	d911      	bls.n	cd0 <get_ldnumber+0x30>
     cac:	293a      	cmp	r1, #58	; 0x3a
     cae:	d022      	beq.n	cf6 <get_ldnumber+0x56>
     cb0:	4622      	mov	r2, r4
     cb2:	f812 3f01 	ldrb.w	r3, [r2, #1]!
     cb6:	2b20      	cmp	r3, #32
     cb8:	d90c      	bls.n	cd4 <get_ldnumber+0x34>
     cba:	2b3a      	cmp	r3, #58	; 0x3a
     cbc:	d1f9      	bne.n	cb2 <get_ldnumber+0x12>
			;             /* Find ':' in the path */
		if (*tt == ':') { /* If a ':' is exist in the path name */
			tp = *path;
			i  = *tp++ - '0';
     cbe:	3930      	subs	r1, #48	; 0x30
     cc0:	1c63      	adds	r3, r4, #1
			if (i < 10 && tp == tt) { /* Is there a numeric drive id? */
     cc2:	429a      	cmp	r2, r3
     cc4:	d111      	bne.n	cea <get_ldnumber+0x4a>
				if (i < _VOLUMES) {   /* If a drive id is found, get the value and strip it */
     cc6:	2904      	cmp	r1, #4
     cc8:	d812      	bhi.n	cf0 <get_ldnumber+0x50>
					vol   = (int)i;
					*path = ++tt;
     cca:	3402      	adds	r4, #2
     ccc:	6004      	str	r4, [r0, #0]
     cce:	e005      	b.n	cdc <get_ldnumber+0x3c>
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++)
     cd0:	460b      	mov	r3, r1
     cd2:	4622      	mov	r2, r4
		if (*tt == ':') { /* If a ':' is exist in the path name */
     cd4:	2b3a      	cmp	r3, #58	; 0x3a
     cd6:	d0f2      	beq.n	cbe <get_ldnumber+0x1e>
			}
#endif
			return vol;
		}
#if _FS_RPATH && _VOLUMES >= 2
		vol = CurrVol; /* Current drive */
     cd8:	4b08      	ldr	r3, [pc, #32]	; (cfc <get_ldnumber+0x5c>)
     cda:	7819      	ldrb	r1, [r3, #0]
#else
		vol    = 0; /* Drive 0 */
#endif
	}
	return vol;
}
     cdc:	4608      	mov	r0, r1
     cde:	f85d 4b04 	ldr.w	r4, [sp], #4
     ce2:	4770      	bx	lr
	int          vol = -1;
     ce4:	f04f 31ff 	mov.w	r1, #4294967295
     ce8:	e7f8      	b.n	cdc <get_ldnumber+0x3c>
     cea:	f04f 31ff 	mov.w	r1, #4294967295
     cee:	e7f5      	b.n	cdc <get_ldnumber+0x3c>
     cf0:	f04f 31ff 	mov.w	r1, #4294967295
     cf4:	e7f2      	b.n	cdc <get_ldnumber+0x3c>
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++)
     cf6:	4622      	mov	r2, r4
     cf8:	e7e1      	b.n	cbe <get_ldnumber+0x1e>
     cfa:	bf00      	nop
     cfc:	200000dc 	.word	0x200000dc

00000d00 <sync_window>:
{
     d00:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	if (fs->wflag) {         /* Write back the sector if it is dirty */
     d04:	7903      	ldrb	r3, [r0, #4]
     d06:	b913      	cbnz	r3, d0e <sync_window+0xe>
	FRESULT res = FR_OK;
     d08:	2000      	movs	r0, #0
     d0a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
     d0e:	4604      	mov	r4, r0
		wsect = fs->winsect; /* Current sector number */
     d10:	6b05      	ldr	r5, [r0, #48]	; 0x30
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
     d12:	f100 0734 	add.w	r7, r0, #52	; 0x34
     d16:	2301      	movs	r3, #1
     d18:	462a      	mov	r2, r5
     d1a:	4639      	mov	r1, r7
     d1c:	7840      	ldrb	r0, [r0, #1]
     d1e:	4e13      	ldr	r6, [pc, #76]	; (d6c <sync_window+0x6c>)
     d20:	47b0      	blx	r6
     d22:	b9d0      	cbnz	r0, d5a <sync_window+0x5a>
			fs->wflag = 0;
     d24:	2300      	movs	r3, #0
     d26:	7123      	strb	r3, [r4, #4]
			if (wsect - fs->fatbase < fs->fsize) {     /* Is it in the FAT area? */
     d28:	6a63      	ldr	r3, [r4, #36]	; 0x24
     d2a:	1aeb      	subs	r3, r5, r3
     d2c:	69e2      	ldr	r2, [r4, #28]
     d2e:	4293      	cmp	r3, r2
     d30:	d216      	bcs.n	d60 <sync_window+0x60>
				for (nf = fs->n_fats; nf >= 2; nf--) { /* Reflect the change to all FAT copies */
     d32:	78e6      	ldrb	r6, [r4, #3]
     d34:	2e01      	cmp	r6, #1
     d36:	d916      	bls.n	d66 <sync_window+0x66>
					disk_write(fs->drv, fs->win, wsect, 1);
     d38:	f04f 0901 	mov.w	r9, #1
     d3c:	f8df 802c 	ldr.w	r8, [pc, #44]	; d6c <sync_window+0x6c>
					wsect += fs->fsize;
     d40:	69e3      	ldr	r3, [r4, #28]
     d42:	441d      	add	r5, r3
					disk_write(fs->drv, fs->win, wsect, 1);
     d44:	464b      	mov	r3, r9
     d46:	462a      	mov	r2, r5
     d48:	4639      	mov	r1, r7
     d4a:	7860      	ldrb	r0, [r4, #1]
     d4c:	47c0      	blx	r8
				for (nf = fs->n_fats; nf >= 2; nf--) { /* Reflect the change to all FAT copies */
     d4e:	3e01      	subs	r6, #1
     d50:	2e01      	cmp	r6, #1
     d52:	d1f5      	bne.n	d40 <sync_window+0x40>
	FRESULT res = FR_OK;
     d54:	2000      	movs	r0, #0
     d56:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			res = FR_DISK_ERR;
     d5a:	2001      	movs	r0, #1
     d5c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	FRESULT res = FR_OK;
     d60:	2000      	movs	r0, #0
     d62:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
     d66:	2000      	movs	r0, #0
}
     d68:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
     d6c:	000004bd 	.word	0x000004bd

00000d70 <move_window>:
{
     d70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (sector != fs->winsect) { /* Window offset changed? */
     d72:	6b03      	ldr	r3, [r0, #48]	; 0x30
     d74:	428b      	cmp	r3, r1
     d76:	d015      	beq.n	da4 <move_window+0x34>
     d78:	4604      	mov	r4, r0
     d7a:	460d      	mov	r5, r1
		res = sync_window(fs); /* Write-back changes */
     d7c:	4b0a      	ldr	r3, [pc, #40]	; (da8 <move_window+0x38>)
     d7e:	4798      	blx	r3
		if (res == FR_OK) { /* Fill sector window with new data */
     d80:	4606      	mov	r6, r0
     d82:	b108      	cbz	r0, d88 <move_window+0x18>
}
     d84:	4630      	mov	r0, r6
     d86:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
     d88:	2301      	movs	r3, #1
     d8a:	462a      	mov	r2, r5
     d8c:	f104 0134 	add.w	r1, r4, #52	; 0x34
     d90:	7860      	ldrb	r0, [r4, #1]
     d92:	4f06      	ldr	r7, [pc, #24]	; (dac <move_window+0x3c>)
     d94:	47b8      	blx	r7
     d96:	2800      	cmp	r0, #0
				res    = FR_DISK_ERR;
     d98:	bf1c      	itt	ne
     d9a:	2601      	movne	r6, #1
     d9c:	f04f 35ff 	movne.w	r5, #4294967295
			fs->winsect = sector;
     da0:	6325      	str	r5, [r4, #48]	; 0x30
     da2:	e7ef      	b.n	d84 <move_window+0x14>
	FRESULT res = FR_OK;
     da4:	2600      	movs	r6, #0
     da6:	e7ed      	b.n	d84 <move_window+0x14>
     da8:	00000d01 	.word	0x00000d01
     dac:	0000043d 	.word	0x0000043d

00000db0 <check_fs>:

static BYTE check_fs(            /* 0:Valid FAT-BS, 1:Valid BS but not FAT, 2:Not a BS, 3:Disk error */
                     FATFS *fs,  /* File system object */
                     DWORD  sect /* Sector# (lba) to check if it is an FAT boot record or not */
                     )
{
     db0:	b510      	push	{r4, lr}
     db2:	4604      	mov	r4, r0
	fs->wflag   = 0;
     db4:	2300      	movs	r3, #0
     db6:	7103      	strb	r3, [r0, #4]
	fs->winsect = 0xFFFFFFFF;           /* Invaidate window */
     db8:	f04f 33ff 	mov.w	r3, #4294967295
     dbc:	6303      	str	r3, [r0, #48]	; 0x30
	if (move_window(fs, sect) != FR_OK) /* Load boot record */
     dbe:	4b1d      	ldr	r3, [pc, #116]	; (e34 <check_fs+0x84>)
     dc0:	4798      	blx	r3
     dc2:	b108      	cbz	r0, dc8 <check_fs+0x18>
		return 3;
     dc4:	2003      	movs	r0, #3
     dc6:	bd10      	pop	{r4, pc}

	if (LD_WORD(&fs->win[BS_55AA])
     dc8:	f894 2233 	ldrb.w	r2, [r4, #563]	; 0x233
     dcc:	f894 3232 	ldrb.w	r3, [r4, #562]	; 0x232
     dd0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
     dd4:	b21b      	sxth	r3, r3
     dd6:	4a18      	ldr	r2, [pc, #96]	; (e38 <check_fs+0x88>)
     dd8:	4293      	cmp	r3, r2
     dda:	d001      	beq.n	de0 <check_fs+0x30>
	    != 0xAA55) /* Check boot record signature (always placed at offset 510 even if the sector size is >512) */
		return 2;
     ddc:	2002      	movs	r0, #2
     dde:	bd10      	pop	{r4, pc}

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146) /* Check "FAT" string */
     de0:	f894 206d 	ldrb.w	r2, [r4, #109]	; 0x6d
     de4:	f894 306c 	ldrb.w	r3, [r4, #108]	; 0x6c
     de8:	041b      	lsls	r3, r3, #16
     dea:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
     dee:	f894 206a 	ldrb.w	r2, [r4, #106]	; 0x6a
     df2:	4313      	orrs	r3, r2
     df4:	f894 206b 	ldrb.w	r2, [r4, #107]	; 0x6b
     df8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
     dfc:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
     e00:	4a0e      	ldr	r2, [pc, #56]	; (e3c <check_fs+0x8c>)
     e02:	4293      	cmp	r3, r2
     e04:	d013      	beq.n	e2e <check_fs+0x7e>
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146) /* Check "FAT" string */
     e06:	f894 3089 	ldrb.w	r3, [r4, #137]	; 0x89
     e0a:	f894 0088 	ldrb.w	r0, [r4, #136]	; 0x88
     e0e:	0400      	lsls	r0, r0, #16
     e10:	ea40 6003 	orr.w	r0, r0, r3, lsl #24
     e14:	f894 3086 	ldrb.w	r3, [r4, #134]	; 0x86
     e18:	4318      	orrs	r0, r3
     e1a:	f894 3087 	ldrb.w	r3, [r4, #135]	; 0x87
     e1e:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
     e22:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
		return 3;
     e26:	1a80      	subs	r0, r0, r2
     e28:	bf18      	it	ne
     e2a:	2001      	movne	r0, #1
     e2c:	bd10      	pop	{r4, pc}
		return 0;
     e2e:	2000      	movs	r0, #0
		return 0;

	return 1;
}
     e30:	bd10      	pop	{r4, pc}
     e32:	bf00      	nop
     e34:	00000d71 	.word	0x00000d71
     e38:	ffffaa55 	.word	0xffffaa55
     e3c:	00544146 	.word	0x00544146

00000e40 <validate>:
                        void *obj /* Pointer to the object FIL/DIR to check validity */
                        )
{
	FIL *fil = (FIL *)obj; /* Assuming offset of .fs and .id in the FIL/DIR structure is identical */

	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id || (disk_status(fil->fs->drv) & STA_NOINIT))
     e40:	b1b0      	cbz	r0, e70 <validate+0x30>
{
     e42:	b508      	push	{r3, lr}
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id || (disk_status(fil->fs->drv) & STA_NOINIT))
     e44:	6803      	ldr	r3, [r0, #0]
     e46:	b1ab      	cbz	r3, e74 <validate+0x34>
     e48:	7819      	ldrb	r1, [r3, #0]
     e4a:	b909      	cbnz	r1, e50 <validate+0x10>
		return FR_INVALID_OBJECT;
     e4c:	2009      	movs	r0, #9
     e4e:	bd08      	pop	{r3, pc}
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id || (disk_status(fil->fs->drv) & STA_NOINIT))
     e50:	88d9      	ldrh	r1, [r3, #6]
     e52:	8882      	ldrh	r2, [r0, #4]
     e54:	4291      	cmp	r1, r2
     e56:	d001      	beq.n	e5c <validate+0x1c>
		return FR_INVALID_OBJECT;
     e58:	2009      	movs	r0, #9

	ENTER_FF(fil->fs); /* Lock file system */

	return FR_OK;
}
     e5a:	bd08      	pop	{r3, pc}
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id || (disk_status(fil->fs->drv) & STA_NOINIT))
     e5c:	7858      	ldrb	r0, [r3, #1]
     e5e:	4b06      	ldr	r3, [pc, #24]	; (e78 <validate+0x38>)
     e60:	4798      	blx	r3
     e62:	f000 0001 	and.w	r0, r0, #1
		return FR_INVALID_OBJECT;
     e66:	2800      	cmp	r0, #0
     e68:	bf0c      	ite	eq
     e6a:	2000      	moveq	r0, #0
     e6c:	2009      	movne	r0, #9
     e6e:	bd08      	pop	{r3, pc}
     e70:	2009      	movs	r0, #9
     e72:	4770      	bx	lr
     e74:	2009      	movs	r0, #9
     e76:	bd08      	pop	{r3, pc}
     e78:	00000421 	.word	0x00000421

00000e7c <find_volume>:
{
     e7c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
     e80:	b085      	sub	sp, #20
     e82:	4606      	mov	r6, r0
     e84:	4617      	mov	r7, r2
	*rfs = 0;
     e86:	2300      	movs	r3, #0
     e88:	6003      	str	r3, [r0, #0]
	vol  = get_ldnumber(path);
     e8a:	4608      	mov	r0, r1
     e8c:	4b9c      	ldr	r3, [pc, #624]	; (1100 <find_volume+0x284>)
     e8e:	4798      	blx	r3
	if (vol < 0)
     e90:	1e05      	subs	r5, r0, #0
     e92:	f2c0 81a4 	blt.w	11de <find_volume+0x362>
	fs = FatFs[vol]; /* Get pointer to the file system object */
     e96:	4b9b      	ldr	r3, [pc, #620]	; (1104 <find_volume+0x288>)
     e98:	eb03 0385 	add.w	r3, r3, r5, lsl #2
     e9c:	685c      	ldr	r4, [r3, #4]
	if (!fs)
     e9e:	2c00      	cmp	r4, #0
     ea0:	f000 81a1 	beq.w	11e6 <find_volume+0x36a>
	*rfs = fs;    /* Return pointer to the file system object */
     ea4:	6034      	str	r4, [r6, #0]
	if (fs->fs_type) { /* If the volume has been mounted */
     ea6:	7823      	ldrb	r3, [r4, #0]
     ea8:	b17b      	cbz	r3, eca <find_volume+0x4e>
		stat = disk_status(fs->drv);
     eaa:	7860      	ldrb	r0, [r4, #1]
     eac:	4b96      	ldr	r3, [pc, #600]	; (1108 <find_volume+0x28c>)
     eae:	4798      	blx	r3
		if (!(stat & STA_NOINIT)) {                             /* and the physical drive is kept initialized */
     eb0:	f010 0f01 	tst.w	r0, #1
     eb4:	d109      	bne.n	eca <find_volume+0x4e>
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT)) /* Check write protection if needed */
     eb6:	2f00      	cmp	r7, #0
     eb8:	f000 8197 	beq.w	11ea <find_volume+0x36e>
     ebc:	f000 0004 	and.w	r0, r0, #4
				return FR_WRITE_PROTECTED;
     ec0:	2800      	cmp	r0, #0
     ec2:	bf0c      	ite	eq
     ec4:	2000      	moveq	r0, #0
     ec6:	200a      	movne	r0, #10
     ec8:	e18a      	b.n	11e0 <find_volume+0x364>
	fs->fs_type = 0;                                    /* Clear the file system object */
     eca:	2300      	movs	r3, #0
     ecc:	7023      	strb	r3, [r4, #0]
	fs->drv     = LD2PD(vol);                           /* Bind the logical drive and a physical drive */
     ece:	b2e8      	uxtb	r0, r5
     ed0:	7060      	strb	r0, [r4, #1]
	stat        = disk_initialize(fs->drv);             /* Initialize the physical drive */
     ed2:	4b8e      	ldr	r3, [pc, #568]	; (110c <find_volume+0x290>)
     ed4:	4798      	blx	r3
	if (stat & STA_NOINIT)                              /* Check if the initialization succeeded */
     ed6:	f010 0f01 	tst.w	r0, #1
     eda:	d001      	beq.n	ee0 <find_volume+0x64>
		return FR_NOT_READY;                            /* Failed to initialize due to no medium or hard error */
     edc:	2003      	movs	r0, #3
     ede:	e17f      	b.n	11e0 <find_volume+0x364>
	if (!_FS_READONLY && wmode && (stat & STA_PROTECT)) /* Check disk write protection if needed */
     ee0:	b127      	cbz	r7, eec <find_volume+0x70>
     ee2:	f010 0f04 	tst.w	r0, #4
     ee6:	d001      	beq.n	eec <find_volume+0x70>
		return FR_WRITE_PROTECTED;
     ee8:	200a      	movs	r0, #10
     eea:	e179      	b.n	11e0 <find_volume+0x364>
	fmt   = check_fs(fs, bsect);              /* Load sector 0 and check if it is an FAT boot sector as SFD */
     eec:	2100      	movs	r1, #0
     eee:	4620      	mov	r0, r4
     ef0:	4b87      	ldr	r3, [pc, #540]	; (1110 <find_volume+0x294>)
     ef2:	4798      	blx	r3
     ef4:	4603      	mov	r3, r0
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) { /* Not an FAT boot sector or forced partition number */
     ef6:	2801      	cmp	r0, #1
     ef8:	d006      	beq.n	f08 <find_volume+0x8c>
	bsect = 0;
     efa:	2600      	movs	r6, #0
	if (fmt == 3)
     efc:	2b03      	cmp	r3, #3
     efe:	f000 8176 	beq.w	11ee <find_volume+0x372>
	if (fmt)
     f02:	b3a3      	cbz	r3, f6e <find_volume+0xf2>
		return FR_NO_FILESYSTEM; /* No FAT volume is found */
     f04:	200d      	movs	r0, #13
     f06:	e16b      	b.n	11e0 <find_volume+0x364>
     f08:	4623      	mov	r3, r4
     f0a:	466d      	mov	r5, sp
     f0c:	f104 0040 	add.w	r0, r4, #64	; 0x40
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) { /* Not an FAT boot sector or forced partition number */
     f10:	4669      	mov	r1, sp
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
     f12:	2700      	movs	r7, #0
     f14:	e005      	b.n	f22 <find_volume+0xa6>
     f16:	463a      	mov	r2, r7
     f18:	f841 2b04 	str.w	r2, [r1], #4
     f1c:	3310      	adds	r3, #16
		for (i = 0; i < 4; i++) {             /* Get partition offset */
     f1e:	4283      	cmp	r3, r0
     f20:	d012      	beq.n	f48 <find_volume+0xcc>
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
     f22:	f893 21f6 	ldrb.w	r2, [r3, #502]	; 0x1f6
     f26:	2a00      	cmp	r2, #0
     f28:	d0f5      	beq.n	f16 <find_volume+0x9a>
     f2a:	f893 61fd 	ldrb.w	r6, [r3, #509]	; 0x1fd
     f2e:	f893 21fc 	ldrb.w	r2, [r3, #508]	; 0x1fc
     f32:	0412      	lsls	r2, r2, #16
     f34:	ea42 6206 	orr.w	r2, r2, r6, lsl #24
     f38:	f893 61fa 	ldrb.w	r6, [r3, #506]	; 0x1fa
     f3c:	4332      	orrs	r2, r6
     f3e:	f893 61fb 	ldrb.w	r6, [r3, #507]	; 0x1fb
     f42:	ea42 2206 	orr.w	r2, r2, r6, lsl #8
     f46:	e7e7      	b.n	f18 <find_volume+0x9c>
     f48:	af04      	add	r7, sp, #16
			fmt   = bsect ? check_fs(fs, bsect) : 2; /* Check the partition */
     f4a:	f04f 0802 	mov.w	r8, #2
     f4e:	f8df 91c0 	ldr.w	r9, [pc, #448]	; 1110 <find_volume+0x294>
     f52:	e006      	b.n	f62 <find_volume+0xe6>
     f54:	4631      	mov	r1, r6
     f56:	4620      	mov	r0, r4
     f58:	47c8      	blx	r9
		} while (!LD2PT(vol) && fmt && ++i < 4);
     f5a:	4603      	mov	r3, r0
     f5c:	b138      	cbz	r0, f6e <find_volume+0xf2>
     f5e:	42af      	cmp	r7, r5
     f60:	d0cc      	beq.n	efc <find_volume+0x80>
			bsect = br[i];
     f62:	f855 6b04 	ldr.w	r6, [r5], #4
			fmt   = bsect ? check_fs(fs, bsect) : 2; /* Check the partition */
     f66:	2e00      	cmp	r6, #0
     f68:	d1f4      	bne.n	f54 <find_volume+0xd8>
     f6a:	4643      	mov	r3, r8
     f6c:	e7f7      	b.n	f5e <find_volume+0xe2>
	if (LD_WORD(fs->win + BPB_BytsPerSec) != SS(fs)) /* (BPB_BytsPerSec must be equal to the physical sector size) */
     f6e:	f894 2040 	ldrb.w	r2, [r4, #64]	; 0x40
     f72:	f894 303f 	ldrb.w	r3, [r4, #63]	; 0x3f
     f76:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
     f7a:	b21b      	sxth	r3, r3
     f7c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
     f80:	d001      	beq.n	f86 <find_volume+0x10a>
		return FR_NO_FILESYSTEM;
     f82:	200d      	movs	r0, #13
     f84:	e12c      	b.n	11e0 <find_volume+0x364>
	fasize = LD_WORD(fs->win + BPB_FATSz16); /* Number of sectors per FAT */
     f86:	f894 304b 	ldrb.w	r3, [r4, #75]	; 0x4b
     f8a:	f894 204a 	ldrb.w	r2, [r4, #74]	; 0x4a
	if (!fasize)
     f8e:	ea52 2203 	orrs.w	r2, r2, r3, lsl #8
     f92:	d10d      	bne.n	fb0 <find_volume+0x134>
		fasize = LD_DWORD(fs->win + BPB_FATSz32);
     f94:	f894 305b 	ldrb.w	r3, [r4, #91]	; 0x5b
     f98:	f894 205a 	ldrb.w	r2, [r4, #90]	; 0x5a
     f9c:	0412      	lsls	r2, r2, #16
     f9e:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
     fa2:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
     fa6:	431a      	orrs	r2, r3
     fa8:	f894 3059 	ldrb.w	r3, [r4, #89]	; 0x59
     fac:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
	fs->fsize  = fasize;
     fb0:	61e2      	str	r2, [r4, #28]
	fs->n_fats = fs->win[BPB_NumFATs];      /* Number of FAT copies */
     fb2:	f894 1044 	ldrb.w	r1, [r4, #68]	; 0x44
     fb6:	70e1      	strb	r1, [r4, #3]
	if (fs->n_fats != 1 && fs->n_fats != 2) /* (Must be 1 or 2) */
     fb8:	1e4b      	subs	r3, r1, #1
     fba:	b2db      	uxtb	r3, r3
     fbc:	2b01      	cmp	r3, #1
     fbe:	d901      	bls.n	fc4 <find_volume+0x148>
		return FR_NO_FILESYSTEM;
     fc0:	200d      	movs	r0, #13
     fc2:	e10d      	b.n	11e0 <find_volume+0x364>
	fs->csize = fs->win[BPB_SecPerClus];             /* Number of sectors per cluster */
     fc4:	f894 7041 	ldrb.w	r7, [r4, #65]	; 0x41
     fc8:	70a7      	strb	r7, [r4, #2]
	if (!fs->csize || (fs->csize & (fs->csize - 1))) /* (Must be power of 2) */
     fca:	b90f      	cbnz	r7, fd0 <find_volume+0x154>
		return FR_NO_FILESYSTEM;
     fcc:	200d      	movs	r0, #13
     fce:	e107      	b.n	11e0 <find_volume+0x364>
	if (!fs->csize || (fs->csize & (fs->csize - 1))) /* (Must be power of 2) */
     fd0:	1e7b      	subs	r3, r7, #1
     fd2:	423b      	tst	r3, r7
     fd4:	d001      	beq.n	fda <find_volume+0x15e>
		return FR_NO_FILESYSTEM;
     fd6:	200d      	movs	r0, #13
     fd8:	e102      	b.n	11e0 <find_volume+0x364>
	fs->n_rootdir = LD_WORD(fs->win + BPB_RootEntCnt); /* Number of root directory entries */
     fda:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
     fde:	f894 0045 	ldrb.w	r0, [r4, #69]	; 0x45
     fe2:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
     fe6:	8120      	strh	r0, [r4, #8]
	if (fs->n_rootdir % (SS(fs) / SZ_DIRE))            /* (Must be sector aligned) */
     fe8:	f010 0f0f 	tst.w	r0, #15
     fec:	f040 8101 	bne.w	11f2 <find_volume+0x376>
	tsect = LD_WORD(fs->win + BPB_TotSec16); /* Number of sectors on the volume */
     ff0:	f894 5048 	ldrb.w	r5, [r4, #72]	; 0x48
     ff4:	f894 3047 	ldrb.w	r3, [r4, #71]	; 0x47
	if (!tsect)
     ff8:	ea53 2305 	orrs.w	r3, r3, r5, lsl #8
     ffc:	d10d      	bne.n	101a <find_volume+0x19e>
		tsect = LD_DWORD(fs->win + BPB_TotSec32);
     ffe:	f894 5057 	ldrb.w	r5, [r4, #87]	; 0x57
    1002:	f894 3056 	ldrb.w	r3, [r4, #86]	; 0x56
    1006:	041b      	lsls	r3, r3, #16
    1008:	ea43 6305 	orr.w	r3, r3, r5, lsl #24
    100c:	f894 5054 	ldrb.w	r5, [r4, #84]	; 0x54
    1010:	432b      	orrs	r3, r5
    1012:	f894 5055 	ldrb.w	r5, [r4, #85]	; 0x55
    1016:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
	nrsv = LD_WORD(fs->win + BPB_RsvdSecCnt); /* Number of reserved sectors */
    101a:	f894 e043 	ldrb.w	lr, [r4, #67]	; 0x43
    101e:	f894 5042 	ldrb.w	r5, [r4, #66]	; 0x42
	if (!nrsv)
    1022:	ea55 250e 	orrs.w	r5, r5, lr, lsl #8
    1026:	f000 80e6 	beq.w	11f6 <find_volume+0x37a>
	fasize *= fs->n_fats; /* Number of sectors for FAT area */
    102a:	fb02 fc01 	mul.w	ip, r2, r1
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIRE); /* RSV + FAT + DIR */
    102e:	eb05 1110 	add.w	r1, r5, r0, lsr #4
    1032:	eb01 0e0c 	add.w	lr, r1, ip
	if (tsect < sysect)
    1036:	4573      	cmp	r3, lr
    1038:	f0c0 80df 	bcc.w	11fa <find_volume+0x37e>
	nclst = (tsect - sysect) / fs->csize; /* Number of clusters */
    103c:	eba3 030e 	sub.w	r3, r3, lr
    1040:	fbb3 f3f7 	udiv	r3, r3, r7
	if (!nclst)
    1044:	2b00      	cmp	r3, #0
    1046:	f000 80da 	beq.w	11fe <find_volume+0x382>
		fmt = FS_FAT16;
    104a:	f640 71f5 	movw	r1, #4085	; 0xff5
    104e:	428b      	cmp	r3, r1
    1050:	bf94      	ite	ls
    1052:	2101      	movls	r1, #1
    1054:	2102      	movhi	r1, #2
	if (nclst >= MIN_FAT32)
    1056:	f64f 77f5 	movw	r7, #65525	; 0xfff5
    105a:	42bb      	cmp	r3, r7
    105c:	f200 80d9 	bhi.w	1212 <find_volume+0x396>
	fs->n_fatent = nclst + 2;      /* Number of FAT entries */
    1060:	3302      	adds	r3, #2
    1062:	61a3      	str	r3, [r4, #24]
	fs->volbase  = bsect;          /* Volume start sector */
    1064:	6226      	str	r6, [r4, #32]
	fs->fatbase  = bsect + nrsv;   /* FAT start sector */
    1066:	4435      	add	r5, r6
    1068:	6265      	str	r5, [r4, #36]	; 0x24
	fs->database = bsect + sysect; /* Data start sector */
    106a:	eb0e 0706 	add.w	r7, lr, r6
    106e:	62e7      	str	r7, [r4, #44]	; 0x2c
	if (fmt == FS_FAT32) {
    1070:	2903      	cmp	r1, #3
    1072:	d129      	bne.n	10c8 <find_volume+0x24c>
		if (fs->n_rootdir)
    1074:	2800      	cmp	r0, #0
    1076:	f040 80c4 	bne.w	1202 <find_volume+0x386>
		fs->dirbase = LD_DWORD(fs->win + BPB_RootClus); /* Root directory start cluster */
    107a:	f894 0063 	ldrb.w	r0, [r4, #99]	; 0x63
    107e:	f894 1062 	ldrb.w	r1, [r4, #98]	; 0x62
    1082:	0409      	lsls	r1, r1, #16
    1084:	ea41 6100 	orr.w	r1, r1, r0, lsl #24
    1088:	f894 0060 	ldrb.w	r0, [r4, #96]	; 0x60
    108c:	4301      	orrs	r1, r0
    108e:	f894 0061 	ldrb.w	r0, [r4, #97]	; 0x61
    1092:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
    1096:	62a1      	str	r1, [r4, #40]	; 0x28
		szbfat      = fs->n_fatent * 4;                 /* (Needed FAT size) */
    1098:	009b      	lsls	r3, r3, #2
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) /* (BPB_FATSz must not be less than the size needed) */
    109a:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
    109e:	ebb2 2f53 	cmp.w	r2, r3, lsr #9
    10a2:	f0c0 80b0 	bcc.w	1206 <find_volume+0x38a>
	fs->last_clust = fs->free_clust = 0xFFFFFFFF;
    10a6:	f04f 33ff 	mov.w	r3, #4294967295
    10aa:	6123      	str	r3, [r4, #16]
    10ac:	60e3      	str	r3, [r4, #12]
	fs->fsi_flag = 0x80;
    10ae:	2380      	movs	r3, #128	; 0x80
    10b0:	7163      	strb	r3, [r4, #5]
	    && LD_WORD(fs->win + BPB_FSInfo) == 1
    10b2:	f894 2065 	ldrb.w	r2, [r4, #101]	; 0x65
    10b6:	f894 3064 	ldrb.w	r3, [r4, #100]	; 0x64
    10ba:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    10be:	b21b      	sxth	r3, r3
    10c0:	2b01      	cmp	r3, #1
    10c2:	d027      	beq.n	1114 <find_volume+0x298>
    10c4:	2103      	movs	r1, #3
    10c6:	e078      	b.n	11ba <find_volume+0x33e>
		if (!fs->n_rootdir)
    10c8:	2800      	cmp	r0, #0
    10ca:	f000 809e 	beq.w	120a <find_volume+0x38e>
		fs->dirbase = fs->fatbase + fasize; /* Root directory start sector */
    10ce:	4465      	add	r5, ip
    10d0:	62a5      	str	r5, [r4, #40]	; 0x28
		                           : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
    10d2:	2902      	cmp	r1, #2
    10d4:	bf0f      	iteee	eq
    10d6:	005b      	lsleq	r3, r3, #1
    10d8:	eb03 0043 	addne.w	r0, r3, r3, lsl #1
    10dc:	f003 0301 	andne.w	r3, r3, #1
    10e0:	eb03 0350 	addne.w	r3, r3, r0, lsr #1
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) /* (BPB_FATSz must not be less than the size needed) */
    10e4:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
    10e8:	ebb2 2f53 	cmp.w	r2, r3, lsr #9
    10ec:	f0c0 808f 	bcc.w	120e <find_volume+0x392>
	fs->last_clust = fs->free_clust = 0xFFFFFFFF;
    10f0:	f04f 33ff 	mov.w	r3, #4294967295
    10f4:	6123      	str	r3, [r4, #16]
    10f6:	60e3      	str	r3, [r4, #12]
	fs->fsi_flag = 0x80;
    10f8:	2380      	movs	r3, #128	; 0x80
    10fa:	7163      	strb	r3, [r4, #5]
    10fc:	e05d      	b.n	11ba <find_volume+0x33e>
    10fe:	bf00      	nop
    1100:	00000ca1 	.word	0x00000ca1
    1104:	200000dc 	.word	0x200000dc
    1108:	00000421 	.word	0x00000421
    110c:	000003e9 	.word	0x000003e9
    1110:	00000db1 	.word	0x00000db1
	    && move_window(fs, bsect + 1) == FR_OK) {
    1114:	1c71      	adds	r1, r6, #1
    1116:	4620      	mov	r0, r4
    1118:	4b42      	ldr	r3, [pc, #264]	; (1224 <find_volume+0x3a8>)
    111a:	4798      	blx	r3
    111c:	2800      	cmp	r0, #0
    111e:	d156      	bne.n	11ce <find_volume+0x352>
		fs->fsi_flag = 0;
    1120:	2300      	movs	r3, #0
    1122:	7163      	strb	r3, [r4, #5]
		if (LD_WORD(fs->win + BS_55AA) == 0xAA55 /* Load FSINFO data if available */
    1124:	f894 2233 	ldrb.w	r2, [r4, #563]	; 0x233
    1128:	f894 3232 	ldrb.w	r3, [r4, #562]	; 0x232
    112c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    1130:	b21b      	sxth	r3, r3
    1132:	4a3d      	ldr	r2, [pc, #244]	; (1228 <find_volume+0x3ac>)
    1134:	4293      	cmp	r3, r2
    1136:	d14c      	bne.n	11d2 <find_volume+0x356>
		    && LD_DWORD(fs->win + FSI_LeadSig) == 0x41615252
    1138:	f894 2037 	ldrb.w	r2, [r4, #55]	; 0x37
    113c:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
    1140:	041b      	lsls	r3, r3, #16
    1142:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
    1146:	f894 2034 	ldrb.w	r2, [r4, #52]	; 0x34
    114a:	4313      	orrs	r3, r2
    114c:	f894 2035 	ldrb.w	r2, [r4, #53]	; 0x35
    1150:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    1154:	4a35      	ldr	r2, [pc, #212]	; (122c <find_volume+0x3b0>)
    1156:	4293      	cmp	r3, r2
    1158:	d13d      	bne.n	11d6 <find_volume+0x35a>
		    && LD_DWORD(fs->win + FSI_StrucSig) == 0x61417272) {
    115a:	f894 221b 	ldrb.w	r2, [r4, #539]	; 0x21b
    115e:	f894 321a 	ldrb.w	r3, [r4, #538]	; 0x21a
    1162:	041b      	lsls	r3, r3, #16
    1164:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
    1168:	f894 2218 	ldrb.w	r2, [r4, #536]	; 0x218
    116c:	4313      	orrs	r3, r2
    116e:	f894 2219 	ldrb.w	r2, [r4, #537]	; 0x219
    1172:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    1176:	4a2e      	ldr	r2, [pc, #184]	; (1230 <find_volume+0x3b4>)
    1178:	4293      	cmp	r3, r2
    117a:	d12e      	bne.n	11da <find_volume+0x35e>
			fs->free_clust = LD_DWORD(fs->win + FSI_Free_Count);
    117c:	f894 221f 	ldrb.w	r2, [r4, #543]	; 0x21f
    1180:	f894 321e 	ldrb.w	r3, [r4, #542]	; 0x21e
    1184:	041b      	lsls	r3, r3, #16
    1186:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
    118a:	f894 221c 	ldrb.w	r2, [r4, #540]	; 0x21c
    118e:	4313      	orrs	r3, r2
    1190:	f894 221d 	ldrb.w	r2, [r4, #541]	; 0x21d
    1194:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    1198:	6123      	str	r3, [r4, #16]
			fs->last_clust = LD_DWORD(fs->win + FSI_Nxt_Free);
    119a:	f894 2223 	ldrb.w	r2, [r4, #547]	; 0x223
    119e:	f894 3222 	ldrb.w	r3, [r4, #546]	; 0x222
    11a2:	041b      	lsls	r3, r3, #16
    11a4:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
    11a8:	f894 2220 	ldrb.w	r2, [r4, #544]	; 0x220
    11ac:	4313      	orrs	r3, r2
    11ae:	f894 2221 	ldrb.w	r2, [r4, #545]	; 0x221
    11b2:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    11b6:	60e3      	str	r3, [r4, #12]
    11b8:	2103      	movs	r1, #3
	fs->fs_type = fmt;    /* FAT sub-type */
    11ba:	7021      	strb	r1, [r4, #0]
	fs->id      = ++Fsid; /* File system mount ID */
    11bc:	4a1d      	ldr	r2, [pc, #116]	; (1234 <find_volume+0x3b8>)
    11be:	8b13      	ldrh	r3, [r2, #24]
    11c0:	3301      	adds	r3, #1
    11c2:	b29b      	uxth	r3, r3
    11c4:	8313      	strh	r3, [r2, #24]
    11c6:	80e3      	strh	r3, [r4, #6]
	fs->cdir = 0; /* Set current directory to root */
    11c8:	2000      	movs	r0, #0
    11ca:	6160      	str	r0, [r4, #20]
	return FR_OK;
    11cc:	e008      	b.n	11e0 <find_volume+0x364>
    11ce:	2103      	movs	r1, #3
    11d0:	e7f3      	b.n	11ba <find_volume+0x33e>
    11d2:	2103      	movs	r1, #3
    11d4:	e7f1      	b.n	11ba <find_volume+0x33e>
    11d6:	2103      	movs	r1, #3
    11d8:	e7ef      	b.n	11ba <find_volume+0x33e>
    11da:	2103      	movs	r1, #3
    11dc:	e7ed      	b.n	11ba <find_volume+0x33e>
		return FR_INVALID_DRIVE;
    11de:	200b      	movs	r0, #11
}
    11e0:	b005      	add	sp, #20
    11e2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		return FR_NOT_ENABLED; /* Is the file system object available? */
    11e6:	200c      	movs	r0, #12
    11e8:	e7fa      	b.n	11e0 <find_volume+0x364>
			return FR_OK; /* The file system object is valid */
    11ea:	2000      	movs	r0, #0
    11ec:	e7f8      	b.n	11e0 <find_volume+0x364>
		return FR_DISK_ERR; /* An error occured in the disk I/O layer */
    11ee:	2001      	movs	r0, #1
    11f0:	e7f6      	b.n	11e0 <find_volume+0x364>
		return FR_NO_FILESYSTEM;
    11f2:	200d      	movs	r0, #13
    11f4:	e7f4      	b.n	11e0 <find_volume+0x364>
		return FR_NO_FILESYSTEM; /* (Must not be 0) */
    11f6:	200d      	movs	r0, #13
    11f8:	e7f2      	b.n	11e0 <find_volume+0x364>
		return FR_NO_FILESYSTEM;          /* (Invalid volume size) */
    11fa:	200d      	movs	r0, #13
    11fc:	e7f0      	b.n	11e0 <find_volume+0x364>
		return FR_NO_FILESYSTEM; /* (Invalid volume size) */
    11fe:	200d      	movs	r0, #13
    1200:	e7ee      	b.n	11e0 <find_volume+0x364>
			return FR_NO_FILESYSTEM;                    /* (BPB_RootEntCnt must be 0) */
    1202:	200d      	movs	r0, #13
    1204:	e7ec      	b.n	11e0 <find_volume+0x364>
		return FR_NO_FILESYSTEM;
    1206:	200d      	movs	r0, #13
    1208:	e7ea      	b.n	11e0 <find_volume+0x364>
			return FR_NO_FILESYSTEM;        /* (BPB_RootEntCnt must not be 0) */
    120a:	200d      	movs	r0, #13
    120c:	e7e8      	b.n	11e0 <find_volume+0x364>
		return FR_NO_FILESYSTEM;
    120e:	200d      	movs	r0, #13
    1210:	e7e6      	b.n	11e0 <find_volume+0x364>
	fs->n_fatent = nclst + 2;      /* Number of FAT entries */
    1212:	3302      	adds	r3, #2
    1214:	61a3      	str	r3, [r4, #24]
	fs->volbase  = bsect;          /* Volume start sector */
    1216:	6226      	str	r6, [r4, #32]
	fs->fatbase  = bsect + nrsv;   /* FAT start sector */
    1218:	4435      	add	r5, r6
    121a:	6265      	str	r5, [r4, #36]	; 0x24
	fs->database = bsect + sysect; /* Data start sector */
    121c:	eb0e 0106 	add.w	r1, lr, r6
    1220:	62e1      	str	r1, [r4, #44]	; 0x2c
    1222:	e727      	b.n	1074 <find_volume+0x1f8>
    1224:	00000d71 	.word	0x00000d71
    1228:	ffffaa55 	.word	0xffffaa55
    122c:	41615252 	.word	0x41615252
    1230:	61417272 	.word	0x61417272
    1234:	200000dc 	.word	0x200000dc

00001238 <sync_fs>:
{
    1238:	b538      	push	{r3, r4, r5, lr}
    123a:	4604      	mov	r4, r0
	res = sync_window(fs);
    123c:	4b2d      	ldr	r3, [pc, #180]	; (12f4 <sync_fs+0xbc>)
    123e:	4798      	blx	r3
	if (res == FR_OK) {
    1240:	4603      	mov	r3, r0
    1242:	b950      	cbnz	r0, 125a <sync_fs+0x22>
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
    1244:	7823      	ldrb	r3, [r4, #0]
    1246:	2b03      	cmp	r3, #3
    1248:	d009      	beq.n	125e <sync_fs+0x26>
		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
    124a:	2200      	movs	r2, #0
    124c:	4611      	mov	r1, r2
    124e:	7860      	ldrb	r0, [r4, #1]
    1250:	4b29      	ldr	r3, [pc, #164]	; (12f8 <sync_fs+0xc0>)
    1252:	4798      	blx	r3
	res = sync_window(fs);
    1254:	1c03      	adds	r3, r0, #0
    1256:	bf18      	it	ne
    1258:	2301      	movne	r3, #1
}
    125a:	4618      	mov	r0, r3
    125c:	bd38      	pop	{r3, r4, r5, pc}
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
    125e:	7963      	ldrb	r3, [r4, #5]
    1260:	2b01      	cmp	r3, #1
    1262:	d1f2      	bne.n	124a <sync_fs+0x12>
			mem_set(fs->win, 0, SS(fs));
    1264:	f104 0534 	add.w	r5, r4, #52	; 0x34
    1268:	f44f 7200 	mov.w	r2, #512	; 0x200
    126c:	2100      	movs	r1, #0
    126e:	4628      	mov	r0, r5
    1270:	4b22      	ldr	r3, [pc, #136]	; (12fc <sync_fs+0xc4>)
    1272:	4798      	blx	r3
			ST_WORD(fs->win + BS_55AA, 0xAA55);
    1274:	2355      	movs	r3, #85	; 0x55
    1276:	f884 3232 	strb.w	r3, [r4, #562]	; 0x232
    127a:	23aa      	movs	r3, #170	; 0xaa
    127c:	f884 3233 	strb.w	r3, [r4, #563]	; 0x233
			ST_DWORD(fs->win + FSI_LeadSig, 0x41615252);
    1280:	2352      	movs	r3, #82	; 0x52
    1282:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
    1286:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
    128a:	2361      	movs	r3, #97	; 0x61
    128c:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
    1290:	2241      	movs	r2, #65	; 0x41
    1292:	f884 2037 	strb.w	r2, [r4, #55]	; 0x37
			ST_DWORD(fs->win + FSI_StrucSig, 0x61417272);
    1296:	2172      	movs	r1, #114	; 0x72
    1298:	f884 1218 	strb.w	r1, [r4, #536]	; 0x218
    129c:	f884 1219 	strb.w	r1, [r4, #537]	; 0x219
    12a0:	f884 221a 	strb.w	r2, [r4, #538]	; 0x21a
    12a4:	f884 321b 	strb.w	r3, [r4, #539]	; 0x21b
			ST_DWORD(fs->win + FSI_Free_Count, fs->free_clust);
    12a8:	6923      	ldr	r3, [r4, #16]
    12aa:	f884 321c 	strb.w	r3, [r4, #540]	; 0x21c
    12ae:	f3c3 2207 	ubfx	r2, r3, #8, #8
    12b2:	f884 221d 	strb.w	r2, [r4, #541]	; 0x21d
    12b6:	0c1a      	lsrs	r2, r3, #16
    12b8:	f884 221e 	strb.w	r2, [r4, #542]	; 0x21e
    12bc:	0e1b      	lsrs	r3, r3, #24
    12be:	f884 321f 	strb.w	r3, [r4, #543]	; 0x21f
			ST_DWORD(fs->win + FSI_Nxt_Free, fs->last_clust);
    12c2:	68e3      	ldr	r3, [r4, #12]
    12c4:	f884 3220 	strb.w	r3, [r4, #544]	; 0x220
    12c8:	f3c3 2207 	ubfx	r2, r3, #8, #8
    12cc:	f884 2221 	strb.w	r2, [r4, #545]	; 0x221
    12d0:	0c1a      	lsrs	r2, r3, #16
    12d2:	f884 2222 	strb.w	r2, [r4, #546]	; 0x222
    12d6:	0e1b      	lsrs	r3, r3, #24
    12d8:	f884 3223 	strb.w	r3, [r4, #547]	; 0x223
			fs->winsect = fs->volbase + 1;
    12dc:	6a22      	ldr	r2, [r4, #32]
    12de:	3201      	adds	r2, #1
    12e0:	6322      	str	r2, [r4, #48]	; 0x30
			disk_write(fs->drv, fs->win, fs->winsect, 1);
    12e2:	2301      	movs	r3, #1
    12e4:	4629      	mov	r1, r5
    12e6:	7860      	ldrb	r0, [r4, #1]
    12e8:	4d05      	ldr	r5, [pc, #20]	; (1300 <sync_fs+0xc8>)
    12ea:	47a8      	blx	r5
			fs->fsi_flag = 0;
    12ec:	2300      	movs	r3, #0
    12ee:	7163      	strb	r3, [r4, #5]
    12f0:	e7ab      	b.n	124a <sync_fs+0x12>
    12f2:	bf00      	nop
    12f4:	00000d01 	.word	0x00000d01
    12f8:	0000053d 	.word	0x0000053d
    12fc:	00000c71 	.word	0x00000c71
    1300:	000004bd 	.word	0x000004bd

00001304 <clust2sect>:
	clst -= 2;
    1304:	3902      	subs	r1, #2
	if (clst >= fs->n_fatent - 2)
    1306:	6983      	ldr	r3, [r0, #24]
    1308:	3b02      	subs	r3, #2
    130a:	4299      	cmp	r1, r3
	return clst * fs->csize + fs->database;
    130c:	bf3d      	ittte	cc
    130e:	7883      	ldrbcc	r3, [r0, #2]
    1310:	6ac0      	ldrcc	r0, [r0, #44]	; 0x2c
    1312:	fb01 0003 	mlacc	r0, r1, r3, r0
		return 0; /* Invalid cluster# */
    1316:	2000      	movcs	r0, #0
}
    1318:	4770      	bx	lr
	...

0000131c <get_fat>:
	if (clst < 2 || clst >= fs->n_fatent) { /* Check if in valid range */
    131c:	2901      	cmp	r1, #1
    131e:	d969      	bls.n	13f4 <get_fat+0xd8>
{
    1320:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (clst < 2 || clst >= fs->n_fatent) { /* Check if in valid range */
    1322:	6983      	ldr	r3, [r0, #24]
    1324:	4299      	cmp	r1, r3
    1326:	d267      	bcs.n	13f8 <get_fat+0xdc>
    1328:	460c      	mov	r4, r1
    132a:	4606      	mov	r6, r0
		switch (fs->fs_type) {
    132c:	7803      	ldrb	r3, [r0, #0]
    132e:	2b02      	cmp	r3, #2
    1330:	d02e      	beq.n	1390 <get_fat+0x74>
    1332:	2b03      	cmp	r3, #3
    1334:	d040      	beq.n	13b8 <get_fat+0x9c>
    1336:	2b01      	cmp	r3, #1
    1338:	d001      	beq.n	133e <get_fat+0x22>
			val = 1; /* Internal error */
    133a:	2001      	movs	r0, #1
    133c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			bc += bc / 2;
    133e:	eb01 0551 	add.w	r5, r1, r1, lsr #1
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK)
    1342:	6a41      	ldr	r1, [r0, #36]	; 0x24
    1344:	eb01 2155 	add.w	r1, r1, r5, lsr #9
    1348:	4b2c      	ldr	r3, [pc, #176]	; (13fc <get_fat+0xe0>)
    134a:	4798      	blx	r3
    134c:	b110      	cbz	r0, 1354 <get_fat+0x38>
		val = 0xFFFFFFFF; /* Default value falls on disk error */
    134e:	f04f 30ff 	mov.w	r0, #4294967295
    1352:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			wc = fs->win[bc++ % SS(fs)];
    1354:	1c6f      	adds	r7, r5, #1
    1356:	f3c5 0508 	ubfx	r5, r5, #0, #9
    135a:	4435      	add	r5, r6
    135c:	f895 5034 	ldrb.w	r5, [r5, #52]	; 0x34
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK)
    1360:	6a71      	ldr	r1, [r6, #36]	; 0x24
    1362:	eb01 2157 	add.w	r1, r1, r7, lsr #9
    1366:	4630      	mov	r0, r6
    1368:	4b24      	ldr	r3, [pc, #144]	; (13fc <get_fat+0xe0>)
    136a:	4798      	blx	r3
    136c:	b110      	cbz	r0, 1374 <get_fat+0x58>
		val = 0xFFFFFFFF; /* Default value falls on disk error */
    136e:	f04f 30ff 	mov.w	r0, #4294967295
    1372:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			wc |= fs->win[bc % SS(fs)] << 8;
    1374:	f3c7 0008 	ubfx	r0, r7, #0, #9
    1378:	4430      	add	r0, r6
    137a:	f890 0034 	ldrb.w	r0, [r0, #52]	; 0x34
    137e:	ea45 2000 	orr.w	r0, r5, r0, lsl #8
			val = clst & 1 ? wc >> 4 : (wc & 0xFFF);
    1382:	f014 0f01 	tst.w	r4, #1
    1386:	bf14      	ite	ne
    1388:	0900      	lsrne	r0, r0, #4
    138a:	f3c0 000b 	ubfxeq	r0, r0, #0, #12
    138e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK)
    1390:	6a41      	ldr	r1, [r0, #36]	; 0x24
    1392:	eb01 2114 	add.w	r1, r1, r4, lsr #8
    1396:	4b19      	ldr	r3, [pc, #100]	; (13fc <get_fat+0xe0>)
    1398:	4798      	blx	r3
    139a:	b110      	cbz	r0, 13a2 <get_fat+0x86>
		val = 0xFFFFFFFF; /* Default value falls on disk error */
    139c:	f04f 30ff 	mov.w	r0, #4294967295
    13a0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			p   = &fs->win[clst * 2 % SS(fs)];
    13a2:	0060      	lsls	r0, r4, #1
    13a4:	f400 70ff 	and.w	r0, r0, #510	; 0x1fe
			val = LD_WORD(p);
    13a8:	4430      	add	r0, r6
    13aa:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
    13ae:	f890 0034 	ldrb.w	r0, [r0, #52]	; 0x34
    13b2:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
			break;
    13b6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK)
    13b8:	6a41      	ldr	r1, [r0, #36]	; 0x24
    13ba:	eb01 11d4 	add.w	r1, r1, r4, lsr #7
    13be:	4b0f      	ldr	r3, [pc, #60]	; (13fc <get_fat+0xe0>)
    13c0:	4798      	blx	r3
    13c2:	b110      	cbz	r0, 13ca <get_fat+0xae>
		val = 0xFFFFFFFF; /* Default value falls on disk error */
    13c4:	f04f 30ff 	mov.w	r0, #4294967295
}
    13c8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			p   = &fs->win[clst * 4 % SS(fs)];
    13ca:	00a0      	lsls	r0, r4, #2
    13cc:	f400 70fe 	and.w	r0, r0, #508	; 0x1fc
    13d0:	f100 0234 	add.w	r2, r0, #52	; 0x34
    13d4:	4432      	add	r2, r6
			val = LD_DWORD(p) & 0x0FFFFFFF;
    13d6:	78d1      	ldrb	r1, [r2, #3]
    13d8:	7893      	ldrb	r3, [r2, #2]
    13da:	041b      	lsls	r3, r3, #16
    13dc:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
    13e0:	4430      	add	r0, r6
    13e2:	f890 0034 	ldrb.w	r0, [r0, #52]	; 0x34
    13e6:	4318      	orrs	r0, r3
    13e8:	7853      	ldrb	r3, [r2, #1]
    13ea:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
    13ee:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000
			break;
    13f2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		val = 1;                            /* Internal error */
    13f4:	2001      	movs	r0, #1
    13f6:	4770      	bx	lr
    13f8:	2001      	movs	r0, #1
    13fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    13fc:	00000d71 	.word	0x00000d71

00001400 <dir_sdi>:
{
    1400:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    1404:	4605      	mov	r5, r0
	dp->index = (WORD)idx;                     /* Current index */
    1406:	80c1      	strh	r1, [r0, #6]
	clst      = dp->sclust;                    /* Table start cluster (0:root) */
    1408:	6884      	ldr	r4, [r0, #8]
	if (clst == 1 || clst >= dp->fs->n_fatent) /* Check start cluster range */
    140a:	2c01      	cmp	r4, #1
    140c:	d046      	beq.n	149c <dir_sdi+0x9c>
    140e:	460e      	mov	r6, r1
    1410:	6803      	ldr	r3, [r0, #0]
    1412:	699a      	ldr	r2, [r3, #24]
    1414:	4294      	cmp	r4, r2
    1416:	d302      	bcc.n	141e <dir_sdi+0x1e>
		return FR_INT_ERR;
    1418:	2002      	movs	r0, #2
    141a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (!clst && dp->fs->fs_type == FS_FAT32) /* Replace cluster# 0 with root cluster# if in FAT32 */
    141e:	b964      	cbnz	r4, 143a <dir_sdi+0x3a>
    1420:	781a      	ldrb	r2, [r3, #0]
    1422:	2a03      	cmp	r2, #3
    1424:	d005      	beq.n	1432 <dir_sdi+0x32>
		if (idx >= dp->fs->n_rootdir) /* Is index out of range? */
    1426:	891a      	ldrh	r2, [r3, #8]
    1428:	4296      	cmp	r6, r2
    142a:	d30e      	bcc.n	144a <dir_sdi+0x4a>
			return FR_INT_ERR;
    142c:	2002      	movs	r0, #2
    142e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		clst = dp->fs->dirbase;
    1432:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if (clst == 0) {                  /* Static table (root-directory in FAT12/16) */
    1434:	2a00      	cmp	r2, #0
    1436:	d0f6      	beq.n	1426 <dir_sdi+0x26>
		clst = dp->fs->dirbase;
    1438:	4614      	mov	r4, r2
		ic = SS(dp->fs) / SZ_DIRE * dp->fs->csize; /* Entries per cluster */
    143a:	789f      	ldrb	r7, [r3, #2]
    143c:	013f      	lsls	r7, r7, #4
		while (idx >= ic) {                        /* Follow cluster chain */
    143e:	42be      	cmp	r6, r7
    1440:	d31a      	bcc.n	1478 <dir_sdi+0x78>
    1442:	1bf6      	subs	r6, r6, r7
			clst = get_fat(dp->fs, clst);          /* Get next cluster */
    1444:	f8df 8070 	ldr.w	r8, [pc, #112]	; 14b8 <dir_sdi+0xb8>
    1448:	e006      	b.n	1458 <dir_sdi+0x58>
		sect = dp->fs->dirbase;
    144a:	6a98      	ldr	r0, [r3, #40]	; 0x28
	dp->clust = clst; /* Current cluster# */
    144c:	60ec      	str	r4, [r5, #12]
	if (!sect)
    144e:	b9c0      	cbnz	r0, 1482 <dir_sdi+0x82>
		return FR_INT_ERR;
    1450:	2002      	movs	r0, #2
}
    1452:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    1456:	461e      	mov	r6, r3
			clst = get_fat(dp->fs, clst);          /* Get next cluster */
    1458:	4621      	mov	r1, r4
    145a:	6828      	ldr	r0, [r5, #0]
    145c:	47c0      	blx	r8
    145e:	4604      	mov	r4, r0
			if (clst == 0xFFFFFFFF)
    1460:	f1b0 3fff 	cmp.w	r0, #4294967295
    1464:	d01d      	beq.n	14a2 <dir_sdi+0xa2>
			if (clst < 2 || clst >= dp->fs->n_fatent) /* Reached to end of table or internal error */
    1466:	2801      	cmp	r0, #1
    1468:	d91e      	bls.n	14a8 <dir_sdi+0xa8>
    146a:	682b      	ldr	r3, [r5, #0]
    146c:	699b      	ldr	r3, [r3, #24]
    146e:	4298      	cmp	r0, r3
    1470:	d21d      	bcs.n	14ae <dir_sdi+0xae>
    1472:	1bf3      	subs	r3, r6, r7
		while (idx >= ic) {                        /* Follow cluster chain */
    1474:	42be      	cmp	r6, r7
    1476:	d2ee      	bcs.n	1456 <dir_sdi+0x56>
		sect = clust2sect(dp->fs, clst);
    1478:	4621      	mov	r1, r4
    147a:	6828      	ldr	r0, [r5, #0]
    147c:	4b0d      	ldr	r3, [pc, #52]	; (14b4 <dir_sdi+0xb4>)
    147e:	4798      	blx	r3
    1480:	e7e4      	b.n	144c <dir_sdi+0x4c>
	dp->sect = sect + idx / (SS(dp->fs) / SZ_DIRE);                    /* Sector# of the directory entry */
    1482:	eb00 1016 	add.w	r0, r0, r6, lsr #4
    1486:	6128      	str	r0, [r5, #16]
	dp->dir  = dp->fs->win + (idx % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE; /* Ptr to the entry in the sector */
    1488:	682b      	ldr	r3, [r5, #0]
    148a:	3334      	adds	r3, #52	; 0x34
    148c:	f006 060f 	and.w	r6, r6, #15
    1490:	eb03 1646 	add.w	r6, r3, r6, lsl #5
    1494:	616e      	str	r6, [r5, #20]
	return FR_OK;
    1496:	2000      	movs	r0, #0
    1498:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return FR_INT_ERR;
    149c:	2002      	movs	r0, #2
    149e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				return FR_DISK_ERR;                   /* Disk error */
    14a2:	2001      	movs	r0, #1
    14a4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				return FR_INT_ERR;
    14a8:	2002      	movs	r0, #2
    14aa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    14ae:	2002      	movs	r0, #2
    14b0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    14b4:	00001305 	.word	0x00001305
    14b8:	0000131d 	.word	0x0000131d

000014bc <put_fat>:
{
    14bc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	if (clst < 2 || clst >= fs->n_fatent) { /* Check if in valid range */
    14c0:	2901      	cmp	r1, #1
    14c2:	f240 808b 	bls.w	15dc <put_fat+0x120>
    14c6:	6983      	ldr	r3, [r0, #24]
    14c8:	4299      	cmp	r1, r3
    14ca:	d301      	bcc.n	14d0 <put_fat+0x14>
		res = FR_INT_ERR;
    14cc:	2702      	movs	r7, #2
    14ce:	e086      	b.n	15de <put_fat+0x122>
    14d0:	4616      	mov	r6, r2
    14d2:	460c      	mov	r4, r1
    14d4:	4605      	mov	r5, r0
		switch (fs->fs_type) {
    14d6:	7803      	ldrb	r3, [r0, #0]
    14d8:	2b02      	cmp	r3, #2
    14da:	d04c      	beq.n	1576 <put_fat+0xba>
    14dc:	2b03      	cmp	r3, #3
    14de:	d05e      	beq.n	159e <put_fat+0xe2>
    14e0:	2b01      	cmp	r3, #1
    14e2:	d001      	beq.n	14e8 <put_fat+0x2c>
			res = FR_INT_ERR;
    14e4:	2702      	movs	r7, #2
    14e6:	e07a      	b.n	15de <put_fat+0x122>
			bc += bc / 2;
    14e8:	eb01 0851 	add.w	r8, r1, r1, lsr #1
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
    14ec:	6a41      	ldr	r1, [r0, #36]	; 0x24
    14ee:	eb01 2158 	add.w	r1, r1, r8, lsr #9
    14f2:	4b3e      	ldr	r3, [pc, #248]	; (15ec <put_fat+0x130>)
    14f4:	4798      	blx	r3
			if (res != FR_OK)
    14f6:	4607      	mov	r7, r0
    14f8:	2800      	cmp	r0, #0
    14fa:	d170      	bne.n	15de <put_fat+0x122>
			p         = &fs->win[bc++ % SS(fs)];
    14fc:	f108 0901 	add.w	r9, r8, #1
    1500:	f3c8 0808 	ubfx	r8, r8, #0, #9
			*p        = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
    1504:	f014 0f01 	tst.w	r4, #1
    1508:	d01c      	beq.n	1544 <put_fat+0x88>
    150a:	44a8      	add	r8, r5
    150c:	f898 3034 	ldrb.w	r3, [r8, #52]	; 0x34
    1510:	f003 030f 	and.w	r3, r3, #15
    1514:	ea43 1306 	orr.w	r3, r3, r6, lsl #4
    1518:	f888 3034 	strb.w	r3, [r8, #52]	; 0x34
			fs->wflag = 1;
    151c:	2301      	movs	r3, #1
    151e:	712b      	strb	r3, [r5, #4]
			res       = move_window(fs, fs->fatbase + (bc / SS(fs)));
    1520:	6a69      	ldr	r1, [r5, #36]	; 0x24
    1522:	eb01 2159 	add.w	r1, r1, r9, lsr #9
    1526:	4628      	mov	r0, r5
    1528:	4b30      	ldr	r3, [pc, #192]	; (15ec <put_fat+0x130>)
    152a:	4798      	blx	r3
			if (res != FR_OK)
    152c:	2800      	cmp	r0, #0
    152e:	d159      	bne.n	15e4 <put_fat+0x128>
			p         = &fs->win[bc % SS(fs)];
    1530:	f3c9 0908 	ubfx	r9, r9, #0, #9
			*p        = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
    1534:	f3c6 1207 	ubfx	r2, r6, #4, #8
    1538:	44a9      	add	r9, r5
    153a:	f889 2034 	strb.w	r2, [r9, #52]	; 0x34
			fs->wflag = 1;
    153e:	2301      	movs	r3, #1
    1540:	712b      	strb	r3, [r5, #4]
			break;
    1542:	e04c      	b.n	15de <put_fat+0x122>
			*p        = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
    1544:	44a8      	add	r8, r5
    1546:	f888 6034 	strb.w	r6, [r8, #52]	; 0x34
			fs->wflag = 1;
    154a:	2301      	movs	r3, #1
    154c:	712b      	strb	r3, [r5, #4]
			res       = move_window(fs, fs->fatbase + (bc / SS(fs)));
    154e:	6a69      	ldr	r1, [r5, #36]	; 0x24
    1550:	eb01 2159 	add.w	r1, r1, r9, lsr #9
    1554:	4628      	mov	r0, r5
    1556:	4b25      	ldr	r3, [pc, #148]	; (15ec <put_fat+0x130>)
    1558:	4798      	blx	r3
			if (res != FR_OK)
    155a:	2800      	cmp	r0, #0
    155c:	d144      	bne.n	15e8 <put_fat+0x12c>
			p         = &fs->win[bc % SS(fs)];
    155e:	f3c9 0908 	ubfx	r9, r9, #0, #9
			*p        = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
    1562:	eb05 0309 	add.w	r3, r5, r9
    1566:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
    156a:	f023 030f 	bic.w	r3, r3, #15
    156e:	f3c6 2203 	ubfx	r2, r6, #8, #4
    1572:	431a      	orrs	r2, r3
    1574:	e7e0      	b.n	1538 <put_fat+0x7c>
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
    1576:	6a41      	ldr	r1, [r0, #36]	; 0x24
    1578:	eb01 2114 	add.w	r1, r1, r4, lsr #8
    157c:	4b1b      	ldr	r3, [pc, #108]	; (15ec <put_fat+0x130>)
    157e:	4798      	blx	r3
			if (res != FR_OK)
    1580:	4607      	mov	r7, r0
    1582:	bb60      	cbnz	r0, 15de <put_fat+0x122>
			p = &fs->win[clst * 2 % SS(fs)];
    1584:	0063      	lsls	r3, r4, #1
    1586:	f403 73ff 	and.w	r3, r3, #510	; 0x1fe
			ST_WORD(p, (WORD)val);
    158a:	442b      	add	r3, r5
    158c:	f883 6034 	strb.w	r6, [r3, #52]	; 0x34
    1590:	f3c6 2207 	ubfx	r2, r6, #8, #8
    1594:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
			fs->wflag = 1;
    1598:	2301      	movs	r3, #1
    159a:	712b      	strb	r3, [r5, #4]
			break;
    159c:	e01f      	b.n	15de <put_fat+0x122>
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
    159e:	6a41      	ldr	r1, [r0, #36]	; 0x24
    15a0:	eb01 11d4 	add.w	r1, r1, r4, lsr #7
    15a4:	4b11      	ldr	r3, [pc, #68]	; (15ec <put_fat+0x130>)
    15a6:	4798      	blx	r3
			if (res != FR_OK)
    15a8:	4607      	mov	r7, r0
    15aa:	b9c0      	cbnz	r0, 15de <put_fat+0x122>
			p = &fs->win[clst * 4 % SS(fs)];
    15ac:	00a1      	lsls	r1, r4, #2
    15ae:	f401 71fe 	and.w	r1, r1, #508	; 0x1fc
    15b2:	f101 0334 	add.w	r3, r1, #52	; 0x34
    15b6:	442b      	add	r3, r5
			val |= LD_DWORD(p) & 0xF0000000;
    15b8:	78da      	ldrb	r2, [r3, #3]
    15ba:	0612      	lsls	r2, r2, #24
    15bc:	4429      	add	r1, r5
    15be:	f002 4270 	and.w	r2, r2, #4026531840	; 0xf0000000
    15c2:	4332      	orrs	r2, r6
			ST_DWORD(p, val);
    15c4:	f881 2034 	strb.w	r2, [r1, #52]	; 0x34
    15c8:	f3c2 2107 	ubfx	r1, r2, #8, #8
    15cc:	7059      	strb	r1, [r3, #1]
    15ce:	0c11      	lsrs	r1, r2, #16
    15d0:	7099      	strb	r1, [r3, #2]
    15d2:	0e12      	lsrs	r2, r2, #24
    15d4:	70da      	strb	r2, [r3, #3]
			fs->wflag = 1;
    15d6:	2301      	movs	r3, #1
    15d8:	712b      	strb	r3, [r5, #4]
			break;
    15da:	e000      	b.n	15de <put_fat+0x122>
		res = FR_INT_ERR;
    15dc:	2702      	movs	r7, #2
}
    15de:	4638      	mov	r0, r7
    15e0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			res       = move_window(fs, fs->fatbase + (bc / SS(fs)));
    15e4:	4607      	mov	r7, r0
    15e6:	e7fa      	b.n	15de <put_fat+0x122>
    15e8:	4607      	mov	r7, r0
	return res;
    15ea:	e7f8      	b.n	15de <put_fat+0x122>
    15ec:	00000d71 	.word	0x00000d71

000015f0 <create_chain>:
{
    15f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    15f4:	4605      	mov	r5, r0
	if (clst == 0) {          /* Create a new chain */
    15f6:	4688      	mov	r8, r1
    15f8:	b941      	cbnz	r1, 160c <create_chain+0x1c>
		scl = fs->last_clust; /* Get suggested start point */
    15fa:	68c6      	ldr	r6, [r0, #12]
		if (!scl || scl >= fs->n_fatent)
    15fc:	b19e      	cbz	r6, 1626 <create_chain+0x36>
    15fe:	6983      	ldr	r3, [r0, #24]
			scl = 1;
    1600:	429e      	cmp	r6, r3
    1602:	bf28      	it	cs
    1604:	2601      	movcs	r6, #1
	ncl = scl; /* Start cluster */
    1606:	4634      	mov	r4, r6
		cs = get_fat(fs, ncl); /* Get the cluster status */
    1608:	4f2a      	ldr	r7, [pc, #168]	; (16b4 <create_chain+0xc4>)
    160a:	e01a      	b.n	1642 <create_chain+0x52>
		cs = get_fat(fs, clst); /* Check the cluster status */
    160c:	4b29      	ldr	r3, [pc, #164]	; (16b4 <create_chain+0xc4>)
    160e:	4798      	blx	r3
    1610:	4603      	mov	r3, r0
		if (cs < 2)
    1612:	2801      	cmp	r0, #1
    1614:	d943      	bls.n	169e <create_chain+0xae>
		if (cs == 0xFFFFFFFF)
    1616:	f1b0 3fff 	cmp.w	r0, #4294967295
    161a:	d045      	beq.n	16a8 <create_chain+0xb8>
		if (cs < fs->n_fatent)
    161c:	69aa      	ldr	r2, [r5, #24]
    161e:	4290      	cmp	r0, r2
    1620:	d342      	bcc.n	16a8 <create_chain+0xb8>
		scl = clst;
    1622:	4646      	mov	r6, r8
    1624:	e7ef      	b.n	1606 <create_chain+0x16>
			scl = 1;
    1626:	2601      	movs	r6, #1
    1628:	e7ed      	b.n	1606 <create_chain+0x16>
		cs = get_fat(fs, ncl); /* Get the cluster status */
    162a:	4621      	mov	r1, r4
    162c:	4628      	mov	r0, r5
    162e:	47b8      	blx	r7
		if (cs == 0)
    1630:	4603      	mov	r3, r0
    1632:	b170      	cbz	r0, 1652 <create_chain+0x62>
		if (cs == 0xFFFFFFFF || cs == 1) /* An error occurred */
    1634:	f1b0 3fff 	cmp.w	r0, #4294967295
    1638:	d036      	beq.n	16a8 <create_chain+0xb8>
    163a:	2801      	cmp	r0, #1
    163c:	d034      	beq.n	16a8 <create_chain+0xb8>
		if (ncl == scl)
    163e:	42b4      	cmp	r4, r6
    1640:	d031      	beq.n	16a6 <create_chain+0xb6>
		ncl++;                     /* Next cluster */
    1642:	3401      	adds	r4, #1
		if (ncl >= fs->n_fatent) { /* Check wrap around */
    1644:	69ab      	ldr	r3, [r5, #24]
    1646:	429c      	cmp	r4, r3
    1648:	d3ef      	bcc.n	162a <create_chain+0x3a>
			if (ncl > scl)
    164a:	2e01      	cmp	r6, #1
    164c:	d929      	bls.n	16a2 <create_chain+0xb2>
			ncl = 2;
    164e:	2402      	movs	r4, #2
    1650:	e7eb      	b.n	162a <create_chain+0x3a>
	res = put_fat(fs, ncl, 0x0FFFFFFF); /* Mark the new cluster "last link" */
    1652:	f06f 4270 	mvn.w	r2, #4026531840	; 0xf0000000
    1656:	4621      	mov	r1, r4
    1658:	4628      	mov	r0, r5
    165a:	4b17      	ldr	r3, [pc, #92]	; (16b8 <create_chain+0xc8>)
    165c:	4798      	blx	r3
	if (res == FR_OK && clst != 0) {
    165e:	4603      	mov	r3, r0
    1660:	b9b8      	cbnz	r0, 1692 <create_chain+0xa2>
    1662:	f1b8 0f00 	cmp.w	r8, #0
    1666:	d10c      	bne.n	1682 <create_chain+0x92>
		fs->last_clust = ncl; /* Update FSINFO */
    1668:	60ec      	str	r4, [r5, #12]
		if (fs->free_clust != 0xFFFFFFFF) {
    166a:	692b      	ldr	r3, [r5, #16]
    166c:	f1b3 3fff 	cmp.w	r3, #4294967295
    1670:	d01d      	beq.n	16ae <create_chain+0xbe>
			fs->free_clust--;
    1672:	3b01      	subs	r3, #1
    1674:	612b      	str	r3, [r5, #16]
			fs->fsi_flag |= 1;
    1676:	796b      	ldrb	r3, [r5, #5]
    1678:	f043 0301 	orr.w	r3, r3, #1
    167c:	716b      	strb	r3, [r5, #5]
    167e:	4623      	mov	r3, r4
    1680:	e012      	b.n	16a8 <create_chain+0xb8>
		res = put_fat(fs, clst, ncl); /* Link it to the previous one if needed */
    1682:	4622      	mov	r2, r4
    1684:	4641      	mov	r1, r8
    1686:	4628      	mov	r0, r5
    1688:	4b0b      	ldr	r3, [pc, #44]	; (16b8 <create_chain+0xc8>)
    168a:	4798      	blx	r3
	if (res == FR_OK) {
    168c:	4603      	mov	r3, r0
    168e:	2800      	cmp	r0, #0
    1690:	d0ea      	beq.n	1668 <create_chain+0x78>
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
    1692:	2b01      	cmp	r3, #1
    1694:	bf0c      	ite	eq
    1696:	f04f 33ff 	moveq.w	r3, #4294967295
    169a:	2301      	movne	r3, #1
    169c:	e004      	b.n	16a8 <create_chain+0xb8>
			return 1; /* Invalid value */
    169e:	2301      	movs	r3, #1
    16a0:	e002      	b.n	16a8 <create_chain+0xb8>
				return 0; /* No free cluster */
    16a2:	2300      	movs	r3, #0
    16a4:	e000      	b.n	16a8 <create_chain+0xb8>
			return 0; /* No free cluster */
    16a6:	2300      	movs	r3, #0
}
    16a8:	4618      	mov	r0, r3
    16aa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    16ae:	4623      	mov	r3, r4
    16b0:	e7fa      	b.n	16a8 <create_chain+0xb8>
    16b2:	bf00      	nop
    16b4:	0000131d 	.word	0x0000131d
    16b8:	000014bd 	.word	0x000014bd

000016bc <dir_next>:
{
    16bc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	i = dp->index + 1;
    16c0:	88c4      	ldrh	r4, [r0, #6]
    16c2:	3401      	adds	r4, #1
	if (!(i & 0xFFFF) || !dp->sect) /* Report EOT when index has reached 65535 */
    16c4:	b2a3      	uxth	r3, r4
    16c6:	b913      	cbnz	r3, 16ce <dir_next+0x12>
		return FR_NO_FILE;
    16c8:	2004      	movs	r0, #4
    16ca:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (!(i & 0xFFFF) || !dp->sect) /* Report EOT when index has reached 65535 */
    16ce:	6903      	ldr	r3, [r0, #16]
    16d0:	b913      	cbnz	r3, 16d8 <dir_next+0x1c>
		return FR_NO_FILE;
    16d2:	2004      	movs	r0, #4
    16d4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    16d8:	460e      	mov	r6, r1
    16da:	4605      	mov	r5, r0
	if (!(i % (SS(dp->fs) / SZ_DIRE))) { /* Sector changed? */
    16dc:	f014 070f 	ands.w	r7, r4, #15
    16e0:	d110      	bne.n	1704 <dir_next+0x48>
		dp->sect++;                      /* Next sector */
    16e2:	3301      	adds	r3, #1
    16e4:	6103      	str	r3, [r0, #16]
		if (!dp->clust) {               /* Static table */
    16e6:	68c1      	ldr	r1, [r0, #12]
    16e8:	b931      	cbnz	r1, 16f8 <dir_next+0x3c>
			if (i >= dp->fs->n_rootdir) /* Report EOT if it reached end of static table */
    16ea:	6803      	ldr	r3, [r0, #0]
    16ec:	891b      	ldrh	r3, [r3, #8]
    16ee:	429c      	cmp	r4, r3
    16f0:	d308      	bcc.n	1704 <dir_next+0x48>
				return FR_NO_FILE;
    16f2:	2004      	movs	r0, #4
    16f4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			if (((i / (SS(dp->fs) / SZ_DIRE)) & (dp->fs->csize - 1)) == 0) { /* Cluster changed? */
    16f8:	6800      	ldr	r0, [r0, #0]
    16fa:	7883      	ldrb	r3, [r0, #2]
    16fc:	3b01      	subs	r3, #1
    16fe:	ea13 1814 	ands.w	r8, r3, r4, lsr #4
    1702:	d008      	beq.n	1716 <dir_next+0x5a>
	dp->index = (WORD)i;                                              /* Current index */
    1704:	80ec      	strh	r4, [r5, #6]
	dp->dir   = dp->fs->win + (i % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE; /* Current entry in the window */
    1706:	682b      	ldr	r3, [r5, #0]
    1708:	3334      	adds	r3, #52	; 0x34
    170a:	eb03 1347 	add.w	r3, r3, r7, lsl #5
    170e:	616b      	str	r3, [r5, #20]
	return FR_OK;
    1710:	2000      	movs	r0, #0
    1712:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				clst = get_fat(dp->fs, dp->clust);                           /* Get next cluster */
    1716:	4b30      	ldr	r3, [pc, #192]	; (17d8 <dir_next+0x11c>)
    1718:	4798      	blx	r3
    171a:	4681      	mov	r9, r0
				if (clst <= 1)
    171c:	2801      	cmp	r0, #1
    171e:	d948      	bls.n	17b2 <dir_next+0xf6>
				if (clst == 0xFFFFFFFF)
    1720:	f1b0 3fff 	cmp.w	r0, #4294967295
    1724:	d048      	beq.n	17b8 <dir_next+0xfc>
				if (clst >= dp->fs->n_fatent) { /* If it reached end of dynamic table, */
    1726:	6828      	ldr	r0, [r5, #0]
    1728:	6983      	ldr	r3, [r0, #24]
    172a:	4599      	cmp	r9, r3
    172c:	d339      	bcc.n	17a2 <dir_next+0xe6>
					if (!stretch)
    172e:	b916      	cbnz	r6, 1736 <dir_next+0x7a>
						return FR_NO_FILE;                  /* If do not stretch, report EOT */
    1730:	2004      	movs	r0, #4
    1732:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
					clst = create_chain(dp->fs, dp->clust); /* Stretch cluster chain */
    1736:	68e9      	ldr	r1, [r5, #12]
    1738:	4b28      	ldr	r3, [pc, #160]	; (17dc <dir_next+0x120>)
    173a:	4798      	blx	r3
					if (clst == 0)
    173c:	4681      	mov	r9, r0
    173e:	b910      	cbnz	r0, 1746 <dir_next+0x8a>
						return FR_DENIED; /* No free cluster */
    1740:	2007      	movs	r0, #7
    1742:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
					if (clst == 1)
    1746:	2801      	cmp	r0, #1
    1748:	d039      	beq.n	17be <dir_next+0x102>
					if (clst == 0xFFFFFFFF)
    174a:	f1b0 3fff 	cmp.w	r0, #4294967295
    174e:	d039      	beq.n	17c4 <dir_next+0x108>
					if (sync_window(dp->fs))
    1750:	6828      	ldr	r0, [r5, #0]
    1752:	4b23      	ldr	r3, [pc, #140]	; (17e0 <dir_next+0x124>)
    1754:	4798      	blx	r3
    1756:	2800      	cmp	r0, #0
    1758:	d137      	bne.n	17ca <dir_next+0x10e>
					mem_set(dp->fs->win, 0, SS(dp->fs));        /* Clear window buffer */
    175a:	6828      	ldr	r0, [r5, #0]
    175c:	f44f 7200 	mov.w	r2, #512	; 0x200
    1760:	2100      	movs	r1, #0
    1762:	3034      	adds	r0, #52	; 0x34
    1764:	4b1f      	ldr	r3, [pc, #124]	; (17e4 <dir_next+0x128>)
    1766:	4798      	blx	r3
					dp->fs->winsect = clust2sect(dp->fs, clst); /* Cluster start sector */
    1768:	682e      	ldr	r6, [r5, #0]
    176a:	4649      	mov	r1, r9
    176c:	4630      	mov	r0, r6
    176e:	4b1e      	ldr	r3, [pc, #120]	; (17e8 <dir_next+0x12c>)
    1770:	4798      	blx	r3
    1772:	6330      	str	r0, [r6, #48]	; 0x30
						dp->fs->wflag = 1;
    1774:	f04f 0a01 	mov.w	sl, #1
						if (sync_window(dp->fs))
    1778:	4e19      	ldr	r6, [pc, #100]	; (17e0 <dir_next+0x124>)
					for (c = 0; c < dp->fs->csize; c++) {       /* Fill the new cluster with 0 */
    177a:	682b      	ldr	r3, [r5, #0]
    177c:	789a      	ldrb	r2, [r3, #2]
    177e:	4590      	cmp	r8, r2
    1780:	d20b      	bcs.n	179a <dir_next+0xde>
						dp->fs->wflag = 1;
    1782:	f883 a004 	strb.w	sl, [r3, #4]
						if (sync_window(dp->fs))
    1786:	6828      	ldr	r0, [r5, #0]
    1788:	47b0      	blx	r6
    178a:	bb08      	cbnz	r0, 17d0 <dir_next+0x114>
						dp->fs->winsect++;
    178c:	682a      	ldr	r2, [r5, #0]
    178e:	6b13      	ldr	r3, [r2, #48]	; 0x30
    1790:	3301      	adds	r3, #1
    1792:	6313      	str	r3, [r2, #48]	; 0x30
					for (c = 0; c < dp->fs->csize; c++) {       /* Fill the new cluster with 0 */
    1794:	f108 0801 	add.w	r8, r8, #1
    1798:	e7ef      	b.n	177a <dir_next+0xbe>
					dp->fs->winsect -= c; /* Rewind window offset */
    179a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    179c:	eba2 0208 	sub.w	r2, r2, r8
    17a0:	631a      	str	r2, [r3, #48]	; 0x30
				dp->clust = clst; /* Initialize data for new cluster */
    17a2:	f8c5 900c 	str.w	r9, [r5, #12]
				dp->sect  = clust2sect(dp->fs, clst);
    17a6:	4649      	mov	r1, r9
    17a8:	6828      	ldr	r0, [r5, #0]
    17aa:	4b0f      	ldr	r3, [pc, #60]	; (17e8 <dir_next+0x12c>)
    17ac:	4798      	blx	r3
    17ae:	6128      	str	r0, [r5, #16]
    17b0:	e7a8      	b.n	1704 <dir_next+0x48>
					return FR_INT_ERR;
    17b2:	2002      	movs	r0, #2
    17b4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
					return FR_DISK_ERR;
    17b8:	2001      	movs	r0, #1
    17ba:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
						return FR_INT_ERR;
    17be:	2002      	movs	r0, #2
    17c0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
						return FR_DISK_ERR;
    17c4:	2001      	movs	r0, #1
    17c6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
						return FR_DISK_ERR;                     /* Flush disk access window */
    17ca:	2001      	movs	r0, #1
    17cc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
							return FR_DISK_ERR;
    17d0:	2001      	movs	r0, #1
}
    17d2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    17d6:	bf00      	nop
    17d8:	0000131d 	.word	0x0000131d
    17dc:	000015f1 	.word	0x000015f1
    17e0:	00000d01 	.word	0x00000d01
    17e4:	00000c71 	.word	0x00000c71
    17e8:	00001305 	.word	0x00001305

000017ec <follow_path>:
{
    17ec:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    17f0:	4605      	mov	r5, r0
    17f2:	460c      	mov	r4, r1
	if (*path == '/' || *path == '\\') { /* There is a heading separator */
    17f4:	780b      	ldrb	r3, [r1, #0]
    17f6:	2b2f      	cmp	r3, #47	; 0x2f
    17f8:	d00a      	beq.n	1810 <follow_path+0x24>
    17fa:	2b5c      	cmp	r3, #92	; 0x5c
    17fc:	d008      	beq.n	1810 <follow_path+0x24>
		dp->sclust = dp->fs->cdir; /* Start from the current directory */
    17fe:	6803      	ldr	r3, [r0, #0]
    1800:	695b      	ldr	r3, [r3, #20]
    1802:	6083      	str	r3, [r0, #8]
	if ((UINT)*path < ' ') { /* Null path name is the origin directory itself */
    1804:	7823      	ldrb	r3, [r4, #0]
    1806:	2b1f      	cmp	r3, #31
    1808:	d906      	bls.n	1818 <follow_path+0x2c>
		res = dir_next(dp, 0); /* Next entry */
    180a:	f8df 8238 	ldr.w	r8, [pc, #568]	; 1a44 <follow_path+0x258>
    180e:	e085      	b.n	191c <follow_path+0x130>
		path++;
    1810:	3401      	adds	r4, #1
		dp->sclust = 0;            /* Strip it and start from the root directory */
    1812:	2300      	movs	r3, #0
    1814:	60ab      	str	r3, [r5, #8]
    1816:	e7f5      	b.n	1804 <follow_path+0x18>
		res     = dir_sdi(dp, 0);
    1818:	2100      	movs	r1, #0
    181a:	4628      	mov	r0, r5
    181c:	4b83      	ldr	r3, [pc, #524]	; (1a2c <follow_path+0x240>)
    181e:	4798      	blx	r3
    1820:	4681      	mov	r9, r0
		dp->dir = 0;
    1822:	2300      	movs	r3, #0
    1824:	616b      	str	r3, [r5, #20]
    1826:	e0e0      	b.n	19ea <follow_path+0x1fe>
			sfn[i++] = c;
    1828:	232e      	movs	r3, #46	; 0x2e
    182a:	703b      	strb	r3, [r7, #0]
			c = (BYTE)p[si++];
    182c:	7873      	ldrb	r3, [r6, #1]
			if (c != '.' || si >= 3)
    182e:	2b2e      	cmp	r3, #46	; 0x2e
    1830:	d113      	bne.n	185a <follow_path+0x6e>
			sfn[i++] = c;
    1832:	707b      	strb	r3, [r7, #1]
			c = (BYTE)p[si++];
    1834:	78b3      	ldrb	r3, [r6, #2]
			if (c != '.' || si >= 3)
    1836:	2b2e      	cmp	r3, #46	; 0x2e
    1838:	d102      	bne.n	1840 <follow_path+0x54>
    183a:	f04f 0906 	mov.w	r9, #6
    183e:	e0d4      	b.n	19ea <follow_path+0x1fe>
			c = (BYTE)p[si++];
    1840:	2403      	movs	r4, #3
		if (c != '/' && c != '\\' && c > ' ')
    1842:	2b2f      	cmp	r3, #47	; 0x2f
    1844:	f000 80ba 	beq.w	19bc <follow_path+0x1d0>
    1848:	2b5c      	cmp	r3, #92	; 0x5c
    184a:	f000 80b7 	beq.w	19bc <follow_path+0x1d0>
    184e:	2b20      	cmp	r3, #32
    1850:	f200 80c9 	bhi.w	19e6 <follow_path+0x1fa>
		*path       = &p[si];                                 /* Return pointer to the next segment */
    1854:	4434      	add	r4, r6
		sfn[NSFLAG] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT; /* Set last segment flag if end of path */
    1856:	2324      	movs	r3, #36	; 0x24
    1858:	e0b2      	b.n	19c0 <follow_path+0x1d4>
			c = (BYTE)p[si++];
    185a:	2402      	movs	r4, #2
    185c:	e7f1      	b.n	1842 <follow_path+0x56>
			b |= 3;              /* Eliminate NT flag */
    185e:	f04c 0c03 	orr.w	ip, ip, #3
			c = ExCvt[c - 0x80]; /* To upper extended characters (SBCS cfg) */
    1862:	3b80      	subs	r3, #128	; 0x80
    1864:	4a72      	ldr	r2, [pc, #456]	; (1a30 <follow_path+0x244>)
    1866:	5cd3      	ldrb	r3, [r2, r3]
    1868:	e085      	b.n	1976 <follow_path+0x18a>
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c)) /* Reject illegal chrs for SFN */
    186a:	2b00      	cmp	r3, #0
    186c:	f040 80bb 	bne.w	19e6 <follow_path+0x1fa>
				if (IsLower(c)) { /* ASCII small capital? */
    1870:	f1a3 0261 	sub.w	r2, r3, #97	; 0x61
    1874:	b2d2      	uxtb	r2, r2
    1876:	2a19      	cmp	r2, #25
    1878:	f200 8091 	bhi.w	199e <follow_path+0x1b2>
					b |= 1;
    187c:	f04c 0c01 	orr.w	ip, ip, #1
					c -= 0x20;
    1880:	3b20      	subs	r3, #32
    1882:	b2db      	uxtb	r3, r3
    1884:	e08b      	b.n	199e <follow_path+0x1b2>
	if (sfn[0] == DDEM)
    1886:	783a      	ldrb	r2, [r7, #0]
    1888:	2ae5      	cmp	r2, #229	; 0xe5
		sfn[0] = RDDEM; /* When first character collides with DDEM, replace it with RDDEM */
    188a:	bf04      	itt	eq
    188c:	2205      	moveq	r2, #5
    188e:	703a      	strbeq	r2, [r7, #0]
	if (ni == 8)
    1890:	f1b9 0f08 	cmp.w	r9, #8
		b <<= 2;
    1894:	bf04      	itt	eq
    1896:	ea4f 0c8c 	moveq.w	ip, ip, lsl #2
    189a:	fa5f fc8c 	uxtbeq.w	ip, ip
	if ((b & 0x03) == 0x01)
    189e:	f00c 0203 	and.w	r2, ip, #3
    18a2:	2a01      	cmp	r2, #1
		c |= NS_EXT; /* NT flag (Name extension has only small capital) */
    18a4:	bf08      	it	eq
    18a6:	f043 0310 	orreq.w	r3, r3, #16
	if ((b & 0x0C) == 0x04)
    18aa:	f00c 0c0c 	and.w	ip, ip, #12
    18ae:	f1bc 0f04 	cmp.w	ip, #4
		c |= NS_BODY; /* NT flag (Name body has only small capital) */
    18b2:	bf08      	it	eq
    18b4:	f043 0308 	orreq.w	r3, r3, #8
	sfn[NSFLAG] = c; /* Store NT flag, File name is created */
    18b8:	72fb      	strb	r3, [r7, #11]
    18ba:	e082      	b.n	19c2 <follow_path+0x1d6>
		res = dir_next(dp, 0); /* Next entry */
    18bc:	4659      	mov	r1, fp
    18be:	4628      	mov	r0, r5
    18c0:	47c0      	blx	r8
	} while (res == FR_OK);
    18c2:	4681      	mov	r9, r0
    18c4:	2800      	cmp	r0, #0
    18c6:	f040 8093 	bne.w	19f0 <follow_path+0x204>
		res = move_window(dp->fs, dp->sect);
    18ca:	6929      	ldr	r1, [r5, #16]
    18cc:	6828      	ldr	r0, [r5, #0]
    18ce:	47b0      	blx	r6
		if (res != FR_OK)
    18d0:	4681      	mov	r9, r0
    18d2:	2800      	cmp	r0, #0
    18d4:	f040 808c 	bne.w	19f0 <follow_path+0x204>
		dir = dp->dir; /* Ptr to the directory entry of current index */
    18d8:	6969      	ldr	r1, [r5, #20]
		if (c == 0) {
    18da:	780b      	ldrb	r3, [r1, #0]
    18dc:	2b00      	cmp	r3, #0
    18de:	f000 8097 	beq.w	1a10 <follow_path+0x224>
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dp->fn, 11)) /* Is it a valid entry? */
    18e2:	f891 a00b 	ldrb.w	sl, [r1, #11]
    18e6:	f01a 0f08 	tst.w	sl, #8
    18ea:	d1e7      	bne.n	18bc <follow_path+0xd0>
    18ec:	69af      	ldr	r7, [r5, #24]
    18ee:	f101 0c0b 	add.w	ip, r1, #11
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
    18f2:	463a      	mov	r2, r7
    18f4:	460b      	mov	r3, r1
	while (cnt-- && (r = *d++ - *s++) == 0)
    18f6:	f813 eb01 	ldrb.w	lr, [r3], #1
    18fa:	f812 0b01 	ldrb.w	r0, [r2], #1
    18fe:	4586      	cmp	lr, r0
    1900:	d1dc      	bne.n	18bc <follow_path+0xd0>
    1902:	459c      	cmp	ip, r3
    1904:	d1f7      	bne.n	18f6 <follow_path+0x10a>
			if (ns & NS_LAST)
    1906:	7afb      	ldrb	r3, [r7, #11]
    1908:	f013 0f04 	tst.w	r3, #4
    190c:	d16d      	bne.n	19ea <follow_path+0x1fe>
			if (!(dir[DIR_Attr] & AM_DIR)) { /* It is not a sub-directory and cannot follow */
    190e:	f01a 0f10 	tst.w	sl, #16
    1912:	d050      	beq.n	19b6 <follow_path+0x1ca>
			dp->sclust = ld_clust(dp->fs, dir);
    1914:	6828      	ldr	r0, [r5, #0]
    1916:	4b47      	ldr	r3, [pc, #284]	; (1a34 <follow_path+0x248>)
    1918:	4798      	blx	r3
    191a:	60a8      	str	r0, [r5, #8]
    191c:	4626      	mov	r6, r4
	for (p = *path; *p == '/' || *p == '\\'; p++)
    191e:	f814 3b01 	ldrb.w	r3, [r4], #1
    1922:	2b2f      	cmp	r3, #47	; 0x2f
    1924:	d0fa      	beq.n	191c <follow_path+0x130>
    1926:	2b5c      	cmp	r3, #92	; 0x5c
    1928:	d0f8      	beq.n	191c <follow_path+0x130>
	sfn = dp->fn;
    192a:	69af      	ldr	r7, [r5, #24]
	mem_set(sfn, ' ', 11);
    192c:	220b      	movs	r2, #11
    192e:	2120      	movs	r1, #32
    1930:	4638      	mov	r0, r7
    1932:	4b41      	ldr	r3, [pc, #260]	; (1a38 <follow_path+0x24c>)
    1934:	4798      	blx	r3
	if (p[si] == '.') { /* Is this a dot entry? */
    1936:	7833      	ldrb	r3, [r6, #0]
    1938:	2b2e      	cmp	r3, #46	; 0x2e
    193a:	f43f af75 	beq.w	1828 <follow_path+0x3c>
    193e:	f106 3eff 	add.w	lr, r6, #4294967295
    1942:	2000      	movs	r0, #0
    1944:	4604      	mov	r4, r0
    1946:	f04f 0908 	mov.w	r9, #8
    194a:	4684      	mov	ip, r0
			ni = 11;
    194c:	f04f 0b0b 	mov.w	fp, #11
	while (*str && *str != chr)
    1950:	f04f 0a2a 	mov.w	sl, #42	; 0x2a
		c = (BYTE)p[si++];
    1954:	3401      	adds	r4, #1
    1956:	f81e 3f01 	ldrb.w	r3, [lr, #1]!
		if (c <= ' ' || c == '/' || c == '\\')
    195a:	2b20      	cmp	r3, #32
    195c:	d93b      	bls.n	19d6 <follow_path+0x1ea>
    195e:	2b2f      	cmp	r3, #47	; 0x2f
    1960:	d03c      	beq.n	19dc <follow_path+0x1f0>
    1962:	2b5c      	cmp	r3, #92	; 0x5c
    1964:	d03a      	beq.n	19dc <follow_path+0x1f0>
		if (c == '.' || i >= ni) {
    1966:	2b2e      	cmp	r3, #46	; 0x2e
    1968:	d055      	beq.n	1a16 <follow_path+0x22a>
    196a:	4581      	cmp	r9, r0
    196c:	d93b      	bls.n	19e6 <follow_path+0x1fa>
		if (c >= 0x80) {         /* Extended character? */
    196e:	f013 0f80 	tst.w	r3, #128	; 0x80
    1972:	f47f af74 	bne.w	185e <follow_path+0x72>
	while (*str && *str != chr)
    1976:	2b22      	cmp	r3, #34	; 0x22
    1978:	f43f af5f 	beq.w	183a <follow_path+0x4e>
    197c:	4652      	mov	r2, sl
    197e:	492f      	ldr	r1, [pc, #188]	; (1a3c <follow_path+0x250>)
    1980:	4293      	cmp	r3, r2
    1982:	f43f af72 	beq.w	186a <follow_path+0x7e>
    1986:	f811 2f01 	ldrb.w	r2, [r1, #1]!
    198a:	2a00      	cmp	r2, #0
    198c:	d1f8      	bne.n	1980 <follow_path+0x194>
			if (IsUpper(c)) { /* ASCII large capital? */
    198e:	f1a3 0241 	sub.w	r2, r3, #65	; 0x41
    1992:	b2d2      	uxtb	r2, r2
    1994:	2a19      	cmp	r2, #25
    1996:	f63f af6b 	bhi.w	1870 <follow_path+0x84>
				b |= 2;
    199a:	f04c 0c02 	orr.w	ip, ip, #2
			sfn[i++] = c;
    199e:	543b      	strb	r3, [r7, r0]
    19a0:	3001      	adds	r0, #1
    19a2:	e7d7      	b.n	1954 <follow_path+0x168>
						if (!(ns & NS_LAST))
    19a4:	f003 0304 	and.w	r3, r3, #4
							res = FR_NO_PATH; /* Adjust error code if not last segment */
    19a8:	2b00      	cmp	r3, #0
    19aa:	bf14      	ite	ne
    19ac:	f04f 0904 	movne.w	r9, #4
    19b0:	f04f 0905 	moveq.w	r9, #5
    19b4:	e019      	b.n	19ea <follow_path+0x1fe>
				res = FR_NO_PATH;
    19b6:	f04f 0905 	mov.w	r9, #5
    19ba:	e016      	b.n	19ea <follow_path+0x1fe>
		*path       = &p[si];                                 /* Return pointer to the next segment */
    19bc:	4434      	add	r4, r6
		sfn[NSFLAG] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT; /* Set last segment flag if end of path */
    19be:	2320      	movs	r3, #32
    19c0:	72fb      	strb	r3, [r7, #11]
	res = dir_sdi(dp, 0); /* Rewind directory object */
    19c2:	2100      	movs	r1, #0
    19c4:	4628      	mov	r0, r5
    19c6:	4b19      	ldr	r3, [pc, #100]	; (1a2c <follow_path+0x240>)
    19c8:	4798      	blx	r3
	if (res != FR_OK)
    19ca:	4681      	mov	r9, r0
    19cc:	b980      	cbnz	r0, 19f0 <follow_path+0x204>
		res = move_window(dp->fs, dp->sect);
    19ce:	4e1c      	ldr	r6, [pc, #112]	; (1a40 <follow_path+0x254>)
		res = dir_next(dp, 0); /* Next entry */
    19d0:	f04f 0b00 	mov.w	fp, #0
    19d4:	e779      	b.n	18ca <follow_path+0xde>
	*path = &p[si];                   /* Return pointer to the next segment */
    19d6:	4434      	add	r4, r6
	c     = (c <= ' ') ? NS_LAST : 0; /* Set last segment flag if end of path */
    19d8:	2304      	movs	r3, #4
    19da:	e001      	b.n	19e0 <follow_path+0x1f4>
	*path = &p[si];                   /* Return pointer to the next segment */
    19dc:	4434      	add	r4, r6
	c     = (c <= ' ') ? NS_LAST : 0; /* Set last segment flag if end of path */
    19de:	2300      	movs	r3, #0
	if (!i)
    19e0:	2800      	cmp	r0, #0
    19e2:	f47f af50 	bne.w	1886 <follow_path+0x9a>
			res = dir_find(dp); /* Find an object with the sagment name */
    19e6:	f04f 0906 	mov.w	r9, #6
}
    19ea:	4648      	mov	r0, r9
    19ec:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			ns  = dp->fn[NSFLAG];
    19f0:	69ab      	ldr	r3, [r5, #24]
    19f2:	7adb      	ldrb	r3, [r3, #11]
				if (res == FR_NO_FILE) {              /* Object is not found */
    19f4:	f1b9 0f04 	cmp.w	r9, #4
    19f8:	d1f7      	bne.n	19ea <follow_path+0x1fe>
					if (_FS_RPATH && (ns & NS_DOT)) { /* If dot entry is not exist, */
    19fa:	f013 0f20 	tst.w	r3, #32
    19fe:	d0d1      	beq.n	19a4 <follow_path+0x1b8>
						dp->sclust = 0;
    1a00:	2200      	movs	r2, #0
    1a02:	60aa      	str	r2, [r5, #8]
						dp->dir    = 0; /* it is the root directory and stay there */
    1a04:	616a      	str	r2, [r5, #20]
						if (!(ns & NS_LAST))
    1a06:	f013 0f04 	tst.w	r3, #4
    1a0a:	d087      	beq.n	191c <follow_path+0x130>
						res = FR_OK;  /* Ended at the root directroy. Function completed. */
    1a0c:	4691      	mov	r9, r2
    1a0e:	e7ec      	b.n	19ea <follow_path+0x1fe>
			ns  = dp->fn[NSFLAG];
    1a10:	69ab      	ldr	r3, [r5, #24]
    1a12:	7adb      	ldrb	r3, [r3, #11]
    1a14:	e7f1      	b.n	19fa <follow_path+0x20e>
			if (ni != 8 || c != '.')
    1a16:	f1b9 0f08 	cmp.w	r9, #8
    1a1a:	d1e4      	bne.n	19e6 <follow_path+0x1fa>
			b <<= 2;
    1a1c:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
    1a20:	fa5f fc8c 	uxtb.w	ip, ip
			i  = 8;
    1a24:	4648      	mov	r0, r9
			ni = 11;
    1a26:	46d9      	mov	r9, fp
    1a28:	e794      	b.n	1954 <follow_path+0x168>
    1a2a:	bf00      	nop
    1a2c:	00001401 	.word	0x00001401
    1a30:	000096bc 	.word	0x000096bc
    1a34:	00000c7f 	.word	0x00000c7f
    1a38:	00000c71 	.word	0x00000c71
    1a3c:	0000976d 	.word	0x0000976d
    1a40:	00000d71 	.word	0x00000d71
    1a44:	000016bd 	.word	0x000016bd

00001a48 <dir_register>:
{
    1a48:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    1a4c:	4604      	mov	r4, r0
	res = dir_sdi(dp, 0);
    1a4e:	2100      	movs	r1, #0
    1a50:	4b1b      	ldr	r3, [pc, #108]	; (1ac0 <dir_register+0x78>)
    1a52:	4798      	blx	r3
	if (res == FR_OK) {
    1a54:	2800      	cmp	r0, #0
    1a56:	d12b      	bne.n	1ab0 <dir_register+0x68>
			res = move_window(dp->fs, dp->sect);
    1a58:	4e1a      	ldr	r6, [pc, #104]	; (1ac4 <dir_register+0x7c>)
			res = dir_next(dp, 1); /* Next entry with table stretch enabled */
    1a5a:	f04f 0801 	mov.w	r8, #1
    1a5e:	4f1a      	ldr	r7, [pc, #104]	; (1ac8 <dir_register+0x80>)
    1a60:	e004      	b.n	1a6c <dir_register+0x24>
    1a62:	4641      	mov	r1, r8
    1a64:	4620      	mov	r0, r4
    1a66:	47b8      	blx	r7
		} while (res == FR_OK);
    1a68:	4605      	mov	r5, r0
    1a6a:	bb30      	cbnz	r0, 1aba <dir_register+0x72>
			res = move_window(dp->fs, dp->sect);
    1a6c:	6921      	ldr	r1, [r4, #16]
    1a6e:	6820      	ldr	r0, [r4, #0]
    1a70:	47b0      	blx	r6
			if (res != FR_OK)
    1a72:	4605      	mov	r5, r0
    1a74:	bb08      	cbnz	r0, 1aba <dir_register+0x72>
			if (dp->dir[0] == DDEM || dp->dir[0] == 0) { /* Is it a free entry? */
    1a76:	6963      	ldr	r3, [r4, #20]
    1a78:	781b      	ldrb	r3, [r3, #0]
    1a7a:	2be5      	cmp	r3, #229	; 0xe5
    1a7c:	d001      	beq.n	1a82 <dir_register+0x3a>
    1a7e:	2b00      	cmp	r3, #0
    1a80:	d1ef      	bne.n	1a62 <dir_register+0x1a>
		res = move_window(dp->fs, dp->sect);
    1a82:	6921      	ldr	r1, [r4, #16]
    1a84:	6820      	ldr	r0, [r4, #0]
    1a86:	4b0f      	ldr	r3, [pc, #60]	; (1ac4 <dir_register+0x7c>)
    1a88:	4798      	blx	r3
		if (res == FR_OK) {
    1a8a:	4605      	mov	r5, r0
    1a8c:	b110      	cbz	r0, 1a94 <dir_register+0x4c>
}
    1a8e:	4628      	mov	r0, r5
    1a90:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			mem_set(dp->dir, 0, SZ_DIRE); /* Clean the entry */
    1a94:	2220      	movs	r2, #32
    1a96:	2100      	movs	r1, #0
    1a98:	6960      	ldr	r0, [r4, #20]
    1a9a:	4b0c      	ldr	r3, [pc, #48]	; (1acc <dir_register+0x84>)
    1a9c:	4798      	blx	r3
			mem_cpy(dp->dir, dp->fn, 11); /* Put SFN */
    1a9e:	220b      	movs	r2, #11
    1aa0:	69a1      	ldr	r1, [r4, #24]
    1aa2:	6960      	ldr	r0, [r4, #20]
    1aa4:	4b0a      	ldr	r3, [pc, #40]	; (1ad0 <dir_register+0x88>)
    1aa6:	4798      	blx	r3
			dp->fs->wflag = 1;
    1aa8:	6823      	ldr	r3, [r4, #0]
    1aaa:	2201      	movs	r2, #1
    1aac:	711a      	strb	r2, [r3, #4]
    1aae:	e7ee      	b.n	1a8e <dir_register+0x46>
    1ab0:	4605      	mov	r5, r0
	if (res == FR_NO_FILE)
    1ab2:	2804      	cmp	r0, #4
    1ab4:	d1eb      	bne.n	1a8e <dir_register+0x46>
		res = FR_DENIED; /* No directory entry to allocate */
    1ab6:	2507      	movs	r5, #7
    1ab8:	e7e9      	b.n	1a8e <dir_register+0x46>
	if (res == FR_NO_FILE)
    1aba:	2d04      	cmp	r5, #4
    1abc:	d0fb      	beq.n	1ab6 <dir_register+0x6e>
    1abe:	e7e6      	b.n	1a8e <dir_register+0x46>
    1ac0:	00001401 	.word	0x00001401
    1ac4:	00000d71 	.word	0x00000d71
    1ac8:	000016bd 	.word	0x000016bd
    1acc:	00000c71 	.word	0x00000c71
    1ad0:	00000c5d 	.word	0x00000c5d

00001ad4 <remove_chain>:
	if (clst < 2 || clst >= fs->n_fatent) { /* Check if in valid range */
    1ad4:	2901      	cmp	r1, #1
    1ad6:	d930      	bls.n	1b3a <remove_chain+0x66>
{
    1ad8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    1adc:	4604      	mov	r4, r0
    1ade:	460e      	mov	r6, r1
	if (clst < 2 || clst >= fs->n_fatent) { /* Check if in valid range */
    1ae0:	6983      	ldr	r3, [r0, #24]
    1ae2:	4299      	cmp	r1, r3
    1ae4:	d303      	bcc.n	1aee <remove_chain+0x1a>
		res = FR_INT_ERR;
    1ae6:	2202      	movs	r2, #2
}
    1ae8:	4610      	mov	r0, r2
    1aea:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			nxt = get_fat(fs, clst);  /* Get cluster status */
    1aee:	4f17      	ldr	r7, [pc, #92]	; (1b4c <remove_chain+0x78>)
			res = put_fat(fs, clst, 0); /* Mark the cluster "empty" */
    1af0:	f04f 0900 	mov.w	r9, #0
    1af4:	f8df 8058 	ldr.w	r8, [pc, #88]	; 1b50 <remove_chain+0x7c>
    1af8:	e003      	b.n	1b02 <remove_chain+0x2e>
    1afa:	462e      	mov	r6, r5
		while (clst < fs->n_fatent) { /* Not a last link? */
    1afc:	69a3      	ldr	r3, [r4, #24]
    1afe:	42ab      	cmp	r3, r5
    1b00:	d9f2      	bls.n	1ae8 <remove_chain+0x14>
			nxt = get_fat(fs, clst);  /* Get cluster status */
    1b02:	4631      	mov	r1, r6
    1b04:	4620      	mov	r0, r4
    1b06:	47b8      	blx	r7
			if (nxt == 0)
    1b08:	4605      	mov	r5, r0
    1b0a:	b1c8      	cbz	r0, 1b40 <remove_chain+0x6c>
			if (nxt == 1) {
    1b0c:	2801      	cmp	r0, #1
    1b0e:	d019      	beq.n	1b44 <remove_chain+0x70>
			if (nxt == 0xFFFFFFFF) {
    1b10:	f1b0 3fff 	cmp.w	r0, #4294967295
    1b14:	d018      	beq.n	1b48 <remove_chain+0x74>
			res = put_fat(fs, clst, 0); /* Mark the cluster "empty" */
    1b16:	464a      	mov	r2, r9
    1b18:	4631      	mov	r1, r6
    1b1a:	4620      	mov	r0, r4
    1b1c:	47c0      	blx	r8
			if (res != FR_OK)
    1b1e:	4602      	mov	r2, r0
    1b20:	2800      	cmp	r0, #0
    1b22:	d1e1      	bne.n	1ae8 <remove_chain+0x14>
			if (fs->free_clust != 0xFFFFFFFF) { /* Update FSINFO */
    1b24:	6923      	ldr	r3, [r4, #16]
    1b26:	f1b3 3fff 	cmp.w	r3, #4294967295
    1b2a:	d0e6      	beq.n	1afa <remove_chain+0x26>
				fs->free_clust++;
    1b2c:	3301      	adds	r3, #1
    1b2e:	6123      	str	r3, [r4, #16]
				fs->fsi_flag |= 1;
    1b30:	7963      	ldrb	r3, [r4, #5]
    1b32:	f043 0301 	orr.w	r3, r3, #1
    1b36:	7163      	strb	r3, [r4, #5]
    1b38:	e7df      	b.n	1afa <remove_chain+0x26>
		res = FR_INT_ERR;
    1b3a:	2202      	movs	r2, #2
}
    1b3c:	4610      	mov	r0, r2
    1b3e:	4770      	bx	lr
    1b40:	2200      	movs	r2, #0
    1b42:	e7d1      	b.n	1ae8 <remove_chain+0x14>
				res = FR_INT_ERR;
    1b44:	2202      	movs	r2, #2
    1b46:	e7cf      	b.n	1ae8 <remove_chain+0x14>
				res = FR_DISK_ERR;
    1b48:	2201      	movs	r2, #1
    1b4a:	e7cd      	b.n	1ae8 <remove_chain+0x14>
    1b4c:	0000131d 	.word	0x0000131d
    1b50:	000014bd 	.word	0x000014bd

00001b54 <f_mount>:

FRESULT f_mount(FATFS *      fs,   /* Pointer to the file system object (NULL:unmount)*/
                const TCHAR *path, /* Logical drive number to be mounted/unmounted */
                BYTE         opt   /* 0:Do not mount (delayed mount), 1:Mount immediately */
                )
{
    1b54:	b510      	push	{r4, lr}
    1b56:	b084      	sub	sp, #16
    1b58:	9001      	str	r0, [sp, #4]
    1b5a:	9100      	str	r1, [sp, #0]
    1b5c:	4614      	mov	r4, r2
	FATFS *      cfs;
	int          vol;
	FRESULT      res;
	const TCHAR *rp = path;
    1b5e:	a804      	add	r0, sp, #16
    1b60:	f840 1d04 	str.w	r1, [r0, #-4]!

	vol = get_ldnumber(&rp);
    1b64:	4b14      	ldr	r3, [pc, #80]	; (1bb8 <f_mount+0x64>)
    1b66:	4798      	blx	r3
	if (vol < 0)
    1b68:	2800      	cmp	r0, #0
    1b6a:	db1a      	blt.n	1ba2 <f_mount+0x4e>
		return FR_INVALID_DRIVE;
	cfs = FatFs[vol]; /* Pointer to fs object */
    1b6c:	4b13      	ldr	r3, [pc, #76]	; (1bbc <f_mount+0x68>)
    1b6e:	eb03 0380 	add.w	r3, r3, r0, lsl #2
    1b72:	685b      	ldr	r3, [r3, #4]

	if (cfs) {
    1b74:	b10b      	cbz	r3, 1b7a <f_mount+0x26>
#endif
#if _FS_REENTRANT /* Discard sync object of the current volume */
		if (!ff_del_syncobj(cfs->sobj))
			return FR_INT_ERR;
#endif
		cfs->fs_type = 0; /* Clear old fs object */
    1b76:	2200      	movs	r2, #0
    1b78:	701a      	strb	r2, [r3, #0]
	}

	if (fs) {
    1b7a:	9b01      	ldr	r3, [sp, #4]
    1b7c:	b1b3      	cbz	r3, 1bac <f_mount+0x58>
		fs->fs_type = 0; /* Clear new fs object */
    1b7e:	2200      	movs	r2, #0
    1b80:	701a      	strb	r2, [r3, #0]
#if _FS_REENTRANT        /* Create sync object for the new volume */
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj))
			return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs; /* Register new fs object */
    1b82:	9a01      	ldr	r2, [sp, #4]
    1b84:	4b0d      	ldr	r3, [pc, #52]	; (1bbc <f_mount+0x68>)
    1b86:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    1b8a:	6042      	str	r2, [r0, #4]

	if (!fs || opt != 1)
    1b8c:	b162      	cbz	r2, 1ba8 <f_mount+0x54>
    1b8e:	2c01      	cmp	r4, #1
    1b90:	d001      	beq.n	1b96 <f_mount+0x42>
		return FR_OK; /* Do not mount now, it will be mounted later */
    1b92:	2000      	movs	r0, #0
    1b94:	e006      	b.n	1ba4 <f_mount+0x50>

	res = find_volume(&fs, &path, 0); /* Force mounted the volume */
    1b96:	2200      	movs	r2, #0
    1b98:	4669      	mov	r1, sp
    1b9a:	a801      	add	r0, sp, #4
    1b9c:	4b08      	ldr	r3, [pc, #32]	; (1bc0 <f_mount+0x6c>)
    1b9e:	4798      	blx	r3
	LEAVE_FF(fs, res);
    1ba0:	e000      	b.n	1ba4 <f_mount+0x50>
		return FR_INVALID_DRIVE;
    1ba2:	200b      	movs	r0, #11
}
    1ba4:	b004      	add	sp, #16
    1ba6:	bd10      	pop	{r4, pc}
		return FR_OK; /* Do not mount now, it will be mounted later */
    1ba8:	2000      	movs	r0, #0
    1baa:	e7fb      	b.n	1ba4 <f_mount+0x50>
	FatFs[vol] = fs; /* Register new fs object */
    1bac:	4b03      	ldr	r3, [pc, #12]	; (1bbc <f_mount+0x68>)
    1bae:	eb03 0380 	add.w	r3, r3, r0, lsl #2
    1bb2:	2000      	movs	r0, #0
    1bb4:	6058      	str	r0, [r3, #4]
    1bb6:	e7f5      	b.n	1ba4 <f_mount+0x50>
    1bb8:	00000ca1 	.word	0x00000ca1
    1bbc:	200000dc 	.word	0x200000dc
    1bc0:	00000e7d 	.word	0x00000e7d

00001bc4 <f_open>:

FRESULT f_open(FIL *        fp,   /* Pointer to the blank file object */
               const TCHAR *path, /* Pointer to the file name */
               BYTE         mode  /* Access mode and file open mode flags */
               )
{
    1bc4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    1bc8:	b08c      	sub	sp, #48	; 0x30
    1bca:	9101      	str	r1, [sp, #4]
	DEFINE_NAMEBUF;
#if !_FS_READONLY
	DWORD dw, cl;
#endif

	if (!fp)
    1bcc:	2800      	cmp	r0, #0
    1bce:	f000 80ac 	beq.w	1d2a <f_open+0x166>
    1bd2:	4604      	mov	r4, r0
    1bd4:	4615      	mov	r5, r2
		return FR_INVALID_OBJECT;
	fp->fs = 0; /* Clear file object */
    1bd6:	2300      	movs	r3, #0
    1bd8:	6003      	str	r3, [r0, #0]

/* Get logical drive number */
#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
	res = find_volume(&dj.fs, &path, (BYTE)(mode & ~FA_READ));
    1bda:	f002 021e 	and.w	r2, r2, #30
    1bde:	a901      	add	r1, sp, #4
    1be0:	a805      	add	r0, sp, #20
    1be2:	4b5c      	ldr	r3, [pc, #368]	; (1d54 <f_open+0x190>)
    1be4:	4798      	blx	r3
#else
	mode &= FA_READ;
	res = find_volume(&dj.fs, &path, 0);
#endif
	if (res == FR_OK) {
    1be6:	4606      	mov	r6, r0
    1be8:	2800      	cmp	r0, #0
    1bea:	f040 809f 	bne.w	1d2c <f_open+0x168>
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
    1bee:	f005 081f 	and.w	r8, r5, #31
		INIT_BUF(dj);
    1bf2:	ab02      	add	r3, sp, #8
    1bf4:	930b      	str	r3, [sp, #44]	; 0x2c
		res = follow_path(&dj, path); /* Follow the file path */
    1bf6:	9901      	ldr	r1, [sp, #4]
    1bf8:	a805      	add	r0, sp, #20
    1bfa:	4b57      	ldr	r3, [pc, #348]	; (1d58 <f_open+0x194>)
    1bfc:	4798      	blx	r3
		dir = dj.dir;
    1bfe:	9f0a      	ldr	r7, [sp, #40]	; 0x28
#if !_FS_READONLY /* R/W configuration */
		if (res == FR_OK) {
    1c00:	4603      	mov	r3, r0
    1c02:	2800      	cmp	r0, #0
    1c04:	d139      	bne.n	1c7a <f_open+0xb6>
			if (!dir) /* Default directory itself */
    1c06:	2f00      	cmp	r7, #0
    1c08:	f000 8094 	beq.w	1d34 <f_open+0x170>
			else
				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
#endif
		}
		/* Create or Open a file */
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
    1c0c:	f015 0f1c 	tst.w	r5, #28
    1c10:	d148      	bne.n	1ca4 <f_open+0xe0>
					}
				}
			}
		} else {                              /* Open an existing file */
			if (res == FR_OK) {               /* Following succeeded */
				if (dir[DIR_Attr] & AM_DIR) { /* It is a directory */
    1c12:	7afb      	ldrb	r3, [r7, #11]
    1c14:	f013 0f10 	tst.w	r3, #16
    1c18:	f040 8099 	bne.w	1d4e <f_open+0x18a>
					res = FR_NO_FILE;
				} else {
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
    1c1c:	f015 0f02 	tst.w	r5, #2
    1c20:	d003      	beq.n	1c2a <f_open+0x66>
    1c22:	f013 0f01 	tst.w	r3, #1
    1c26:	f040 8090 	bne.w	1d4a <f_open+0x186>
						res = FR_DENIED;
				}
			}
		}
		if (res == FR_OK) {
			if (mode & FA_CREATE_ALWAYS) /* Set file change flag if created or overwritten */
    1c2a:	f015 0f08 	tst.w	r5, #8
    1c2e:	d001      	beq.n	1c34 <f_open+0x70>
				mode |= FA__WRITTEN;
    1c30:	f048 0820 	orr.w	r8, r8, #32
			fp->dir_sect = dj.fs->winsect; /* Pointer to the directory entry */
    1c34:	9b05      	ldr	r3, [sp, #20]
    1c36:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    1c38:	61e3      	str	r3, [r4, #28]
			fp->dir_ptr  = dir;
    1c3a:	6227      	str	r7, [r4, #32]
		}
#endif
		FREE_BUF();

		if (res == FR_OK) {
			fp->flag   = mode;                         /* File access mode */
    1c3c:	f884 8006 	strb.w	r8, [r4, #6]
			fp->err    = 0;                            /* Clear error flag */
    1c40:	f04f 0800 	mov.w	r8, #0
    1c44:	f884 8007 	strb.w	r8, [r4, #7]
			fp->sclust = ld_clust(dj.fs, dir);         /* File start cluster */
    1c48:	9d05      	ldr	r5, [sp, #20]
    1c4a:	4639      	mov	r1, r7
    1c4c:	4628      	mov	r0, r5
    1c4e:	4b43      	ldr	r3, [pc, #268]	; (1d5c <f_open+0x198>)
    1c50:	4798      	blx	r3
    1c52:	6120      	str	r0, [r4, #16]
			fp->fsize  = LD_DWORD(dir + DIR_FileSize); /* File size */
    1c54:	7ffa      	ldrb	r2, [r7, #31]
    1c56:	7fbb      	ldrb	r3, [r7, #30]
    1c58:	041b      	lsls	r3, r3, #16
    1c5a:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
    1c5e:	7f3a      	ldrb	r2, [r7, #28]
    1c60:	4313      	orrs	r3, r2
    1c62:	7f7a      	ldrb	r2, [r7, #29]
    1c64:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    1c68:	60e3      	str	r3, [r4, #12]
			fp->fptr   = 0;                            /* File pointer */
    1c6a:	f8c4 8008 	str.w	r8, [r4, #8]
			fp->dsect  = 0;
    1c6e:	f8c4 8018 	str.w	r8, [r4, #24]
#if _USE_FASTSEEK
			fp->cltbl = 0; /* Normal seek mode */
#endif
			fp->fs = dj.fs; /* Validate file object */
    1c72:	6025      	str	r5, [r4, #0]
			fp->id = fp->fs->id;
    1c74:	88eb      	ldrh	r3, [r5, #6]
    1c76:	80a3      	strh	r3, [r4, #4]
    1c78:	e058      	b.n	1d2c <f_open+0x168>
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
    1c7a:	f015 0f1c 	tst.w	r5, #28
    1c7e:	d004      	beq.n	1c8a <f_open+0xc6>
				if (res == FR_NO_FILE) /* There is no file to open, create a new entry */
    1c80:	2804      	cmp	r0, #4
    1c82:	d006      	beq.n	1c92 <f_open+0xce>
				mode |= FA_CREATE_ALWAYS;                /* File is created */
    1c84:	f048 0808 	orr.w	r8, r8, #8
				dir = dj.dir;                            /* New entry */
    1c88:	9f0a      	ldr	r7, [sp, #40]	; 0x28
		if (res == FR_OK) {
    1c8a:	2b00      	cmp	r3, #0
    1c8c:	d0d6      	beq.n	1c3c <f_open+0x78>
    1c8e:	461e      	mov	r6, r3
    1c90:	e04c      	b.n	1d2c <f_open+0x168>
					res = dir_register(&dj);
    1c92:	a805      	add	r0, sp, #20
    1c94:	4b32      	ldr	r3, [pc, #200]	; (1d60 <f_open+0x19c>)
    1c96:	4798      	blx	r3
				mode |= FA_CREATE_ALWAYS;                /* File is created */
    1c98:	f048 0808 	orr.w	r8, r8, #8
				dir = dj.dir;                            /* New entry */
    1c9c:	9f0a      	ldr	r7, [sp, #40]	; 0x28
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) { /* Truncate it if overwrite mode */
    1c9e:	b140      	cbz	r0, 1cb2 <f_open+0xee>
					res = dir_register(&dj);
    1ca0:	4606      	mov	r6, r0
    1ca2:	e043      	b.n	1d2c <f_open+0x168>
				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) { /* Cannot overwrite it (R/O or DIR) */
    1ca4:	7afb      	ldrb	r3, [r7, #11]
    1ca6:	f013 0f11 	tst.w	r3, #17
    1caa:	d14a      	bne.n	1d42 <f_open+0x17e>
					if (mode & FA_CREATE_NEW) /* Cannot create as new file */
    1cac:	f015 0f04 	tst.w	r5, #4
    1cb0:	d149      	bne.n	1d46 <f_open+0x182>
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) { /* Truncate it if overwrite mode */
    1cb2:	f018 0f08 	tst.w	r8, #8
    1cb6:	d0bd      	beq.n	1c34 <f_open+0x70>
				dw = GET_FATTIME();
    1cb8:	4b2a      	ldr	r3, [pc, #168]	; (1d64 <f_open+0x1a0>)
    1cba:	4798      	blx	r3
				ST_DWORD(dir + DIR_CrtTime, dw); /* Set created time */
    1cbc:	b2c1      	uxtb	r1, r0
    1cbe:	73b9      	strb	r1, [r7, #14]
    1cc0:	f3c0 2207 	ubfx	r2, r0, #8, #8
    1cc4:	73fa      	strb	r2, [r7, #15]
    1cc6:	f3c0 4307 	ubfx	r3, r0, #16, #8
    1cca:	743b      	strb	r3, [r7, #16]
    1ccc:	0e00      	lsrs	r0, r0, #24
    1cce:	7478      	strb	r0, [r7, #17]
				ST_DWORD(dir + DIR_WrtTime, dw); /* Set modified time */
    1cd0:	75b9      	strb	r1, [r7, #22]
    1cd2:	75fa      	strb	r2, [r7, #23]
    1cd4:	763b      	strb	r3, [r7, #24]
    1cd6:	7678      	strb	r0, [r7, #25]
				dir[DIR_Attr] = 0;               /* Reset attribute */
    1cd8:	2500      	movs	r5, #0
    1cda:	72fd      	strb	r5, [r7, #11]
				ST_DWORD(dir + DIR_FileSize, 0); /* Reset file size */
    1cdc:	773d      	strb	r5, [r7, #28]
    1cde:	777d      	strb	r5, [r7, #29]
    1ce0:	77bd      	strb	r5, [r7, #30]
    1ce2:	77fd      	strb	r5, [r7, #31]
				cl = ld_clust(dj.fs, dir);       /* Get cluster chain */
    1ce4:	f8dd 9014 	ldr.w	r9, [sp, #20]
    1ce8:	4639      	mov	r1, r7
    1cea:	4648      	mov	r0, r9
    1cec:	4b1b      	ldr	r3, [pc, #108]	; (1d5c <f_open+0x198>)
    1cee:	4798      	blx	r3
	ST_WORD(dir + DIR_FstClusLO, cl);
    1cf0:	76bd      	strb	r5, [r7, #26]
    1cf2:	76fd      	strb	r5, [r7, #27]
	ST_WORD(dir + DIR_FstClusHI, cl >> 16);
    1cf4:	753d      	strb	r5, [r7, #20]
    1cf6:	757d      	strb	r5, [r7, #21]
				dj.fs->wflag = 1;
    1cf8:	2301      	movs	r3, #1
    1cfa:	f889 3004 	strb.w	r3, [r9, #4]
				if (cl) { /* Remove the cluster chain if exist */
    1cfe:	4605      	mov	r5, r0
    1d00:	2800      	cmp	r0, #0
    1d02:	d095      	beq.n	1c30 <f_open+0x6c>
					dw  = dj.fs->winsect;
    1d04:	f8d9 a030 	ldr.w	sl, [r9, #48]	; 0x30
					res = remove_chain(dj.fs, cl);
    1d08:	4601      	mov	r1, r0
    1d0a:	4648      	mov	r0, r9
    1d0c:	4b16      	ldr	r3, [pc, #88]	; (1d68 <f_open+0x1a4>)
    1d0e:	4798      	blx	r3
					if (res == FR_OK) {
    1d10:	b108      	cbz	r0, 1d16 <f_open+0x152>
					res = remove_chain(dj.fs, cl);
    1d12:	4606      	mov	r6, r0
    1d14:	e00a      	b.n	1d2c <f_open+0x168>
						dj.fs->last_clust = cl - 1; /* Reuse the cluster hole */
    1d16:	9805      	ldr	r0, [sp, #20]
    1d18:	3d01      	subs	r5, #1
    1d1a:	60c5      	str	r5, [r0, #12]
						res               = move_window(dj.fs, dw);
    1d1c:	4651      	mov	r1, sl
    1d1e:	4b13      	ldr	r3, [pc, #76]	; (1d6c <f_open+0x1a8>)
    1d20:	4798      	blx	r3
		if (res == FR_OK) {
    1d22:	2800      	cmp	r0, #0
    1d24:	d084      	beq.n	1c30 <f_open+0x6c>
						res               = move_window(dj.fs, dw);
    1d26:	4606      	mov	r6, r0
    1d28:	e000      	b.n	1d2c <f_open+0x168>
		return FR_INVALID_OBJECT;
    1d2a:	2609      	movs	r6, #9
		}
	}

	LEAVE_FF(dj.fs, res);
}
    1d2c:	4630      	mov	r0, r6
    1d2e:	b00c      	add	sp, #48	; 0x30
    1d30:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
    1d34:	f015 0f1c 	tst.w	r5, #28
    1d38:	d101      	bne.n	1d3e <f_open+0x17a>
				res = FR_INVALID_NAME;
    1d3a:	2306      	movs	r3, #6
    1d3c:	e7a5      	b.n	1c8a <f_open+0xc6>
    1d3e:	2306      	movs	r3, #6
    1d40:	e7a0      	b.n	1c84 <f_open+0xc0>
					res = FR_DENIED;
    1d42:	2607      	movs	r6, #7
    1d44:	e7f2      	b.n	1d2c <f_open+0x168>
						res = FR_EXIST;
    1d46:	2608      	movs	r6, #8
    1d48:	e7f0      	b.n	1d2c <f_open+0x168>
						res = FR_DENIED;
    1d4a:	2607      	movs	r6, #7
    1d4c:	e7ee      	b.n	1d2c <f_open+0x168>
					res = FR_NO_FILE;
    1d4e:	2604      	movs	r6, #4
    1d50:	e7ec      	b.n	1d2c <f_open+0x168>
    1d52:	bf00      	nop
    1d54:	00000e7d 	.word	0x00000e7d
    1d58:	000017ed 	.word	0x000017ed
    1d5c:	00000c7f 	.word	0x00000c7f
    1d60:	00001a49 	.word	0x00001a49
    1d64:	000021d5 	.word	0x000021d5
    1d68:	00001ad5 	.word	0x00001ad5
    1d6c:	00000d71 	.word	0x00000d71

00001d70 <f_read>:
FRESULT f_read(FIL * fp,   /* Pointer to the file object */
               void *buff, /* Pointer to data buffer */
               UINT  btr,  /* Number of bytes to read */
               UINT *br    /* Pointer to number of bytes read */
               )
{
    1d70:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1d74:	b083      	sub	sp, #12
    1d76:	4604      	mov	r4, r0
    1d78:	4688      	mov	r8, r1
    1d7a:	4615      	mov	r5, r2
    1d7c:	4699      	mov	r9, r3
	FRESULT res;
	DWORD   clst, sect, remain;
	UINT    rcnt, cc;
	BYTE    csect, *rbuff = (BYTE *)buff;

	*br = 0; /* Clear read byte counter */
    1d7e:	2300      	movs	r3, #0
    1d80:	f8c9 3000 	str.w	r3, [r9]

	res = validate(fp); /* Check validity */
    1d84:	4b5c      	ldr	r3, [pc, #368]	; (1ef8 <f_read+0x188>)
    1d86:	4798      	blx	r3
	if (res != FR_OK)
    1d88:	9001      	str	r0, [sp, #4]
    1d8a:	b948      	cbnz	r0, 1da0 <f_read+0x30>
		LEAVE_FF(fp->fs, res);
	if (fp->err) /* Check error */
    1d8c:	79e3      	ldrb	r3, [r4, #7]
    1d8e:	2b00      	cmp	r3, #0
    1d90:	f040 80b0 	bne.w	1ef4 <f_read+0x184>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
	if (!(fp->flag & FA_READ)) /* Check access mode */
    1d94:	79a3      	ldrb	r3, [r4, #6]
    1d96:	f013 0f01 	tst.w	r3, #1
    1d9a:	d105      	bne.n	1da8 <f_read+0x38>
		LEAVE_FF(fp->fs, FR_DENIED);
    1d9c:	2307      	movs	r3, #7
    1d9e:	9301      	str	r3, [sp, #4]
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt); /* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
}
    1da0:	9801      	ldr	r0, [sp, #4]
    1da2:	b003      	add	sp, #12
    1da4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	remain = fp->fsize - fp->fptr;
    1da8:	68e6      	ldr	r6, [r4, #12]
    1daa:	68a3      	ldr	r3, [r4, #8]
    1dac:	1af6      	subs	r6, r6, r3
    1dae:	42ae      	cmp	r6, r5
    1db0:	bf28      	it	cs
    1db2:	462e      	movcs	r6, r5
	for (; btr; /* Repeat until all data read */
    1db4:	2e00      	cmp	r6, #0
    1db6:	d155      	bne.n	1e64 <f_read+0xf4>
    1db8:	e7f2      	b.n	1da0 <f_read+0x30>
						clst = get_fat(fp->fs, fp->clust); /* Follow cluster chain on the FAT */
    1dba:	6961      	ldr	r1, [r4, #20]
    1dbc:	4b4f      	ldr	r3, [pc, #316]	; (1efc <f_read+0x18c>)
    1dbe:	4798      	blx	r3
    1dc0:	e060      	b.n	1e84 <f_read+0x114>
					ABORT(fp->fs, FR_INT_ERR);
    1dc2:	2302      	movs	r3, #2
    1dc4:	71e3      	strb	r3, [r4, #7]
    1dc6:	9301      	str	r3, [sp, #4]
    1dc8:	e7ea      	b.n	1da0 <f_read+0x30>
					ABORT(fp->fs, FR_DISK_ERR);
    1dca:	2301      	movs	r3, #1
    1dcc:	71e3      	strb	r3, [r4, #7]
    1dce:	9301      	str	r3, [sp, #4]
    1dd0:	e7e6      	b.n	1da0 <f_read+0x30>
				ABORT(fp->fs, FR_INT_ERR);
    1dd2:	2302      	movs	r3, #2
    1dd4:	71e3      	strb	r3, [r4, #7]
    1dd6:	9301      	str	r3, [sp, #4]
    1dd8:	e7e2      	b.n	1da0 <f_read+0x30>
					ABORT(fp->fs, FR_DISK_ERR);
    1dda:	2301      	movs	r3, #1
    1ddc:	71e3      	strb	r3, [r4, #7]
    1dde:	9301      	str	r3, [sp, #4]
    1de0:	e7de      	b.n	1da0 <f_read+0x30>
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
    1de2:	f44f 7200 	mov.w	r2, #512	; 0x200
    1de6:	f104 0124 	add.w	r1, r4, #36	; 0x24
    1dea:	eb08 2040 	add.w	r0, r8, r0, lsl #9
    1dee:	4b44      	ldr	r3, [pc, #272]	; (1f00 <f_read+0x190>)
    1df0:	4798      	blx	r3
    1df2:	e074      	b.n	1ede <f_read+0x16e>
			if (fp->dsect != sect) { /* Load data sector if not in cache */
    1df4:	69a2      	ldr	r2, [r4, #24]
    1df6:	4295      	cmp	r5, r2
    1df8:	d01a      	beq.n	1e30 <f_read+0xc0>
				if (fp->flag & FA__DIRTY) { /* Write-back dirty sector cache */
    1dfa:	79a3      	ldrb	r3, [r4, #6]
    1dfc:	f013 0f40 	tst.w	r3, #64	; 0x40
    1e00:	d00c      	beq.n	1e1c <f_read+0xac>
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
    1e02:	2301      	movs	r3, #1
    1e04:	f104 0124 	add.w	r1, r4, #36	; 0x24
    1e08:	f89a 0001 	ldrb.w	r0, [sl, #1]
    1e0c:	4f3d      	ldr	r7, [pc, #244]	; (1f04 <f_read+0x194>)
    1e0e:	47b8      	blx	r7
    1e10:	2800      	cmp	r0, #0
    1e12:	d167      	bne.n	1ee4 <f_read+0x174>
					fp->flag &= ~FA__DIRTY;
    1e14:	79a3      	ldrb	r3, [r4, #6]
    1e16:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    1e1a:	71a3      	strb	r3, [r4, #6]
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK) /* Fill sector cache */
    1e1c:	6820      	ldr	r0, [r4, #0]
    1e1e:	2301      	movs	r3, #1
    1e20:	462a      	mov	r2, r5
    1e22:	f104 0124 	add.w	r1, r4, #36	; 0x24
    1e26:	7840      	ldrb	r0, [r0, #1]
    1e28:	4f37      	ldr	r7, [pc, #220]	; (1f08 <f_read+0x198>)
    1e2a:	47b8      	blx	r7
    1e2c:	2800      	cmp	r0, #0
    1e2e:	d15d      	bne.n	1eec <f_read+0x17c>
			fp->dsect = sect;
    1e30:	61a5      	str	r5, [r4, #24]
		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs)); /* Get partial sector data from sector buffer */
    1e32:	68a1      	ldr	r1, [r4, #8]
    1e34:	f3c1 0108 	ubfx	r1, r1, #0, #9
    1e38:	f5c1 7500 	rsb	r5, r1, #512	; 0x200
    1e3c:	42b5      	cmp	r5, r6
    1e3e:	bf28      	it	cs
    1e40:	4635      	movcs	r5, r6
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt); /* Pick partial sector */
    1e42:	3124      	adds	r1, #36	; 0x24
    1e44:	462a      	mov	r2, r5
    1e46:	4421      	add	r1, r4
    1e48:	4640      	mov	r0, r8
    1e4a:	4b2d      	ldr	r3, [pc, #180]	; (1f00 <f_read+0x190>)
    1e4c:	4798      	blx	r3
	     rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
    1e4e:	44a8      	add	r8, r5
    1e50:	68a3      	ldr	r3, [r4, #8]
    1e52:	442b      	add	r3, r5
    1e54:	60a3      	str	r3, [r4, #8]
    1e56:	f8d9 3000 	ldr.w	r3, [r9]
    1e5a:	442b      	add	r3, r5
    1e5c:	f8c9 3000 	str.w	r3, [r9]
	for (; btr; /* Repeat until all data read */
    1e60:	1b76      	subs	r6, r6, r5
    1e62:	d09d      	beq.n	1da0 <f_read+0x30>
		if ((fp->fptr % SS(fp->fs)) == 0) {                              /* On the sector boundary? */
    1e64:	68a2      	ldr	r2, [r4, #8]
    1e66:	f3c2 0308 	ubfx	r3, r2, #0, #9
    1e6a:	2b00      	cmp	r3, #0
    1e6c:	d1e1      	bne.n	1e32 <f_read+0xc2>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1)); /* Sector offset in the cluster */
    1e6e:	6820      	ldr	r0, [r4, #0]
    1e70:	7883      	ldrb	r3, [r0, #2]
    1e72:	3b01      	subs	r3, #1
    1e74:	ea03 2352 	and.w	r3, r3, r2, lsr #9
			if (!csect) {                                                /* On the cluster boundary? */
    1e78:	f013 07ff 	ands.w	r7, r3, #255	; 0xff
    1e7c:	d108      	bne.n	1e90 <f_read+0x120>
				if (fp->fptr == 0) {                                     /* On the top of the file? */
    1e7e:	2a00      	cmp	r2, #0
    1e80:	d19b      	bne.n	1dba <f_read+0x4a>
					clst = fp->sclust;                                   /* Follow from the origin */
    1e82:	6920      	ldr	r0, [r4, #16]
				if (clst < 2)
    1e84:	2801      	cmp	r0, #1
    1e86:	d99c      	bls.n	1dc2 <f_read+0x52>
				if (clst == 0xFFFFFFFF)
    1e88:	f1b0 3fff 	cmp.w	r0, #4294967295
    1e8c:	d09d      	beq.n	1dca <f_read+0x5a>
				fp->clust = clst; /* Update current cluster */
    1e8e:	6160      	str	r0, [r4, #20]
			sect = clust2sect(fp->fs, fp->clust); /* Get current sector */
    1e90:	f8d4 a000 	ldr.w	sl, [r4]
    1e94:	6961      	ldr	r1, [r4, #20]
    1e96:	4650      	mov	r0, sl
    1e98:	4b1c      	ldr	r3, [pc, #112]	; (1f0c <f_read+0x19c>)
    1e9a:	4798      	blx	r3
			if (!sect)
    1e9c:	4605      	mov	r5, r0
    1e9e:	2800      	cmp	r0, #0
    1ea0:	d097      	beq.n	1dd2 <f_read+0x62>
			sect += csect;
    1ea2:	443d      	add	r5, r7
			if (cc) {                           /* Read maximum contiguous sectors directly */
    1ea4:	ea5f 2b56 	movs.w	fp, r6, lsr #9
    1ea8:	d0a4      	beq.n	1df4 <f_read+0x84>
				if (csect + cc > fp->fs->csize) /* Clip at cluster boundary */
    1eaa:	f89a 3002 	ldrb.w	r3, [sl, #2]
    1eae:	eb07 020b 	add.w	r2, r7, fp
    1eb2:	429a      	cmp	r2, r3
					cc = fp->fs->csize - csect;
    1eb4:	bf88      	it	hi
    1eb6:	eba3 0b07 	subhi.w	fp, r3, r7
				if (disk_read(fp->fs->drv, rbuff, sect, cc) != RES_OK)
    1eba:	fa5f f38b 	uxtb.w	r3, fp
    1ebe:	462a      	mov	r2, r5
    1ec0:	4641      	mov	r1, r8
    1ec2:	f89a 0001 	ldrb.w	r0, [sl, #1]
    1ec6:	4f10      	ldr	r7, [pc, #64]	; (1f08 <f_read+0x198>)
    1ec8:	47b8      	blx	r7
    1eca:	2800      	cmp	r0, #0
    1ecc:	d185      	bne.n	1dda <f_read+0x6a>
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
    1ece:	79a3      	ldrb	r3, [r4, #6]
    1ed0:	f013 0f40 	tst.w	r3, #64	; 0x40
    1ed4:	d003      	beq.n	1ede <f_read+0x16e>
    1ed6:	69a0      	ldr	r0, [r4, #24]
    1ed8:	1b40      	subs	r0, r0, r5
    1eda:	4583      	cmp	fp, r0
    1edc:	d881      	bhi.n	1de2 <f_read+0x72>
				rcnt = SS(fp->fs) * cc; /* Number of bytes transferred */
    1ede:	ea4f 254b 	mov.w	r5, fp, lsl #9
				continue;
    1ee2:	e7b4      	b.n	1e4e <f_read+0xde>
						ABORT(fp->fs, FR_DISK_ERR);
    1ee4:	2301      	movs	r3, #1
    1ee6:	71e3      	strb	r3, [r4, #7]
    1ee8:	9301      	str	r3, [sp, #4]
    1eea:	e759      	b.n	1da0 <f_read+0x30>
					ABORT(fp->fs, FR_DISK_ERR);
    1eec:	2301      	movs	r3, #1
    1eee:	71e3      	strb	r3, [r4, #7]
    1ef0:	9301      	str	r3, [sp, #4]
    1ef2:	e755      	b.n	1da0 <f_read+0x30>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
    1ef4:	9301      	str	r3, [sp, #4]
    1ef6:	e753      	b.n	1da0 <f_read+0x30>
    1ef8:	00000e41 	.word	0x00000e41
    1efc:	0000131d 	.word	0x0000131d
    1f00:	00000c5d 	.word	0x00000c5d
    1f04:	000004bd 	.word	0x000004bd
    1f08:	0000043d 	.word	0x0000043d
    1f0c:	00001305 	.word	0x00001305

00001f10 <f_write>:
FRESULT f_write(FIL *       fp,   /* Pointer to the file object */
                const void *buff, /* Pointer to the data to be written */
                UINT        btw,  /* Number of bytes to write */
                UINT *      bw    /* Pointer to number of bytes written */
                )
{
    1f10:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1f14:	b083      	sub	sp, #12
    1f16:	4604      	mov	r4, r0
    1f18:	4688      	mov	r8, r1
    1f1a:	4616      	mov	r6, r2
    1f1c:	4699      	mov	r9, r3
	DWORD       clst, sect;
	UINT        wcnt, cc;
	const BYTE *wbuff = (const BYTE *)buff;
	BYTE        csect;

	*bw = 0; /* Clear write byte counter */
    1f1e:	2300      	movs	r3, #0
    1f20:	f8c9 3000 	str.w	r3, [r9]

	res = validate(fp); /* Check validity */
    1f24:	4b6a      	ldr	r3, [pc, #424]	; (20d0 <f_write+0x1c0>)
    1f26:	4798      	blx	r3
	if (res != FR_OK)
    1f28:	9001      	str	r0, [sp, #4]
    1f2a:	b948      	cbnz	r0, 1f40 <f_write+0x30>
		LEAVE_FF(fp->fs, res);
	if (fp->err) /* Check error */
    1f2c:	79e3      	ldrb	r3, [r4, #7]
    1f2e:	2b00      	cmp	r3, #0
    1f30:	f040 80cc 	bne.w	20cc <f_write+0x1bc>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
	if (!(fp->flag & FA_WRITE)) /* Check access mode */
    1f34:	79a3      	ldrb	r3, [r4, #6]
    1f36:	f013 0f02 	tst.w	r3, #2
    1f3a:	d105      	bne.n	1f48 <f_write+0x38>
		LEAVE_FF(fp->fs, FR_DENIED);
    1f3c:	2307      	movs	r3, #7
    1f3e:	9301      	str	r3, [sp, #4]
	if (fp->fptr > fp->fsize)
		fp->fsize = fp->fptr; /* Update file size if needed */
	fp->flag |= FA__WRITTEN;  /* Set file change flag */

	LEAVE_FF(fp->fs, FR_OK);
}
    1f40:	9801      	ldr	r0, [sp, #4]
    1f42:	b003      	add	sp, #12
    1f44:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (fp->fptr + btw < fp->fptr)
    1f48:	68a3      	ldr	r3, [r4, #8]
    1f4a:	42f3      	cmn	r3, r6
    1f4c:	d20d      	bcs.n	1f6a <f_write+0x5a>
	for (; btw; /* Repeat until all data written */
    1f4e:	2e00      	cmp	r6, #0
    1f50:	d169      	bne.n	2026 <f_write+0x116>
    1f52:	e00a      	b.n	1f6a <f_write+0x5a>
						clst = create_chain(fp->fs, 0);                  /* Create a new cluster chain */
    1f54:	2100      	movs	r1, #0
    1f56:	4b5f      	ldr	r3, [pc, #380]	; (20d4 <f_write+0x1c4>)
    1f58:	4798      	blx	r3
    1f5a:	4603      	mov	r3, r0
    1f5c:	e003      	b.n	1f66 <f_write+0x56>
						clst = create_chain(fp->fs, fp->clust); /* Follow or stretch cluster chain on the FAT */
    1f5e:	6961      	ldr	r1, [r4, #20]
    1f60:	4b5c      	ldr	r3, [pc, #368]	; (20d4 <f_write+0x1c4>)
    1f62:	4798      	blx	r3
    1f64:	4603      	mov	r3, r0
				if (clst == 0)
    1f66:	2b00      	cmp	r3, #0
    1f68:	d16f      	bne.n	204a <f_write+0x13a>
	if (fp->fptr > fp->fsize)
    1f6a:	68a3      	ldr	r3, [r4, #8]
    1f6c:	68e2      	ldr	r2, [r4, #12]
    1f6e:	4293      	cmp	r3, r2
		fp->fsize = fp->fptr; /* Update file size if needed */
    1f70:	bf88      	it	hi
    1f72:	60e3      	strhi	r3, [r4, #12]
	fp->flag |= FA__WRITTEN;  /* Set file change flag */
    1f74:	79a3      	ldrb	r3, [r4, #6]
    1f76:	f043 0320 	orr.w	r3, r3, #32
    1f7a:	71a3      	strb	r3, [r4, #6]
	LEAVE_FF(fp->fs, FR_OK);
    1f7c:	e7e0      	b.n	1f40 <f_write+0x30>
					ABORT(fp->fs, FR_INT_ERR);
    1f7e:	2302      	movs	r3, #2
    1f80:	71e3      	strb	r3, [r4, #7]
    1f82:	9301      	str	r3, [sp, #4]
    1f84:	e7dc      	b.n	1f40 <f_write+0x30>
					ABORT(fp->fs, FR_DISK_ERR);
    1f86:	2301      	movs	r3, #1
    1f88:	71e3      	strb	r3, [r4, #7]
    1f8a:	9301      	str	r3, [sp, #4]
    1f8c:	e7d8      	b.n	1f40 <f_write+0x30>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
    1f8e:	6820      	ldr	r0, [r4, #0]
    1f90:	2301      	movs	r3, #1
    1f92:	69a2      	ldr	r2, [r4, #24]
    1f94:	f104 0124 	add.w	r1, r4, #36	; 0x24
    1f98:	7840      	ldrb	r0, [r0, #1]
    1f9a:	4d4f      	ldr	r5, [pc, #316]	; (20d8 <f_write+0x1c8>)
    1f9c:	47a8      	blx	r5
    1f9e:	b920      	cbnz	r0, 1faa <f_write+0x9a>
				fp->flag &= ~FA__DIRTY;
    1fa0:	79a3      	ldrb	r3, [r4, #6]
    1fa2:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    1fa6:	71a3      	strb	r3, [r4, #6]
    1fa8:	e05c      	b.n	2064 <f_write+0x154>
					ABORT(fp->fs, FR_DISK_ERR);
    1faa:	2301      	movs	r3, #1
    1fac:	71e3      	strb	r3, [r4, #7]
    1fae:	9301      	str	r3, [sp, #4]
    1fb0:	e7c6      	b.n	1f40 <f_write+0x30>
				ABORT(fp->fs, FR_INT_ERR);
    1fb2:	2302      	movs	r3, #2
    1fb4:	71e3      	strb	r3, [r4, #7]
    1fb6:	9301      	str	r3, [sp, #4]
    1fb8:	e7c2      	b.n	1f40 <f_write+0x30>
					ABORT(fp->fs, FR_DISK_ERR);
    1fba:	2301      	movs	r3, #1
    1fbc:	71e3      	strb	r3, [r4, #7]
    1fbe:	9301      	str	r3, [sp, #4]
    1fc0:	e7be      	b.n	1f40 <f_write+0x30>
					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
    1fc2:	f44f 7200 	mov.w	r2, #512	; 0x200
    1fc6:	eb08 2141 	add.w	r1, r8, r1, lsl #9
    1fca:	f104 0024 	add.w	r0, r4, #36	; 0x24
    1fce:	4b43      	ldr	r3, [pc, #268]	; (20dc <f_write+0x1cc>)
    1fd0:	4798      	blx	r3
					fp->flag &= ~FA__DIRTY;
    1fd2:	79a3      	ldrb	r3, [r4, #6]
    1fd4:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    1fd8:	71a3      	strb	r3, [r4, #6]
    1fda:	e066      	b.n	20aa <f_write+0x19a>
			if (fp->dsect != sect) { /* Fill sector cache with file data */
    1fdc:	69a3      	ldr	r3, [r4, #24]
    1fde:	429d      	cmp	r5, r3
    1fe0:	d003      	beq.n	1fea <f_write+0xda>
				if (fp->fptr < fp->fsize && disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
    1fe2:	68a2      	ldr	r2, [r4, #8]
    1fe4:	68e3      	ldr	r3, [r4, #12]
    1fe6:	429a      	cmp	r2, r3
    1fe8:	d362      	bcc.n	20b0 <f_write+0x1a0>
			fp->dsect = sect;
    1fea:	61a5      	str	r5, [r4, #24]
		wcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs)); /* Put partial sector into file I/O buffer */
    1fec:	68a0      	ldr	r0, [r4, #8]
    1fee:	f3c0 0008 	ubfx	r0, r0, #0, #9
    1ff2:	f5c0 7500 	rsb	r5, r0, #512	; 0x200
    1ff6:	42b5      	cmp	r5, r6
    1ff8:	bf28      	it	cs
    1ffa:	4635      	movcs	r5, r6
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt); /* Fit partial sector */
    1ffc:	3024      	adds	r0, #36	; 0x24
    1ffe:	462a      	mov	r2, r5
    2000:	4641      	mov	r1, r8
    2002:	4420      	add	r0, r4
    2004:	4b35      	ldr	r3, [pc, #212]	; (20dc <f_write+0x1cc>)
    2006:	4798      	blx	r3
		fp->flag |= FA__DIRTY;
    2008:	79a3      	ldrb	r3, [r4, #6]
    200a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    200e:	71a3      	strb	r3, [r4, #6]
	     wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
    2010:	44a8      	add	r8, r5
    2012:	68a3      	ldr	r3, [r4, #8]
    2014:	442b      	add	r3, r5
    2016:	60a3      	str	r3, [r4, #8]
    2018:	f8d9 3000 	ldr.w	r3, [r9]
    201c:	442b      	add	r3, r5
    201e:	f8c9 3000 	str.w	r3, [r9]
	for (; btw; /* Repeat until all data written */
    2022:	1b76      	subs	r6, r6, r5
    2024:	d0a1      	beq.n	1f6a <f_write+0x5a>
		if ((fp->fptr % SS(fp->fs)) == 0) {                              /* On the sector boundary? */
    2026:	68a2      	ldr	r2, [r4, #8]
    2028:	f3c2 0308 	ubfx	r3, r2, #0, #9
    202c:	2b00      	cmp	r3, #0
    202e:	d1dd      	bne.n	1fec <f_write+0xdc>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1)); /* Sector offset in the cluster */
    2030:	6820      	ldr	r0, [r4, #0]
    2032:	7883      	ldrb	r3, [r0, #2]
    2034:	3b01      	subs	r3, #1
    2036:	ea03 2352 	and.w	r3, r3, r2, lsr #9
			if (!csect) {                                                /* On the cluster boundary? */
    203a:	f013 07ff 	ands.w	r7, r3, #255	; 0xff
    203e:	d10d      	bne.n	205c <f_write+0x14c>
				if (fp->fptr == 0) {                                     /* On the top of the file? */
    2040:	2a00      	cmp	r2, #0
    2042:	d18c      	bne.n	1f5e <f_write+0x4e>
					clst = fp->sclust;                                   /* Follow from the origin */
    2044:	6923      	ldr	r3, [r4, #16]
					if (clst == 0)                                       /* When no cluster is allocated, */
    2046:	2b00      	cmp	r3, #0
    2048:	d084      	beq.n	1f54 <f_write+0x44>
				if (clst == 1)
    204a:	2b01      	cmp	r3, #1
    204c:	d097      	beq.n	1f7e <f_write+0x6e>
				if (clst == 0xFFFFFFFF)
    204e:	f1b3 3fff 	cmp.w	r3, #4294967295
    2052:	d098      	beq.n	1f86 <f_write+0x76>
				fp->clust = clst; /* Update current cluster */
    2054:	6163      	str	r3, [r4, #20]
				if (fp->sclust == 0)
    2056:	6922      	ldr	r2, [r4, #16]
    2058:	b902      	cbnz	r2, 205c <f_write+0x14c>
					fp->sclust = clst; /* Set start cluster if the first write */
    205a:	6123      	str	r3, [r4, #16]
			if (fp->flag & FA__DIRTY) { /* Write-back sector cache */
    205c:	79a3      	ldrb	r3, [r4, #6]
    205e:	f013 0f40 	tst.w	r3, #64	; 0x40
    2062:	d194      	bne.n	1f8e <f_write+0x7e>
			sect = clust2sect(fp->fs, fp->clust); /* Get current sector */
    2064:	f8d4 a000 	ldr.w	sl, [r4]
    2068:	6961      	ldr	r1, [r4, #20]
    206a:	4650      	mov	r0, sl
    206c:	4b1c      	ldr	r3, [pc, #112]	; (20e0 <f_write+0x1d0>)
    206e:	4798      	blx	r3
			if (!sect)
    2070:	4605      	mov	r5, r0
    2072:	2800      	cmp	r0, #0
    2074:	d09d      	beq.n	1fb2 <f_write+0xa2>
			sect += csect;
    2076:	443d      	add	r5, r7
			if (cc) {                           /* Write maximum contiguous sectors directly */
    2078:	ea5f 2b56 	movs.w	fp, r6, lsr #9
    207c:	d0ae      	beq.n	1fdc <f_write+0xcc>
				if (csect + cc > fp->fs->csize) /* Clip at cluster boundary */
    207e:	f89a 3002 	ldrb.w	r3, [sl, #2]
    2082:	eb07 020b 	add.w	r2, r7, fp
    2086:	429a      	cmp	r2, r3
					cc = fp->fs->csize - csect;
    2088:	bf88      	it	hi
    208a:	eba3 0b07 	subhi.w	fp, r3, r7
				if (disk_write(fp->fs->drv, wbuff, sect, cc) != RES_OK)
    208e:	fa5f f38b 	uxtb.w	r3, fp
    2092:	462a      	mov	r2, r5
    2094:	4641      	mov	r1, r8
    2096:	f89a 0001 	ldrb.w	r0, [sl, #1]
    209a:	4f0f      	ldr	r7, [pc, #60]	; (20d8 <f_write+0x1c8>)
    209c:	47b8      	blx	r7
    209e:	2800      	cmp	r0, #0
    20a0:	d18b      	bne.n	1fba <f_write+0xaa>
				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
    20a2:	69a1      	ldr	r1, [r4, #24]
    20a4:	1b49      	subs	r1, r1, r5
    20a6:	458b      	cmp	fp, r1
    20a8:	d88b      	bhi.n	1fc2 <f_write+0xb2>
				wcnt = SS(fp->fs) * cc; /* Number of bytes transferred */
    20aa:	ea4f 254b 	mov.w	r5, fp, lsl #9
				continue;
    20ae:	e7af      	b.n	2010 <f_write+0x100>
				if (fp->fptr < fp->fsize && disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
    20b0:	2301      	movs	r3, #1
    20b2:	462a      	mov	r2, r5
    20b4:	f104 0124 	add.w	r1, r4, #36	; 0x24
    20b8:	f89a 0001 	ldrb.w	r0, [sl, #1]
    20bc:	4f09      	ldr	r7, [pc, #36]	; (20e4 <f_write+0x1d4>)
    20be:	47b8      	blx	r7
    20c0:	2800      	cmp	r0, #0
    20c2:	d092      	beq.n	1fea <f_write+0xda>
					ABORT(fp->fs, FR_DISK_ERR);
    20c4:	2301      	movs	r3, #1
    20c6:	71e3      	strb	r3, [r4, #7]
    20c8:	9301      	str	r3, [sp, #4]
    20ca:	e739      	b.n	1f40 <f_write+0x30>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
    20cc:	9301      	str	r3, [sp, #4]
    20ce:	e737      	b.n	1f40 <f_write+0x30>
    20d0:	00000e41 	.word	0x00000e41
    20d4:	000015f1 	.word	0x000015f1
    20d8:	000004bd 	.word	0x000004bd
    20dc:	00000c5d 	.word	0x00000c5d
    20e0:	00001305 	.word	0x00001305
    20e4:	0000043d 	.word	0x0000043d

000020e8 <f_sync>:
/* Synchronize the File                                                  */
/*-----------------------------------------------------------------------*/

FRESULT f_sync(FIL *fp /* Pointer to the file object */
               )
{
    20e8:	b538      	push	{r3, r4, r5, lr}
    20ea:	4604      	mov	r4, r0
	FRESULT res;
	DWORD   tm;
	BYTE *  dir;

	res = validate(fp); /* Check validity of the object */
    20ec:	4b29      	ldr	r3, [pc, #164]	; (2194 <f_sync+0xac>)
    20ee:	4798      	blx	r3
	if (res == FR_OK) {
    20f0:	4603      	mov	r3, r0
    20f2:	b9d0      	cbnz	r0, 212a <f_sync+0x42>
		if (fp->flag & FA__WRITTEN) { /* Is there any change to the file? */
    20f4:	79a2      	ldrb	r2, [r4, #6]
    20f6:	f012 0f20 	tst.w	r2, #32
    20fa:	d016      	beq.n	212a <f_sync+0x42>
#if !_FS_TINY
			if (fp->flag & FA__DIRTY) { /* Write-back cached data if needed */
    20fc:	f012 0f40 	tst.w	r2, #64	; 0x40
    2100:	d00d      	beq.n	211e <f_sync+0x36>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
    2102:	6820      	ldr	r0, [r4, #0]
    2104:	2301      	movs	r3, #1
    2106:	69a2      	ldr	r2, [r4, #24]
    2108:	f104 0124 	add.w	r1, r4, #36	; 0x24
    210c:	7840      	ldrb	r0, [r0, #1]
    210e:	4d22      	ldr	r5, [pc, #136]	; (2198 <f_sync+0xb0>)
    2110:	47a8      	blx	r5
    2112:	2800      	cmp	r0, #0
    2114:	d13b      	bne.n	218e <f_sync+0xa6>
					LEAVE_FF(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
    2116:	79a3      	ldrb	r3, [r4, #6]
    2118:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    211c:	71a3      	strb	r3, [r4, #6]
			}
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
    211e:	69e1      	ldr	r1, [r4, #28]
    2120:	6820      	ldr	r0, [r4, #0]
    2122:	4b1e      	ldr	r3, [pc, #120]	; (219c <f_sync+0xb4>)
    2124:	4798      	blx	r3
			if (res == FR_OK) {
    2126:	4603      	mov	r3, r0
    2128:	b108      	cbz	r0, 212e <f_sync+0x46>
			}
		}
	}

	LEAVE_FF(fp->fs, res);
}
    212a:	4618      	mov	r0, r3
    212c:	bd38      	pop	{r3, r4, r5, pc}
				dir = fp->dir_ptr;
    212e:	6a25      	ldr	r5, [r4, #32]
				dir[DIR_Attr] |= AM_ARC;                 /* Set archive bit */
    2130:	7aeb      	ldrb	r3, [r5, #11]
    2132:	f043 0320 	orr.w	r3, r3, #32
    2136:	72eb      	strb	r3, [r5, #11]
				ST_DWORD(dir + DIR_FileSize, fp->fsize); /* Update file size */
    2138:	68e3      	ldr	r3, [r4, #12]
    213a:	772b      	strb	r3, [r5, #28]
    213c:	89a3      	ldrh	r3, [r4, #12]
    213e:	0a1b      	lsrs	r3, r3, #8
    2140:	776b      	strb	r3, [r5, #29]
    2142:	89e3      	ldrh	r3, [r4, #14]
    2144:	77ab      	strb	r3, [r5, #30]
    2146:	7be3      	ldrb	r3, [r4, #15]
    2148:	77eb      	strb	r3, [r5, #31]
				st_clust(dir, fp->sclust);               /* Update start cluster */
    214a:	6923      	ldr	r3, [r4, #16]
	ST_WORD(dir + DIR_FstClusLO, cl);
    214c:	76ab      	strb	r3, [r5, #26]
    214e:	f3c3 2207 	ubfx	r2, r3, #8, #8
    2152:	76ea      	strb	r2, [r5, #27]
	ST_WORD(dir + DIR_FstClusHI, cl >> 16);
    2154:	0c1b      	lsrs	r3, r3, #16
    2156:	752b      	strb	r3, [r5, #20]
    2158:	0a1b      	lsrs	r3, r3, #8
    215a:	756b      	strb	r3, [r5, #21]
				tm = GET_FATTIME();                      /* Update modified time */
    215c:	4b10      	ldr	r3, [pc, #64]	; (21a0 <f_sync+0xb8>)
    215e:	4798      	blx	r3
				ST_DWORD(dir + DIR_WrtTime, tm);
    2160:	75a8      	strb	r0, [r5, #22]
    2162:	f3c0 2307 	ubfx	r3, r0, #8, #8
    2166:	75eb      	strb	r3, [r5, #23]
    2168:	0c03      	lsrs	r3, r0, #16
    216a:	762b      	strb	r3, [r5, #24]
    216c:	0e00      	lsrs	r0, r0, #24
    216e:	7668      	strb	r0, [r5, #25]
				ST_WORD(dir + DIR_LstAccDate, 0);
    2170:	2300      	movs	r3, #0
    2172:	74ab      	strb	r3, [r5, #18]
    2174:	74eb      	strb	r3, [r5, #19]
				fp->flag &= ~FA__WRITTEN;
    2176:	79a3      	ldrb	r3, [r4, #6]
    2178:	f023 0320 	bic.w	r3, r3, #32
    217c:	71a3      	strb	r3, [r4, #6]
				fp->fs->wflag = 1;
    217e:	6823      	ldr	r3, [r4, #0]
    2180:	2201      	movs	r2, #1
    2182:	711a      	strb	r2, [r3, #4]
				res           = sync_fs(fp->fs);
    2184:	6820      	ldr	r0, [r4, #0]
    2186:	4b07      	ldr	r3, [pc, #28]	; (21a4 <f_sync+0xbc>)
    2188:	4798      	blx	r3
    218a:	4603      	mov	r3, r0
    218c:	e7cd      	b.n	212a <f_sync+0x42>
					LEAVE_FF(fp->fs, FR_DISK_ERR);
    218e:	2301      	movs	r3, #1
    2190:	e7cb      	b.n	212a <f_sync+0x42>
    2192:	bf00      	nop
    2194:	00000e41 	.word	0x00000e41
    2198:	000004bd 	.word	0x000004bd
    219c:	00000d71 	.word	0x00000d71
    21a0:	000021d5 	.word	0x000021d5
    21a4:	00001239 	.word	0x00001239

000021a8 <f_close>:
/* Close File                                                            */
/*-----------------------------------------------------------------------*/

FRESULT f_close(FIL *fp /* Pointer to the file object to be closed */
                )
{
    21a8:	b510      	push	{r4, lr}
    21aa:	4604      	mov	r4, r0
	FRESULT res;

#if !_FS_READONLY
	res = f_sync(fp); /* Flush cached data */
    21ac:	4b07      	ldr	r3, [pc, #28]	; (21cc <f_close+0x24>)
    21ae:	4798      	blx	r3
	if (res == FR_OK)
    21b0:	4603      	mov	r3, r0
    21b2:	b108      	cbz	r0, 21b8 <f_close+0x10>
			unlock_fs(fs, FR_OK); /* Unlock volume */
#endif
		}
	}
	return res;
}
    21b4:	4618      	mov	r0, r3
    21b6:	bd10      	pop	{r4, pc}
		res = validate(fp); /* Lock volume */
    21b8:	4620      	mov	r0, r4
    21ba:	4b05      	ldr	r3, [pc, #20]	; (21d0 <f_close+0x28>)
    21bc:	4798      	blx	r3
		if (res == FR_OK) {
    21be:	4603      	mov	r3, r0
    21c0:	2800      	cmp	r0, #0
    21c2:	d1f7      	bne.n	21b4 <f_close+0xc>
				fp->fs = 0; /* Invalidate file object */
    21c4:	2200      	movs	r2, #0
    21c6:	6022      	str	r2, [r4, #0]
    21c8:	e7f4      	b.n	21b4 <f_close+0xc>
    21ca:	bf00      	nop
    21cc:	000020e9 	.word	0x000020e9
    21d0:	00000e41 	.word	0x00000e41

000021d4 <get_fattime>:
 * bit4:0    Second (0..59)
 *
 * \return Current time.
 */
DWORD get_fattime(void)
{
    21d4:	b500      	push	{lr}
    21d6:	b083      	sub	sp, #12
	uint32_t                  ul_time;
	struct calendar_date_time datetime;
	calendar_get_date_time(&CALENDER_INTERFACE, &datetime);
    21d8:	4669      	mov	r1, sp
    21da:	480f      	ldr	r0, [pc, #60]	; (2218 <get_fattime+0x44>)
    21dc:	4b0f      	ldr	r3, [pc, #60]	; (221c <get_fattime+0x48>)
    21de:	4798      	blx	r3

	ul_time = ((datetime.date.year - 1980) << 25) | (datetime.date.month << 21) | (datetime.date.day << 16)
    21e0:	f89d 0005 	ldrb.w	r0, [sp, #5]
    21e4:	f89d 3004 	ldrb.w	r3, [sp, #4]
    21e8:	041b      	lsls	r3, r3, #16
	          | (datetime.time.hour << 11) | (datetime.time.min << 5) | (datetime.time.sec << 0);
    21ea:	ea43 5340 	orr.w	r3, r3, r0, lsl #21
    21ee:	f89d 0000 	ldrb.w	r0, [sp]
    21f2:	4303      	orrs	r3, r0
    21f4:	f89d 0002 	ldrb.w	r0, [sp, #2]
    21f8:	ea43 23c0 	orr.w	r3, r3, r0, lsl #11
    21fc:	f89d 0001 	ldrb.w	r0, [sp, #1]
    2200:	ea43 1340 	orr.w	r3, r3, r0, lsl #5
	ul_time = ((datetime.date.year - 1980) << 25) | (datetime.date.month << 21) | (datetime.date.day << 16)
    2204:	f8bd 0006 	ldrh.w	r0, [sp, #6]
    2208:	f2a0 70bc 	subw	r0, r0, #1980	; 0x7bc
	return ul_time;
}
    220c:	ea43 6040 	orr.w	r0, r3, r0, lsl #25
    2210:	b003      	add	sp, #12
    2212:	f85d fb04 	ldr.w	pc, [sp], #4
    2216:	bf00      	nop
    2218:	20001640 	.word	0x20001640
    221c:	0000239d 	.word	0x0000239d

00002220 <atomic_enter_critical>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
    2220:	f3ef 8310 	mrs	r3, PRIMASK
/**
 * \brief Disable interrupts, enter critical section
 */
void atomic_enter_critical(hal_atomic_t volatile *atomic)
{
	*atomic = __get_PRIMASK();
    2224:	6003      	str	r3, [r0, #0]
  __ASM volatile ("cpsid i" : : : "memory");
    2226:	b672      	cpsid	i
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
    2228:	f3bf 8f5f 	dmb	sy
    222c:	4770      	bx	lr

0000222e <atomic_leave_critical>:
    222e:	f3bf 8f5f 	dmb	sy
 * \brief Exit atomic section
 */
void atomic_leave_critical(hal_atomic_t volatile *atomic)
{
	__DMB();
	__set_PRIMASK(*atomic);
    2232:	6803      	ldr	r3, [r0, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
    2234:	f383 8810 	msr	PRIMASK, r3
    2238:	4770      	bx	lr
	...

0000223c <get_secs_in_month>:
 */
static uint32_t get_secs_in_month(uint32_t year, uint8_t month)
{
	uint32_t sec_in_month = 0;

	if (leap_year(year)) {
    223c:	f010 0f03 	tst.w	r0, #3
    2240:	d110      	bne.n	2264 <get_secs_in_month+0x28>
		switch (month) {
    2242:	3901      	subs	r1, #1
    2244:	290b      	cmp	r1, #11
    2246:	d81e      	bhi.n	2286 <get_secs_in_month+0x4a>
    2248:	e8df f001 	tbb	[pc, r1]
    224c:	0a060806 	.word	0x0a060806
    2250:	06060a06 	.word	0x06060a06
    2254:	060a060a 	.word	0x060a060a
		case 5:
		case 7:
		case 8:
		case 10:
		case 12:
			sec_in_month = SECS_IN_31DAYS;
    2258:	480d      	ldr	r0, [pc, #52]	; (2290 <get_secs_in_month+0x54>)
    225a:	4770      	bx	lr
			break;
		case 2:
			sec_in_month = SECS_IN_29DAYS;
    225c:	480d      	ldr	r0, [pc, #52]	; (2294 <get_secs_in_month+0x58>)
			break;
    225e:	4770      	bx	lr
		case 4:
		case 6:
		case 9:
		case 11:
			sec_in_month = SECS_IN_30DAYS;
    2260:	480d      	ldr	r0, [pc, #52]	; (2298 <get_secs_in_month+0x5c>)
			break;
    2262:	4770      	bx	lr
		default:
			break;
		}
	} else {
		switch (month) {
    2264:	3901      	subs	r1, #1
    2266:	290b      	cmp	r1, #11
    2268:	d80f      	bhi.n	228a <get_secs_in_month+0x4e>
    226a:	e8df f001 	tbb	[pc, r1]
    226e:	0806      	.short	0x0806
    2270:	0a060a06 	.word	0x0a060a06
    2274:	060a0606 	.word	0x060a0606
    2278:	060a      	.short	0x060a
		case 5:
		case 7:
		case 8:
		case 10:
		case 12:
			sec_in_month = SECS_IN_31DAYS;
    227a:	4805      	ldr	r0, [pc, #20]	; (2290 <get_secs_in_month+0x54>)
    227c:	4770      	bx	lr
			break;
		case 2:
			sec_in_month = SECS_IN_28DAYS;
    227e:	4807      	ldr	r0, [pc, #28]	; (229c <get_secs_in_month+0x60>)
			break;
    2280:	4770      	bx	lr
		case 4:
		case 6:
		case 9:
		case 11:
			sec_in_month = SECS_IN_30DAYS;
    2282:	4805      	ldr	r0, [pc, #20]	; (2298 <get_secs_in_month+0x5c>)
			break;
    2284:	4770      	bx	lr
	uint32_t sec_in_month = 0;
    2286:	2000      	movs	r0, #0
    2288:	4770      	bx	lr
    228a:	2000      	movs	r0, #0
			break;
		}
	}

	return sec_in_month;
}
    228c:	4770      	bx	lr
    228e:	bf00      	nop
    2290:	0028de80 	.word	0x0028de80
    2294:	00263b80 	.word	0x00263b80
    2298:	00278d00 	.word	0x00278d00
    229c:	0024ea00 	.word	0x0024ea00

000022a0 <convert_timestamp_to_datetime>:

/** \brief convert timestamp to date/time
 */
static int32_t convert_timestamp_to_datetime(struct calendar_descriptor *const calendar, uint32_t ts,
                                             struct calendar_date_time *dt)
{
    22a0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    22a4:	460c      	mov	r4, r1
    22a6:	4690      	mov	r8, r2
	uint32_t tmp, sec_in_year, sec_in_month;
	uint32_t tmp_year    = calendar->base_year;
    22a8:	6946      	ldr	r6, [r0, #20]

	tmp = ts;

	/* Find year */
	while (true) {
		sec_in_year = leap_year(tmp_year) ? SECS_IN_LEAP_YEAR : SECS_IN_NON_LEAP_YEAR;
    22aa:	4927      	ldr	r1, [pc, #156]	; (2348 <convert_timestamp_to_datetime+0xa8>)
    22ac:	4a27      	ldr	r2, [pc, #156]	; (234c <convert_timestamp_to_datetime+0xac>)
    22ae:	b2b7      	uxth	r7, r6
    22b0:	f007 0303 	and.w	r3, r7, #3
    22b4:	2b00      	cmp	r3, #0
    22b6:	bf0c      	ite	eq
    22b8:	460b      	moveq	r3, r1
    22ba:	4613      	movne	r3, r2

		if (tmp >= sec_in_year) {
    22bc:	429c      	cmp	r4, r3
    22be:	d302      	bcc.n	22c6 <convert_timestamp_to_datetime+0x26>
			tmp -= sec_in_year;
    22c0:	1ae4      	subs	r4, r4, r3
			tmp_year++;
    22c2:	3601      	adds	r6, #1
		sec_in_year = leap_year(tmp_year) ? SECS_IN_LEAP_YEAR : SECS_IN_NON_LEAP_YEAR;
    22c4:	e7f3      	b.n	22ae <convert_timestamp_to_datetime+0xe>
    22c6:	2501      	movs	r5, #1
			break;
		}
	}
	/* Find month of year */
	while (true) {
		sec_in_month = get_secs_in_month(tmp_year, tmp_month);
    22c8:	f8df 9088 	ldr.w	r9, [pc, #136]	; 2354 <convert_timestamp_to_datetime+0xb4>
    22cc:	4629      	mov	r1, r5
    22ce:	4630      	mov	r0, r6
    22d0:	47c8      	blx	r9

		if (tmp >= sec_in_month) {
    22d2:	4284      	cmp	r4, r0
    22d4:	d303      	bcc.n	22de <convert_timestamp_to_datetime+0x3e>
			tmp -= sec_in_month;
    22d6:	1a24      	subs	r4, r4, r0
			tmp_month++;
    22d8:	3501      	adds	r5, #1
    22da:	b2ed      	uxtb	r5, r5
		sec_in_month = get_secs_in_month(tmp_year, tmp_month);
    22dc:	e7f6      	b.n	22cc <convert_timestamp_to_datetime+0x2c>
			break;
		}
	}
	/* Find day of month */
	while (true) {
		if (tmp >= SECS_IN_DAY) {
    22de:	4b1c      	ldr	r3, [pc, #112]	; (2350 <convert_timestamp_to_datetime+0xb0>)
    22e0:	429c      	cmp	r4, r3
    22e2:	bf98      	it	ls
    22e4:	2101      	movls	r1, #1
    22e6:	d909      	bls.n	22fc <convert_timestamp_to_datetime+0x5c>
    22e8:	2101      	movs	r1, #1
    22ea:	4b19      	ldr	r3, [pc, #100]	; (2350 <convert_timestamp_to_datetime+0xb0>)
			tmp -= SECS_IN_DAY;
    22ec:	f5a4 34a8 	sub.w	r4, r4, #86016	; 0x15000
    22f0:	f5a4 74c0 	sub.w	r4, r4, #384	; 0x180
			tmp_day++;
    22f4:	3101      	adds	r1, #1
    22f6:	b2c9      	uxtb	r1, r1
		if (tmp >= SECS_IN_DAY) {
    22f8:	429c      	cmp	r4, r3
    22fa:	d8f7      	bhi.n	22ec <convert_timestamp_to_datetime+0x4c>
			break;
		}
	}
	/* Find hour of day */
	while (true) {
		if (tmp >= SECS_IN_HOUR) {
    22fc:	f5b4 6f61 	cmp.w	r4, #3600	; 0xe10
    2300:	bf38      	it	cc
    2302:	2200      	movcc	r2, #0
    2304:	d307      	bcc.n	2316 <convert_timestamp_to_datetime+0x76>
    2306:	2200      	movs	r2, #0
			tmp -= SECS_IN_HOUR;
    2308:	f5a4 6461 	sub.w	r4, r4, #3600	; 0xe10
			tmp_hour++;
    230c:	3201      	adds	r2, #1
    230e:	b2d2      	uxtb	r2, r2
		if (tmp >= SECS_IN_HOUR) {
    2310:	f5b4 6f61 	cmp.w	r4, #3600	; 0xe10
    2314:	d2f8      	bcs.n	2308 <convert_timestamp_to_datetime+0x68>
			break;
		}
	}
	/* Find minute in hour */
	while (true) {
		if (tmp >= SECS_IN_MINUTE) {
    2316:	2c3b      	cmp	r4, #59	; 0x3b
    2318:	bf98      	it	ls
    231a:	2300      	movls	r3, #0
    231c:	d905      	bls.n	232a <convert_timestamp_to_datetime+0x8a>
    231e:	2300      	movs	r3, #0
			tmp -= SECS_IN_MINUTE;
    2320:	3c3c      	subs	r4, #60	; 0x3c
			tmp_minutes++;
    2322:	3301      	adds	r3, #1
    2324:	b2db      	uxtb	r3, r3
		if (tmp >= SECS_IN_MINUTE) {
    2326:	2c3b      	cmp	r4, #59	; 0x3b
    2328:	d8fa      	bhi.n	2320 <convert_timestamp_to_datetime+0x80>
		} else {
			break;
		}
	}

	dt->date.year  = tmp_year;
    232a:	f8a8 7006 	strh.w	r7, [r8, #6]
	dt->date.month = tmp_month;
    232e:	f888 5005 	strb.w	r5, [r8, #5]
	dt->date.day   = tmp_day;
    2332:	f888 1004 	strb.w	r1, [r8, #4]
	dt->time.hour  = tmp_hour;
    2336:	f888 2002 	strb.w	r2, [r8, #2]
	dt->time.min   = tmp_minutes;
    233a:	f888 3001 	strb.w	r3, [r8, #1]
	dt->time.sec   = tmp;
    233e:	f888 4000 	strb.w	r4, [r8]

	return ERR_NONE;
}
    2342:	2000      	movs	r0, #0
    2344:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    2348:	01e28500 	.word	0x01e28500
    234c:	01e13380 	.word	0x01e13380
    2350:	0001517f 	.word	0x0001517f
    2354:	0000223d 	.word	0x0000223d

00002358 <calendar_init>:
}

/** \brief Initialize Calendar
 */
int32_t calendar_init(struct calendar_descriptor *const calendar, const void *hw)
{
    2358:	b538      	push	{r3, r4, r5, lr}
    235a:	460d      	mov	r5, r1
	int32_t ret = 0;

	/* Sanity check arguments */
	ASSERT(calendar);
    235c:	4604      	mov	r4, r0
    235e:	f44f 72e5 	mov.w	r2, #458	; 0x1ca
    2362:	490b      	ldr	r1, [pc, #44]	; (2390 <calendar_init+0x38>)
    2364:	3000      	adds	r0, #0
    2366:	bf18      	it	ne
    2368:	2001      	movne	r0, #1
    236a:	4b0a      	ldr	r3, [pc, #40]	; (2394 <calendar_init+0x3c>)
    236c:	4798      	blx	r3

	if (calendar->device.hw == hw) {
    236e:	6823      	ldr	r3, [r4, #0]
    2370:	42ab      	cmp	r3, r5
    2372:	d008      	beq.n	2386 <calendar_init+0x2e>
		/* Already initialized with current configuration */
		return ERR_NONE;
	} else if (calendar->device.hw != NULL) {
    2374:	b94b      	cbnz	r3, 238a <calendar_init+0x32>
		/* Initialized with another configuration */
		return ERR_ALREADY_INITIALIZED;
	}
	calendar->device.hw = (void *)hw;
    2376:	6025      	str	r5, [r4, #0]
	ret                 = _calendar_init(&calendar->device);
    2378:	4620      	mov	r0, r4
    237a:	4b07      	ldr	r3, [pc, #28]	; (2398 <calendar_init+0x40>)
    237c:	4798      	blx	r3
	calendar->base_year = DEFAULT_BASE_YEAR;
    237e:	f240 73b2 	movw	r3, #1970	; 0x7b2
    2382:	6163      	str	r3, [r4, #20]

	return ret;
    2384:	bd38      	pop	{r3, r4, r5, pc}
		return ERR_NONE;
    2386:	2000      	movs	r0, #0
    2388:	bd38      	pop	{r3, r4, r5, pc}
		return ERR_ALREADY_INITIALIZED;
    238a:	f06f 0011 	mvn.w	r0, #17
}
    238e:	bd38      	pop	{r3, r4, r5, pc}
    2390:	000097b0 	.word	0x000097b0
    2394:	00003205 	.word	0x00003205
    2398:	000037d1 	.word	0x000037d1

0000239c <calendar_get_date_time>:
}

/** \brief Get date/time for calendar
 */
int32_t calendar_get_date_time(struct calendar_descriptor *const calendar, struct calendar_date_time *const date_time)
{
    239c:	b538      	push	{r3, r4, r5, lr}
    239e:	460d      	mov	r5, r1
	uint32_t current_ts;

	/* Sanity check arguments */
	ASSERT(calendar);
    23a0:	4604      	mov	r4, r0
    23a2:	f240 2245 	movw	r2, #581	; 0x245
    23a6:	4908      	ldr	r1, [pc, #32]	; (23c8 <calendar_get_date_time+0x2c>)
    23a8:	3000      	adds	r0, #0
    23aa:	bf18      	it	ne
    23ac:	2001      	movne	r0, #1
    23ae:	4b07      	ldr	r3, [pc, #28]	; (23cc <calendar_get_date_time+0x30>)
    23b0:	4798      	blx	r3

	/* convert current timestamp to date/time */
	current_ts = _calendar_get_counter(&calendar->device);
    23b2:	4620      	mov	r0, r4
    23b4:	4b06      	ldr	r3, [pc, #24]	; (23d0 <calendar_get_date_time+0x34>)
    23b6:	4798      	blx	r3
	convert_timestamp_to_datetime(calendar, current_ts, date_time);
    23b8:	462a      	mov	r2, r5
    23ba:	4601      	mov	r1, r0
    23bc:	4620      	mov	r0, r4
    23be:	4b05      	ldr	r3, [pc, #20]	; (23d4 <calendar_get_date_time+0x38>)
    23c0:	4798      	blx	r3

	return ERR_NONE;
}
    23c2:	2000      	movs	r0, #0
    23c4:	bd38      	pop	{r3, r4, r5, pc}
    23c6:	bf00      	nop
    23c8:	000097b0 	.word	0x000097b0
    23cc:	00003205 	.word	0x00003205
    23d0:	00003861 	.word	0x00003861
    23d4:	000022a1 	.word	0x000022a1

000023d8 <process_ext_irq>:
 * \brief Interrupt processing routine
 *
 * \param[in] pin The pin which triggered the interrupt
 */
static void process_ext_irq(const uint32_t pin)
{
    23d8:	b570      	push	{r4, r5, r6, lr}
		middle = (upper + lower) >> 1;
		if (middle >= EXT_IRQ_AMOUNT) {
			return;
		}

		if (ext_irqs[middle].pin == pin) {
    23da:	4b12      	ldr	r3, [pc, #72]	; (2424 <process_ext_irq+0x4c>)
    23dc:	6959      	ldr	r1, [r3, #20]
    23de:	4288      	cmp	r0, r1
    23e0:	d01d      	beq.n	241e <process_ext_irq+0x46>
    23e2:	2202      	movs	r2, #2
    23e4:	2504      	movs	r5, #4
    23e6:	2400      	movs	r4, #0
    23e8:	461e      	mov	r6, r3
				ext_irqs[middle].cb();
			}
			return;
		}

		if (ext_irqs[middle].pin < pin) {
    23ea:	4288      	cmp	r0, r1
			lower = middle + 1;
    23ec:	bf87      	ittee	hi
    23ee:	3201      	addhi	r2, #1
    23f0:	b2d4      	uxtbhi	r4, r2
		} else {
			upper = middle - 1;
    23f2:	f102 32ff 	addls.w	r2, r2, #4294967295
    23f6:	b2d5      	uxtbls	r5, r2
	while (upper >= lower) {
    23f8:	42a5      	cmp	r5, r4
    23fa:	d312      	bcc.n	2422 <process_ext_irq+0x4a>
		middle = (upper + lower) >> 1;
    23fc:	192b      	adds	r3, r5, r4
    23fe:	105b      	asrs	r3, r3, #1
    2400:	b2da      	uxtb	r2, r3
		if (middle >= EXT_IRQ_AMOUNT) {
    2402:	2a03      	cmp	r2, #3
    2404:	d80d      	bhi.n	2422 <process_ext_irq+0x4a>
    2406:	4613      	mov	r3, r2
		if (ext_irqs[middle].pin == pin) {
    2408:	eb06 01c2 	add.w	r1, r6, r2, lsl #3
    240c:	6849      	ldr	r1, [r1, #4]
    240e:	4281      	cmp	r1, r0
    2410:	d1eb      	bne.n	23ea <process_ext_irq+0x12>
			if (ext_irqs[middle].cb) {
    2412:	4a04      	ldr	r2, [pc, #16]	; (2424 <process_ext_irq+0x4c>)
    2414:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
    2418:	b11b      	cbz	r3, 2422 <process_ext_irq+0x4a>
				ext_irqs[middle].cb();
    241a:	4798      	blx	r3
    241c:	bd70      	pop	{r4, r5, r6, pc}
		if (ext_irqs[middle].pin == pin) {
    241e:	2302      	movs	r3, #2
    2420:	e7f7      	b.n	2412 <process_ext_irq+0x3a>
    2422:	bd70      	pop	{r4, r5, r6, pc}
    2424:	200000f8 	.word	0x200000f8

00002428 <ext_irq_init>:
{
    2428:	b508      	push	{r3, lr}
		ext_irqs[i].pin = 0xFFFFFFFF;
    242a:	4b08      	ldr	r3, [pc, #32]	; (244c <ext_irq_init+0x24>)
    242c:	f04f 31ff 	mov.w	r1, #4294967295
    2430:	6059      	str	r1, [r3, #4]
		ext_irqs[i].cb  = NULL;
    2432:	2200      	movs	r2, #0
    2434:	601a      	str	r2, [r3, #0]
		ext_irqs[i].pin = 0xFFFFFFFF;
    2436:	60d9      	str	r1, [r3, #12]
		ext_irqs[i].cb  = NULL;
    2438:	609a      	str	r2, [r3, #8]
		ext_irqs[i].pin = 0xFFFFFFFF;
    243a:	6159      	str	r1, [r3, #20]
		ext_irqs[i].cb  = NULL;
    243c:	611a      	str	r2, [r3, #16]
		ext_irqs[i].pin = 0xFFFFFFFF;
    243e:	61d9      	str	r1, [r3, #28]
		ext_irqs[i].cb  = NULL;
    2440:	619a      	str	r2, [r3, #24]
	return _ext_irq_init(process_ext_irq);
    2442:	4803      	ldr	r0, [pc, #12]	; (2450 <ext_irq_init+0x28>)
    2444:	4b03      	ldr	r3, [pc, #12]	; (2454 <ext_irq_init+0x2c>)
    2446:	4798      	blx	r3
}
    2448:	bd08      	pop	{r3, pc}
    244a:	bf00      	nop
    244c:	200000f8 	.word	0x200000f8
    2450:	000023d9 	.word	0x000023d9
    2454:	00003481 	.word	0x00003481

00002458 <ext_irq_register>:
{
    2458:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    245a:	4602      	mov	r2, r0
		if (ext_irqs[i].pin == pin) {
    245c:	4b36      	ldr	r3, [pc, #216]	; (2538 <ext_irq_register+0xe0>)
    245e:	685b      	ldr	r3, [r3, #4]
    2460:	4298      	cmp	r0, r3
    2462:	d026      	beq.n	24b2 <ext_irq_register+0x5a>
    2464:	4b34      	ldr	r3, [pc, #208]	; (2538 <ext_irq_register+0xe0>)
    2466:	68db      	ldr	r3, [r3, #12]
    2468:	4298      	cmp	r0, r3
    246a:	d01e      	beq.n	24aa <ext_irq_register+0x52>
    246c:	4b32      	ldr	r3, [pc, #200]	; (2538 <ext_irq_register+0xe0>)
    246e:	695b      	ldr	r3, [r3, #20]
    2470:	4298      	cmp	r0, r3
    2472:	d01c      	beq.n	24ae <ext_irq_register+0x56>
    2474:	4b30      	ldr	r3, [pc, #192]	; (2538 <ext_irq_register+0xe0>)
    2476:	69db      	ldr	r3, [r3, #28]
    2478:	4283      	cmp	r3, r0
    247a:	bf08      	it	eq
    247c:	2003      	moveq	r0, #3
    247e:	d019      	beq.n	24b4 <ext_irq_register+0x5c>
	if (NULL == cb) {
    2480:	2900      	cmp	r1, #0
    2482:	d03b      	beq.n	24fc <ext_irq_register+0xa4>
			if (NULL == ext_irqs[i].cb) {
    2484:	4b2c      	ldr	r3, [pc, #176]	; (2538 <ext_irq_register+0xe0>)
    2486:	681b      	ldr	r3, [r3, #0]
    2488:	2b00      	cmp	r3, #0
    248a:	d04f      	beq.n	252c <ext_irq_register+0xd4>
    248c:	4b2a      	ldr	r3, [pc, #168]	; (2538 <ext_irq_register+0xe0>)
    248e:	689b      	ldr	r3, [r3, #8]
    2490:	2b00      	cmp	r3, #0
    2492:	d036      	beq.n	2502 <ext_irq_register+0xaa>
    2494:	4b28      	ldr	r3, [pc, #160]	; (2538 <ext_irq_register+0xe0>)
    2496:	691b      	ldr	r3, [r3, #16]
    2498:	2b00      	cmp	r3, #0
    249a:	d041      	beq.n	2520 <ext_irq_register+0xc8>
    249c:	4b26      	ldr	r3, [pc, #152]	; (2538 <ext_irq_register+0xe0>)
    249e:	699b      	ldr	r3, [r3, #24]
    24a0:	2b00      	cmp	r3, #0
    24a2:	d040      	beq.n	2526 <ext_irq_register+0xce>
		return ERR_INVALID_ARG;
    24a4:	f06f 000c 	mvn.w	r0, #12
    24a8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (ext_irqs[i].pin == pin) {
    24aa:	2001      	movs	r0, #1
    24ac:	e002      	b.n	24b4 <ext_irq_register+0x5c>
    24ae:	2002      	movs	r0, #2
    24b0:	e000      	b.n	24b4 <ext_irq_register+0x5c>
    24b2:	2000      	movs	r0, #0
			ext_irqs[i].cb = cb;
    24b4:	4b20      	ldr	r3, [pc, #128]	; (2538 <ext_irq_register+0xe0>)
    24b6:	f843 1030 	str.w	r1, [r3, r0, lsl #3]
	if (NULL == cb) {
    24ba:	b9d1      	cbnz	r1, 24f2 <ext_irq_register+0x9a>
		return _ext_irq_enable(pin, false);
    24bc:	2100      	movs	r1, #0
    24be:	4610      	mov	r0, r2
    24c0:	4b1e      	ldr	r3, [pc, #120]	; (253c <ext_irq_register+0xe4>)
    24c2:	4798      	blx	r3
    24c4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    24c6:	3308      	adds	r3, #8
		for (; (j < EXT_IRQ_AMOUNT) && (i < EXT_IRQ_AMOUNT); j++) {
    24c8:	429e      	cmp	r6, r3
    24ca:	d012      	beq.n	24f2 <ext_irq_register+0x9a>
			if ((ext_irqs[i].pin < ext_irqs[j].pin) && (ext_irqs[j].pin != 0xFFFFFFFF)) {
    24cc:	6859      	ldr	r1, [r3, #4]
    24ce:	6868      	ldr	r0, [r5, #4]
    24d0:	4288      	cmp	r0, r1
    24d2:	d2f8      	bcs.n	24c6 <ext_irq_register+0x6e>
    24d4:	f1b1 3fff 	cmp.w	r1, #4294967295
    24d8:	d0f5      	beq.n	24c6 <ext_irq_register+0x6e>
				struct ext_irq tmp = ext_irqs[j];
    24da:	f8d3 c000 	ldr.w	ip, [r3]
    24de:	468e      	mov	lr, r1
				ext_irqs[j] = ext_irqs[i];
    24e0:	e895 0003 	ldmia.w	r5, {r0, r1}
    24e4:	e883 0003 	stmia.w	r3, {r0, r1}
				ext_irqs[i] = tmp;
    24e8:	f8c7 c000 	str.w	ip, [r7]
    24ec:	f8c7 e004 	str.w	lr, [r7, #4]
    24f0:	e7e9      	b.n	24c6 <ext_irq_register+0x6e>
	return _ext_irq_enable(pin, true);
    24f2:	2101      	movs	r1, #1
    24f4:	4610      	mov	r0, r2
    24f6:	4b11      	ldr	r3, [pc, #68]	; (253c <ext_irq_register+0xe4>)
    24f8:	4798      	blx	r3
    24fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			return ERR_INVALID_ARG;
    24fc:	f06f 000c 	mvn.w	r0, #12
    2500:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
    2502:	2001      	movs	r0, #1
			if (NULL == ext_irqs[i].cb) {
    2504:	4604      	mov	r4, r0
				ext_irqs[i].cb  = cb;
    2506:	4b0c      	ldr	r3, [pc, #48]	; (2538 <ext_irq_register+0xe0>)
    2508:	f843 1034 	str.w	r1, [r3, r4, lsl #3]
				ext_irqs[i].pin = pin;
    250c:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
    2510:	605a      	str	r2, [r3, #4]
				ext_irqs[i] = tmp;
    2512:	4e09      	ldr	r6, [pc, #36]	; (2538 <ext_irq_register+0xe0>)
    2514:	eb06 07c0 	add.w	r7, r6, r0, lsl #3
    2518:	4633      	mov	r3, r6
    251a:	3620      	adds	r6, #32
			if ((ext_irqs[i].pin < ext_irqs[j].pin) && (ext_irqs[j].pin != 0xFFFFFFFF)) {
    251c:	463d      	mov	r5, r7
    251e:	e7d5      	b.n	24cc <ext_irq_register+0x74>
		for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
    2520:	2002      	movs	r0, #2
			if (NULL == ext_irqs[i].cb) {
    2522:	4604      	mov	r4, r0
    2524:	e7ef      	b.n	2506 <ext_irq_register+0xae>
		for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
    2526:	2003      	movs	r0, #3
			if (NULL == ext_irqs[i].cb) {
    2528:	4604      	mov	r4, r0
    252a:	e7ec      	b.n	2506 <ext_irq_register+0xae>
				ext_irqs[i].cb  = cb;
    252c:	4b02      	ldr	r3, [pc, #8]	; (2538 <ext_irq_register+0xe0>)
    252e:	6019      	str	r1, [r3, #0]
				ext_irqs[i].pin = pin;
    2530:	605a      	str	r2, [r3, #4]
    2532:	2000      	movs	r0, #0
    2534:	e7ed      	b.n	2512 <ext_irq_register+0xba>
    2536:	bf00      	nop
    2538:	200000f8 	.word	0x200000f8
    253c:	0000356d 	.word	0x0000356d

00002540 <io_write>:

/**
 * \brief I/O write interface
 */
int32_t io_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
    2540:	b570      	push	{r4, r5, r6, lr}
    2542:	460d      	mov	r5, r1
    2544:	4616      	mov	r6, r2
	ASSERT(io_descr && buf);
    2546:	4604      	mov	r4, r0
    2548:	b160      	cbz	r0, 2564 <io_write+0x24>
    254a:	1c08      	adds	r0, r1, #0
    254c:	bf18      	it	ne
    254e:	2001      	movne	r0, #1
    2550:	223e      	movs	r2, #62	; 0x3e
    2552:	4905      	ldr	r1, [pc, #20]	; (2568 <io_write+0x28>)
    2554:	4b05      	ldr	r3, [pc, #20]	; (256c <io_write+0x2c>)
    2556:	4798      	blx	r3
	return io_descr->write(io_descr, buf, length);
    2558:	6823      	ldr	r3, [r4, #0]
    255a:	4632      	mov	r2, r6
    255c:	4629      	mov	r1, r5
    255e:	4620      	mov	r0, r4
    2560:	4798      	blx	r3
}
    2562:	bd70      	pop	{r4, r5, r6, pc}
    2564:	2000      	movs	r0, #0
    2566:	e7f3      	b.n	2550 <io_write+0x10>
    2568:	000097cc 	.word	0x000097cc
    256c:	00003205 	.word	0x00003205

00002570 <io_read>:

/**
 * \brief I/O read interface
 */
int32_t io_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
    2570:	b570      	push	{r4, r5, r6, lr}
    2572:	460d      	mov	r5, r1
    2574:	4616      	mov	r6, r2
	ASSERT(io_descr && buf);
    2576:	4604      	mov	r4, r0
    2578:	b160      	cbz	r0, 2594 <io_read+0x24>
    257a:	1c08      	adds	r0, r1, #0
    257c:	bf18      	it	ne
    257e:	2001      	movne	r0, #1
    2580:	2247      	movs	r2, #71	; 0x47
    2582:	4905      	ldr	r1, [pc, #20]	; (2598 <io_read+0x28>)
    2584:	4b05      	ldr	r3, [pc, #20]	; (259c <io_read+0x2c>)
    2586:	4798      	blx	r3
	return io_descr->read(io_descr, buf, length);
    2588:	6863      	ldr	r3, [r4, #4]
    258a:	4632      	mov	r2, r6
    258c:	4629      	mov	r1, r5
    258e:	4620      	mov	r0, r4
    2590:	4798      	blx	r3
}
    2592:	bd70      	pop	{r4, r5, r6, pc}
    2594:	2000      	movs	r0, #0
    2596:	e7f3      	b.n	2580 <io_read+0x10>
    2598:	000097cc 	.word	0x000097cc
    259c:	00003205 	.word	0x00003205

000025a0 <mci_sync_init>:

/**
 *  \brief Initialize MCI low level driver.
 */
int32_t mci_sync_init(struct mci_sync_desc *mci, void *hw)
{
    25a0:	b538      	push	{r3, r4, r5, lr}
    25a2:	460c      	mov	r4, r1
	ASSERT(mci && hw);
    25a4:	4605      	mov	r5, r0
    25a6:	b158      	cbz	r0, 25c0 <mci_sync_init+0x20>
    25a8:	1c08      	adds	r0, r1, #0
    25aa:	bf18      	it	ne
    25ac:	2001      	movne	r0, #1
    25ae:	223b      	movs	r2, #59	; 0x3b
    25b0:	4904      	ldr	r1, [pc, #16]	; (25c4 <mci_sync_init+0x24>)
    25b2:	4b05      	ldr	r3, [pc, #20]	; (25c8 <mci_sync_init+0x28>)
    25b4:	4798      	blx	r3
	return _mci_sync_init(&mci->device, hw);
    25b6:	4621      	mov	r1, r4
    25b8:	4628      	mov	r0, r5
    25ba:	4b04      	ldr	r3, [pc, #16]	; (25cc <mci_sync_init+0x2c>)
    25bc:	4798      	blx	r3
}
    25be:	bd38      	pop	{r3, r4, r5, pc}
    25c0:	2000      	movs	r0, #0
    25c2:	e7f4      	b.n	25ae <mci_sync_init+0xe>
    25c4:	000097e0 	.word	0x000097e0
    25c8:	00003205 	.word	0x00003205
    25cc:	000039ed 	.word	0x000039ed

000025d0 <mci_sync_select_device>:
/**
 *  \brief Select a device and initialize it
 */
int32_t mci_sync_select_device(struct mci_sync_desc *mci, uint8_t slot, uint32_t clock, uint8_t bus_width,
                               bool high_speed)
{
    25d0:	b5f0      	push	{r4, r5, r6, r7, lr}
    25d2:	b083      	sub	sp, #12
    25d4:	460d      	mov	r5, r1
    25d6:	4616      	mov	r6, r2
    25d8:	461f      	mov	r7, r3
	ASSERT(mci);
    25da:	4604      	mov	r4, r0
    25dc:	224e      	movs	r2, #78	; 0x4e
    25de:	4908      	ldr	r1, [pc, #32]	; (2600 <mci_sync_select_device+0x30>)
    25e0:	3000      	adds	r0, #0
    25e2:	bf18      	it	ne
    25e4:	2001      	movne	r0, #1
    25e6:	4b07      	ldr	r3, [pc, #28]	; (2604 <mci_sync_select_device+0x34>)
    25e8:	4798      	blx	r3
	return _mci_sync_select_device(&mci->device, slot, clock, bus_width, high_speed);
    25ea:	f89d 3020 	ldrb.w	r3, [sp, #32]
    25ee:	9300      	str	r3, [sp, #0]
    25f0:	463b      	mov	r3, r7
    25f2:	4632      	mov	r2, r6
    25f4:	4629      	mov	r1, r5
    25f6:	4620      	mov	r0, r4
    25f8:	4c03      	ldr	r4, [pc, #12]	; (2608 <mci_sync_select_device+0x38>)
    25fa:	47a0      	blx	r4
}
    25fc:	b003      	add	sp, #12
    25fe:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2600:	000097e0 	.word	0x000097e0
    2604:	00003205 	.word	0x00003205
    2608:	00003a55 	.word	0x00003a55

0000260c <mci_sync_deselect_device>:

/**
 *  \brief Deselect a device by an assigned slot
 */
int32_t mci_sync_deselect_device(struct mci_sync_desc *mci, uint8_t slot)
{
    260c:	b538      	push	{r3, r4, r5, lr}
    260e:	460d      	mov	r5, r1
	ASSERT(mci);
    2610:	4604      	mov	r4, r0
    2612:	2257      	movs	r2, #87	; 0x57
    2614:	4905      	ldr	r1, [pc, #20]	; (262c <mci_sync_deselect_device+0x20>)
    2616:	3000      	adds	r0, #0
    2618:	bf18      	it	ne
    261a:	2001      	movne	r0, #1
    261c:	4b04      	ldr	r3, [pc, #16]	; (2630 <mci_sync_deselect_device+0x24>)
    261e:	4798      	blx	r3
	return _mci_sync_deselect_device(&mci->device, slot);
    2620:	4629      	mov	r1, r5
    2622:	4620      	mov	r0, r4
    2624:	4b03      	ldr	r3, [pc, #12]	; (2634 <mci_sync_deselect_device+0x28>)
    2626:	4798      	blx	r3
}
    2628:	bd38      	pop	{r3, r4, r5, pc}
    262a:	bf00      	nop
    262c:	000097e0 	.word	0x000097e0
    2630:	00003205 	.word	0x00003205
    2634:	00003b69 	.word	0x00003b69

00002638 <mci_sync_get_bus_width>:

/**
 *  \brief Get the maximum bus width of a device by a selected slot
 */
uint8_t mci_sync_get_bus_width(struct mci_sync_desc *mci, uint8_t slot)
{
    2638:	b538      	push	{r3, r4, r5, lr}
    263a:	460d      	mov	r5, r1
	ASSERT(mci);
    263c:	4604      	mov	r4, r0
    263e:	2260      	movs	r2, #96	; 0x60
    2640:	4905      	ldr	r1, [pc, #20]	; (2658 <mci_sync_get_bus_width+0x20>)
    2642:	3000      	adds	r0, #0
    2644:	bf18      	it	ne
    2646:	2001      	movne	r0, #1
    2648:	4b04      	ldr	r3, [pc, #16]	; (265c <mci_sync_get_bus_width+0x24>)
    264a:	4798      	blx	r3
	return _mci_sync_get_bus_width(&mci->device, slot);
    264c:	4629      	mov	r1, r5
    264e:	4620      	mov	r0, r4
    2650:	4b03      	ldr	r3, [pc, #12]	; (2660 <mci_sync_get_bus_width+0x28>)
    2652:	4798      	blx	r3
}
    2654:	bd38      	pop	{r3, r4, r5, pc}
    2656:	bf00      	nop
    2658:	000097e0 	.word	0x000097e0
    265c:	00003205 	.word	0x00003205
    2660:	00003b6d 	.word	0x00003b6d

00002664 <mci_sync_is_high_speed_capable>:
/**
 *  \brief Get the high speed capability of the device.
 *
 */
bool mci_sync_is_high_speed_capable(struct mci_sync_desc *mci)
{
    2664:	b510      	push	{r4, lr}
	ASSERT(mci);
    2666:	4604      	mov	r4, r0
    2668:	226a      	movs	r2, #106	; 0x6a
    266a:	4905      	ldr	r1, [pc, #20]	; (2680 <mci_sync_is_high_speed_capable+0x1c>)
    266c:	3000      	adds	r0, #0
    266e:	bf18      	it	ne
    2670:	2001      	movne	r0, #1
    2672:	4b04      	ldr	r3, [pc, #16]	; (2684 <mci_sync_is_high_speed_capable+0x20>)
    2674:	4798      	blx	r3
	return _mci_sync_is_high_speed_capable(&mci->device);
    2676:	4620      	mov	r0, r4
    2678:	4b03      	ldr	r3, [pc, #12]	; (2688 <mci_sync_is_high_speed_capable+0x24>)
    267a:	4798      	blx	r3
}
    267c:	bd10      	pop	{r4, pc}
    267e:	bf00      	nop
    2680:	000097e0 	.word	0x000097e0
    2684:	00003205 	.word	0x00003205
    2688:	00003b77 	.word	0x00003b77

0000268c <mci_sync_send_clock>:

/**
 *  \brief Send 74 clock cycles on the line.
 */
void mci_sync_send_clock(struct mci_sync_desc *mci)
{
    268c:	b510      	push	{r4, lr}
	ASSERT(mci);
    268e:	4604      	mov	r4, r0
    2690:	2273      	movs	r2, #115	; 0x73
    2692:	4905      	ldr	r1, [pc, #20]	; (26a8 <mci_sync_send_clock+0x1c>)
    2694:	3000      	adds	r0, #0
    2696:	bf18      	it	ne
    2698:	2001      	movne	r0, #1
    269a:	4b04      	ldr	r3, [pc, #16]	; (26ac <mci_sync_send_clock+0x20>)
    269c:	4798      	blx	r3
	_mci_sync_send_clock(&mci->device);
    269e:	4620      	mov	r0, r4
    26a0:	4b03      	ldr	r3, [pc, #12]	; (26b0 <mci_sync_send_clock+0x24>)
    26a2:	4798      	blx	r3
    26a4:	bd10      	pop	{r4, pc}
    26a6:	bf00      	nop
    26a8:	000097e0 	.word	0x000097e0
    26ac:	00003205 	.word	0x00003205
    26b0:	00003b81 	.word	0x00003b81

000026b4 <mci_sync_send_cmd>:

/**
 *  \brief Send a command on the selected slot
 */
bool mci_sync_send_cmd(struct mci_sync_desc *mci, uint32_t cmd, uint32_t arg)
{
    26b4:	b570      	push	{r4, r5, r6, lr}
    26b6:	460d      	mov	r5, r1
    26b8:	4616      	mov	r6, r2
	ASSERT(mci);
    26ba:	4604      	mov	r4, r0
    26bc:	227c      	movs	r2, #124	; 0x7c
    26be:	4906      	ldr	r1, [pc, #24]	; (26d8 <mci_sync_send_cmd+0x24>)
    26c0:	3000      	adds	r0, #0
    26c2:	bf18      	it	ne
    26c4:	2001      	movne	r0, #1
    26c6:	4b05      	ldr	r3, [pc, #20]	; (26dc <mci_sync_send_cmd+0x28>)
    26c8:	4798      	blx	r3
	return _mci_sync_send_cmd(&mci->device, cmd, arg);
    26ca:	4632      	mov	r2, r6
    26cc:	4629      	mov	r1, r5
    26ce:	4620      	mov	r0, r4
    26d0:	4b03      	ldr	r3, [pc, #12]	; (26e0 <mci_sync_send_cmd+0x2c>)
    26d2:	4798      	blx	r3
}
    26d4:	bd70      	pop	{r4, r5, r6, pc}
    26d6:	bf00      	nop
    26d8:	000097e0 	.word	0x000097e0
    26dc:	00003205 	.word	0x00003205
    26e0:	00003bc1 	.word	0x00003bc1

000026e4 <mci_sync_get_response>:

/**
 *  \brief Get 32 bits response of the last command.
 */
uint32_t mci_sync_get_response(struct mci_sync_desc *mci)
{
    26e4:	b510      	push	{r4, lr}
	ASSERT(mci);
    26e6:	4604      	mov	r4, r0
    26e8:	2285      	movs	r2, #133	; 0x85
    26ea:	4905      	ldr	r1, [pc, #20]	; (2700 <mci_sync_get_response+0x1c>)
    26ec:	3000      	adds	r0, #0
    26ee:	bf18      	it	ne
    26f0:	2001      	movne	r0, #1
    26f2:	4b04      	ldr	r3, [pc, #16]	; (2704 <mci_sync_get_response+0x20>)
    26f4:	4798      	blx	r3
	return _mci_sync_get_response(&mci->device);
    26f6:	4620      	mov	r0, r4
    26f8:	4b03      	ldr	r3, [pc, #12]	; (2708 <mci_sync_get_response+0x24>)
    26fa:	4798      	blx	r3
}
    26fc:	bd10      	pop	{r4, pc}
    26fe:	bf00      	nop
    2700:	000097e0 	.word	0x000097e0
    2704:	00003205 	.word	0x00003205
    2708:	00003c15 	.word	0x00003c15

0000270c <mci_sync_get_response_128>:

/**
 *  \brief Get 128 bits response of the last command.
 */
void mci_sync_get_response_128(struct mci_sync_desc *mci, uint8_t *response)
{
    270c:	b538      	push	{r3, r4, r5, lr}
    270e:	460c      	mov	r4, r1
	ASSERT(mci && response);
    2710:	4605      	mov	r5, r0
    2712:	b158      	cbz	r0, 272c <mci_sync_get_response_128+0x20>
    2714:	1c08      	adds	r0, r1, #0
    2716:	bf18      	it	ne
    2718:	2001      	movne	r0, #1
    271a:	228e      	movs	r2, #142	; 0x8e
    271c:	4904      	ldr	r1, [pc, #16]	; (2730 <mci_sync_get_response_128+0x24>)
    271e:	4b05      	ldr	r3, [pc, #20]	; (2734 <mci_sync_get_response_128+0x28>)
    2720:	4798      	blx	r3
	_mci_sync_get_response_128(&mci->device, response);
    2722:	4621      	mov	r1, r4
    2724:	4628      	mov	r0, r5
    2726:	4b04      	ldr	r3, [pc, #16]	; (2738 <mci_sync_get_response_128+0x2c>)
    2728:	4798      	blx	r3
    272a:	bd38      	pop	{r3, r4, r5, pc}
    272c:	2000      	movs	r0, #0
    272e:	e7f4      	b.n	271a <mci_sync_get_response_128+0xe>
    2730:	000097e0 	.word	0x000097e0
    2734:	00003205 	.word	0x00003205
    2738:	00003c41 	.word	0x00003c41

0000273c <mci_sync_adtc_start>:
 *         An ADTC (Addressed Data Transfer Commands)
 *         command is used for read/write access.
 */
bool mci_sync_adtc_start(struct mci_sync_desc *mci, uint32_t cmd, uint32_t arg, uint16_t block_size, uint16_t nb_block,
                         bool access_block)
{
    273c:	b5f0      	push	{r4, r5, r6, r7, lr}
    273e:	b083      	sub	sp, #12
    2740:	460d      	mov	r5, r1
    2742:	4616      	mov	r6, r2
    2744:	461f      	mov	r7, r3
	ASSERT(mci);
    2746:	4604      	mov	r4, r0
    2748:	229a      	movs	r2, #154	; 0x9a
    274a:	490a      	ldr	r1, [pc, #40]	; (2774 <mci_sync_adtc_start+0x38>)
    274c:	3000      	adds	r0, #0
    274e:	bf18      	it	ne
    2750:	2001      	movne	r0, #1
    2752:	4b09      	ldr	r3, [pc, #36]	; (2778 <mci_sync_adtc_start+0x3c>)
    2754:	4798      	blx	r3
	return _mci_sync_adtc_start(&mci->device, cmd, arg, block_size, nb_block, access_block);
    2756:	f89d 3024 	ldrb.w	r3, [sp, #36]	; 0x24
    275a:	9301      	str	r3, [sp, #4]
    275c:	f8bd 3020 	ldrh.w	r3, [sp, #32]
    2760:	9300      	str	r3, [sp, #0]
    2762:	463b      	mov	r3, r7
    2764:	4632      	mov	r2, r6
    2766:	4629      	mov	r1, r5
    2768:	4620      	mov	r0, r4
    276a:	4c04      	ldr	r4, [pc, #16]	; (277c <mci_sync_adtc_start+0x40>)
    276c:	47a0      	blx	r4
}
    276e:	b003      	add	sp, #12
    2770:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2772:	bf00      	nop
    2774:	000097e0 	.word	0x000097e0
    2778:	00003205 	.word	0x00003205
    277c:	00003ca5 	.word	0x00003ca5

00002780 <mci_sync_start_read_blocks>:
/**
 *  \brief Start a read blocks transfer on the line
 *  Note: The driver will use the DMA available to speed up the transfer.
 */
bool mci_sync_start_read_blocks(struct mci_sync_desc *mci, void *dst, uint16_t nb_block)
{
    2780:	b570      	push	{r4, r5, r6, lr}
    2782:	460c      	mov	r4, r1
    2784:	4616      	mov	r6, r2
	ASSERT(mci && dst);
    2786:	4605      	mov	r5, r0
    2788:	b160      	cbz	r0, 27a4 <mci_sync_start_read_blocks+0x24>
    278a:	1c08      	adds	r0, r1, #0
    278c:	bf18      	it	ne
    278e:	2001      	movne	r0, #1
    2790:	22bf      	movs	r2, #191	; 0xbf
    2792:	4905      	ldr	r1, [pc, #20]	; (27a8 <mci_sync_start_read_blocks+0x28>)
    2794:	4b05      	ldr	r3, [pc, #20]	; (27ac <mci_sync_start_read_blocks+0x2c>)
    2796:	4798      	blx	r3
	return _mci_sync_start_read_blocks(&mci->device, dst, nb_block);
    2798:	4632      	mov	r2, r6
    279a:	4621      	mov	r1, r4
    279c:	4628      	mov	r0, r5
    279e:	4b04      	ldr	r3, [pc, #16]	; (27b0 <mci_sync_start_read_blocks+0x30>)
    27a0:	4798      	blx	r3
}
    27a2:	bd70      	pop	{r4, r5, r6, pc}
    27a4:	2000      	movs	r0, #0
    27a6:	e7f3      	b.n	2790 <mci_sync_start_read_blocks+0x10>
    27a8:	000097e0 	.word	0x000097e0
    27ac:	00003205 	.word	0x00003205
    27b0:	00003f29 	.word	0x00003f29

000027b4 <mci_sync_start_write_blocks>:

/**
 *  \brief Start a write blocks transfer on the line
 */
bool mci_sync_start_write_blocks(struct mci_sync_desc *mci, const void *src, uint16_t nb_block)
{
    27b4:	b570      	push	{r4, r5, r6, lr}
    27b6:	460c      	mov	r4, r1
    27b8:	4616      	mov	r6, r2
	ASSERT(mci && src);
    27ba:	4605      	mov	r5, r0
    27bc:	b160      	cbz	r0, 27d8 <mci_sync_start_write_blocks+0x24>
    27be:	1c08      	adds	r0, r1, #0
    27c0:	bf18      	it	ne
    27c2:	2001      	movne	r0, #1
    27c4:	22c8      	movs	r2, #200	; 0xc8
    27c6:	4905      	ldr	r1, [pc, #20]	; (27dc <mci_sync_start_write_blocks+0x28>)
    27c8:	4b05      	ldr	r3, [pc, #20]	; (27e0 <mci_sync_start_write_blocks+0x2c>)
    27ca:	4798      	blx	r3
	return _mci_sync_start_write_blocks(&mci->device, src, nb_block);
    27cc:	4632      	mov	r2, r6
    27ce:	4621      	mov	r1, r4
    27d0:	4628      	mov	r0, r5
    27d2:	4b04      	ldr	r3, [pc, #16]	; (27e4 <mci_sync_start_write_blocks+0x30>)
    27d4:	4798      	blx	r3
}
    27d6:	bd70      	pop	{r4, r5, r6, pc}
    27d8:	2000      	movs	r0, #0
    27da:	e7f3      	b.n	27c4 <mci_sync_start_write_blocks+0x10>
    27dc:	000097e0 	.word	0x000097e0
    27e0:	00003205 	.word	0x00003205
    27e4:	00003fad 	.word	0x00003fad

000027e8 <mci_sync_wait_end_of_read_blocks>:

/**
 *  \brief Wait the end of transfer initiated by mci_start_read_blocks()
 */
bool mci_sync_wait_end_of_read_blocks(struct mci_sync_desc *mci)
{
    27e8:	b510      	push	{r4, lr}
	ASSERT(mci);
    27ea:	4604      	mov	r4, r0
    27ec:	22d1      	movs	r2, #209	; 0xd1
    27ee:	4905      	ldr	r1, [pc, #20]	; (2804 <mci_sync_wait_end_of_read_blocks+0x1c>)
    27f0:	3000      	adds	r0, #0
    27f2:	bf18      	it	ne
    27f4:	2001      	movne	r0, #1
    27f6:	4b04      	ldr	r3, [pc, #16]	; (2808 <mci_sync_wait_end_of_read_blocks+0x20>)
    27f8:	4798      	blx	r3
	return _mci_sync_wait_end_of_read_blocks(&mci->device);
    27fa:	4620      	mov	r0, r4
    27fc:	4b03      	ldr	r3, [pc, #12]	; (280c <mci_sync_wait_end_of_read_blocks+0x24>)
    27fe:	4798      	blx	r3
}
    2800:	bd10      	pop	{r4, pc}
    2802:	bf00      	nop
    2804:	000097e0 	.word	0x000097e0
    2808:	00003205 	.word	0x00003205
    280c:	00004031 	.word	0x00004031

00002810 <mci_sync_wait_end_of_write_blocks>:

/**
 *  \brief Wait the end of transfer initiated by mci_start_write_blocks()
 */
bool mci_sync_wait_end_of_write_blocks(struct mci_sync_desc *mci)
{
    2810:	b510      	push	{r4, lr}
	ASSERT(mci);
    2812:	4604      	mov	r4, r0
    2814:	22da      	movs	r2, #218	; 0xda
    2816:	4905      	ldr	r1, [pc, #20]	; (282c <mci_sync_wait_end_of_write_blocks+0x1c>)
    2818:	3000      	adds	r0, #0
    281a:	bf18      	it	ne
    281c:	2001      	movne	r0, #1
    281e:	4b04      	ldr	r3, [pc, #16]	; (2830 <mci_sync_wait_end_of_write_blocks+0x20>)
    2820:	4798      	blx	r3
	return _mci_sync_wait_end_of_write_blocks(&mci->device);
    2822:	4620      	mov	r0, r4
    2824:	4b03      	ldr	r3, [pc, #12]	; (2834 <mci_sync_wait_end_of_write_blocks+0x24>)
    2826:	4798      	blx	r3
}
    2828:	bd10      	pop	{r4, pc}
    282a:	bf00      	nop
    282c:	000097e0 	.word	0x000097e0
    2830:	00003205 	.word	0x00003205
    2834:	00004059 	.word	0x00004059

00002838 <pwm_period_expired>:

/**
 * \internal Process interrupts caused by period experied
 */
static void pwm_period_expired(struct _pwm_device *device)
{
    2838:	b508      	push	{r3, lr}
	struct pwm_descriptor *const descr = CONTAINER_OF(device, struct pwm_descriptor, device);

	if (descr->pwm_cb.period) {
    283a:	6943      	ldr	r3, [r0, #20]
    283c:	b103      	cbz	r3, 2840 <pwm_period_expired+0x8>
		descr->pwm_cb.period(descr);
    283e:	4798      	blx	r3
    2840:	bd08      	pop	{r3, pc}

00002842 <pwm_detect_fault>:

/**
 * \internal Process interrupts caused by pwm fault
 */
static void pwm_detect_fault(struct _pwm_device *device)
{
    2842:	b508      	push	{r3, lr}
	struct pwm_descriptor *const descr = CONTAINER_OF(device, struct pwm_descriptor, device);

	if (descr->pwm_cb.error) {
    2844:	6983      	ldr	r3, [r0, #24]
    2846:	b103      	cbz	r3, 284a <pwm_detect_fault+0x8>
		descr->pwm_cb.error(descr);
    2848:	4798      	blx	r3
    284a:	bd08      	pop	{r3, pc}

0000284c <pwm_init>:
{
    284c:	b538      	push	{r3, r4, r5, lr}
    284e:	460d      	mov	r5, r1
	ASSERT(descr && hw);
    2850:	4604      	mov	r4, r0
    2852:	b180      	cbz	r0, 2876 <pwm_init+0x2a>
    2854:	1c08      	adds	r0, r1, #0
    2856:	bf18      	it	ne
    2858:	2001      	movne	r0, #1
    285a:	223d      	movs	r2, #61	; 0x3d
    285c:	4907      	ldr	r1, [pc, #28]	; (287c <pwm_init+0x30>)
    285e:	4b08      	ldr	r3, [pc, #32]	; (2880 <pwm_init+0x34>)
    2860:	4798      	blx	r3
	_pwm_init(&descr->device, hw);
    2862:	4629      	mov	r1, r5
    2864:	4620      	mov	r0, r4
    2866:	4b07      	ldr	r3, [pc, #28]	; (2884 <pwm_init+0x38>)
    2868:	4798      	blx	r3
	descr->device.callback.pwm_period_cb = pwm_period_expired;
    286a:	4b07      	ldr	r3, [pc, #28]	; (2888 <pwm_init+0x3c>)
    286c:	6023      	str	r3, [r4, #0]
	descr->device.callback.pwm_error_cb  = pwm_detect_fault;
    286e:	4b07      	ldr	r3, [pc, #28]	; (288c <pwm_init+0x40>)
    2870:	6063      	str	r3, [r4, #4]
}
    2872:	2000      	movs	r0, #0
    2874:	bd38      	pop	{r3, r4, r5, pc}
    2876:	2000      	movs	r0, #0
    2878:	e7ef      	b.n	285a <pwm_init+0xe>
    287a:	bf00      	nop
    287c:	000097fc 	.word	0x000097fc
    2880:	00003205 	.word	0x00003205
    2884:	000045ed 	.word	0x000045ed
    2888:	00002839 	.word	0x00002839
    288c:	00002843 	.word	0x00002843

00002890 <pwm_enable>:
{
    2890:	b510      	push	{r4, lr}
	ASSERT(descr);
    2892:	4604      	mov	r4, r0
    2894:	2254      	movs	r2, #84	; 0x54
    2896:	4909      	ldr	r1, [pc, #36]	; (28bc <pwm_enable+0x2c>)
    2898:	3000      	adds	r0, #0
    289a:	bf18      	it	ne
    289c:	2001      	movne	r0, #1
    289e:	4b08      	ldr	r3, [pc, #32]	; (28c0 <pwm_enable+0x30>)
    28a0:	4798      	blx	r3
	if (_pwm_is_enabled(&descr->device)) {
    28a2:	4620      	mov	r0, r4
    28a4:	4b07      	ldr	r3, [pc, #28]	; (28c4 <pwm_enable+0x34>)
    28a6:	4798      	blx	r3
    28a8:	b920      	cbnz	r0, 28b4 <pwm_enable+0x24>
	_pwm_enable(&descr->device);
    28aa:	4620      	mov	r0, r4
    28ac:	4b06      	ldr	r3, [pc, #24]	; (28c8 <pwm_enable+0x38>)
    28ae:	4798      	blx	r3
	return ERR_NONE;
    28b0:	2000      	movs	r0, #0
    28b2:	bd10      	pop	{r4, pc}
		return ERR_DENIED;
    28b4:	f06f 0010 	mvn.w	r0, #16
}
    28b8:	bd10      	pop	{r4, pc}
    28ba:	bf00      	nop
    28bc:	000097fc 	.word	0x000097fc
    28c0:	00003205 	.word	0x00003205
    28c4:	00004781 	.word	0x00004781
    28c8:	00004719 	.word	0x00004719

000028cc <pwm_disable>:
{
    28cc:	b510      	push	{r4, lr}
	ASSERT(descr);
    28ce:	4604      	mov	r4, r0
    28d0:	2262      	movs	r2, #98	; 0x62
    28d2:	4909      	ldr	r1, [pc, #36]	; (28f8 <pwm_disable+0x2c>)
    28d4:	3000      	adds	r0, #0
    28d6:	bf18      	it	ne
    28d8:	2001      	movne	r0, #1
    28da:	4b08      	ldr	r3, [pc, #32]	; (28fc <pwm_disable+0x30>)
    28dc:	4798      	blx	r3
	if (!_pwm_is_enabled(&descr->device)) {
    28de:	4620      	mov	r0, r4
    28e0:	4b07      	ldr	r3, [pc, #28]	; (2900 <pwm_disable+0x34>)
    28e2:	4798      	blx	r3
    28e4:	b120      	cbz	r0, 28f0 <pwm_disable+0x24>
	_pwm_disable(&descr->device);
    28e6:	4620      	mov	r0, r4
    28e8:	4b06      	ldr	r3, [pc, #24]	; (2904 <pwm_disable+0x38>)
    28ea:	4798      	blx	r3
	return ERR_NONE;
    28ec:	2000      	movs	r0, #0
    28ee:	bd10      	pop	{r4, pc}
		return ERR_DENIED;
    28f0:	f06f 0010 	mvn.w	r0, #16
}
    28f4:	bd10      	pop	{r4, pc}
    28f6:	bf00      	nop
    28f8:	000097fc 	.word	0x000097fc
    28fc:	00003205 	.word	0x00003205
    2900:	00004781 	.word	0x00004781
    2904:	0000472d 	.word	0x0000472d

00002908 <pwm_set_parameters>:
{
    2908:	b570      	push	{r4, r5, r6, lr}
    290a:	460d      	mov	r5, r1
    290c:	4616      	mov	r6, r2
	ASSERT(descr);
    290e:	4604      	mov	r4, r0
    2910:	2286      	movs	r2, #134	; 0x86
    2912:	4906      	ldr	r1, [pc, #24]	; (292c <pwm_set_parameters+0x24>)
    2914:	3000      	adds	r0, #0
    2916:	bf18      	it	ne
    2918:	2001      	movne	r0, #1
    291a:	4b05      	ldr	r3, [pc, #20]	; (2930 <pwm_set_parameters+0x28>)
    291c:	4798      	blx	r3
	_pwm_set_param(&descr->device, period, duty_cycle);
    291e:	4632      	mov	r2, r6
    2920:	4629      	mov	r1, r5
    2922:	4620      	mov	r0, r4
    2924:	4b03      	ldr	r3, [pc, #12]	; (2934 <pwm_set_parameters+0x2c>)
    2926:	4798      	blx	r3
}
    2928:	2000      	movs	r0, #0
    292a:	bd70      	pop	{r4, r5, r6, pc}
    292c:	000097fc 	.word	0x000097fc
    2930:	00003205 	.word	0x00003205
    2934:	00004741 	.word	0x00004741

00002938 <spi_s_async_dev_complete>:

	spi->callbacks.rx(spi);
}

static void spi_s_async_dev_complete(struct _spi_s_async_dev *dev, int32_t status)
{
    2938:	b508      	push	{r3, lr}
	struct spi_s_async_descriptor *spi = CONTAINER_OF(dev, struct spi_s_async_descriptor, dev);

	spi->callbacks.complete(spi, status);
    293a:	6a43      	ldr	r3, [r0, #36]	; 0x24
    293c:	4798      	blx	r3
    293e:	bd08      	pop	{r3, pc}

00002940 <spi_s_async_dummy_func>:
 * \brief A dummy function to be called when SPI callbacks are not registered
 * \param[in,out] spi Pointer to the HAL SPI instance.
 * \param[in] param Parameter.
 */
static void spi_s_async_dummy_func(struct spi_s_async_descriptor *spi, uint32_t param)
{
    2940:	4770      	bx	lr
	...

00002944 <_spi_s_async_io_write>:
{
    2944:	b570      	push	{r4, r5, r6, lr}
    2946:	b082      	sub	sp, #8
    2948:	460d      	mov	r5, r1
    294a:	4616      	mov	r6, r2
	ASSERT(io);
    294c:	4604      	mov	r4, r0
    294e:	227f      	movs	r2, #127	; 0x7f
    2950:	4915      	ldr	r1, [pc, #84]	; (29a8 <_spi_s_async_io_write+0x64>)
    2952:	3000      	adds	r0, #0
    2954:	bf18      	it	ne
    2956:	2001      	movne	r0, #1
    2958:	4b14      	ldr	r3, [pc, #80]	; (29ac <_spi_s_async_io_write+0x68>)
    295a:	4798      	blx	r3
	if (size == 0) {
    295c:	b916      	cbnz	r6, 2964 <_spi_s_async_io_write+0x20>
		return ERR_NONE;
    295e:	2000      	movs	r0, #0
}
    2960:	b002      	add	sp, #8
    2962:	bd70      	pop	{r4, r5, r6, pc}
	atomic_enter_critical(&flags);
    2964:	a801      	add	r0, sp, #4
    2966:	4b12      	ldr	r3, [pc, #72]	; (29b0 <_spi_s_async_io_write+0x6c>)
    2968:	4798      	blx	r3
	if (spi->busy) {
    296a:	f894 302d 	ldrb.w	r3, [r4, #45]	; 0x2d
    296e:	f013 0f01 	tst.w	r3, #1
    2972:	d113      	bne.n	299c <_spi_s_async_io_write+0x58>
	spi->busy = 1;
    2974:	f894 302d 	ldrb.w	r3, [r4, #45]	; 0x2d
    2978:	f043 0301 	orr.w	r3, r3, #1
    297c:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
	atomic_leave_critical(&flags);
    2980:	a801      	add	r0, sp, #4
    2982:	4b0c      	ldr	r3, [pc, #48]	; (29b4 <_spi_s_async_io_write+0x70>)
    2984:	4798      	blx	r3
	spi->txbuf  = (uint8_t *)buf;
    2986:	6165      	str	r5, [r4, #20]
	spi->txcnt  = 0;
    2988:	2500      	movs	r5, #0
    298a:	8365      	strh	r5, [r4, #26]
	spi->txsize = size;
    298c:	8326      	strh	r6, [r4, #24]
	_spi_s_async_enable_tx(&spi->dev, true);
    298e:	2101      	movs	r1, #1
    2990:	f1a4 001c 	sub.w	r0, r4, #28
    2994:	4b08      	ldr	r3, [pc, #32]	; (29b8 <_spi_s_async_io_write+0x74>)
    2996:	4798      	blx	r3
	return ERR_NONE;
    2998:	4628      	mov	r0, r5
    299a:	e7e1      	b.n	2960 <_spi_s_async_io_write+0x1c>
		atomic_leave_critical(&flags);
    299c:	a801      	add	r0, sp, #4
    299e:	4b05      	ldr	r3, [pc, #20]	; (29b4 <_spi_s_async_io_write+0x70>)
    29a0:	4798      	blx	r3
		return ERR_BUSY;
    29a2:	f06f 0003 	mvn.w	r0, #3
    29a6:	e7db      	b.n	2960 <_spi_s_async_io_write+0x1c>
    29a8:	00009814 	.word	0x00009814
    29ac:	00003205 	.word	0x00003205
    29b0:	00002221 	.word	0x00002221
    29b4:	0000222f 	.word	0x0000222f
    29b8:	00004409 	.word	0x00004409

000029bc <_spi_s_async_io_read>:
{
    29bc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    29c0:	b083      	sub	sp, #12
    29c2:	460c      	mov	r4, r1
    29c4:	4615      	mov	r5, r2
	ASSERT(io);
    29c6:	4607      	mov	r7, r0
    29c8:	22ae      	movs	r2, #174	; 0xae
    29ca:	4920      	ldr	r1, [pc, #128]	; (2a4c <_spi_s_async_io_read+0x90>)
    29cc:	3000      	adds	r0, #0
    29ce:	bf18      	it	ne
    29d0:	2001      	movne	r0, #1
    29d2:	4b1f      	ldr	r3, [pc, #124]	; (2a50 <_spi_s_async_io_read+0x94>)
    29d4:	4798      	blx	r3
	if (size == 0) {
    29d6:	b91d      	cbnz	r5, 29e0 <_spi_s_async_io_read+0x24>
		return 0;
    29d8:	2000      	movs	r0, #0
}
    29da:	b003      	add	sp, #12
    29dc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	n_bytes = ringbuffer_num(&spi->rx_rb);
    29e0:	f107 061c 	add.w	r6, r7, #28
    29e4:	4630      	mov	r0, r6
    29e6:	4b1b      	ldr	r3, [pc, #108]	; (2a54 <_spi_s_async_io_read+0x98>)
    29e8:	4798      	blx	r3
	if (n_bytes == 0) {
    29ea:	4603      	mov	r3, r0
    29ec:	b358      	cbz	r0, 2a46 <_spi_s_async_io_read+0x8a>
		switch (spi->dev.char_size) {
    29ee:	f817 2c18 	ldrb.w	r2, [r7, #-24]
    29f2:	2a02      	cmp	r2, #2
			n <<= 1;
    29f4:	bf06      	itte	eq
    29f6:	0068      	lsleq	r0, r5, #1
    29f8:	b280      	uxtheq	r0, r0
		uint16_t n = size;
    29fa:	4628      	movne	r0, r5
    29fc:	4298      	cmp	r0, r3
    29fe:	bf28      	it	cs
    2a00:	4618      	movcs	r0, r3
    2a02:	4605      	mov	r5, r0
	if (p == NULL) {
    2a04:	b194      	cbz	r4, 2a2c <_spi_s_async_io_read+0x70>
		for (i = 0; i < n_bytes; i++) {
    2a06:	b150      	cbz	r0, 2a1e <_spi_s_async_io_read+0x62>
    2a08:	eb04 0900 	add.w	r9, r4, r0
    2a0c:	4621      	mov	r1, r4
			ringbuffer_get(&spi->rx_rb, p++);
    2a0e:	f8df 8048 	ldr.w	r8, [pc, #72]	; 2a58 <_spi_s_async_io_read+0x9c>
    2a12:	1c4c      	adds	r4, r1, #1
    2a14:	4630      	mov	r0, r6
    2a16:	47c0      	blx	r8
    2a18:	4621      	mov	r1, r4
		for (i = 0; i < n_bytes; i++) {
    2a1a:	454c      	cmp	r4, r9
    2a1c:	d1f9      	bne.n	2a12 <_spi_s_async_io_read+0x56>
	switch (spi->dev.char_size) {
    2a1e:	f817 3c18 	ldrb.w	r3, [r7, #-24]
    2a22:	2b02      	cmp	r3, #2
		return (int32_t)(n_bytes >> 1);
    2a24:	bf0c      	ite	eq
    2a26:	0868      	lsreq	r0, r5, #1
		return (int32_t)n_bytes;
    2a28:	4628      	movne	r0, r5
    2a2a:	e7d6      	b.n	29da <_spi_s_async_io_read+0x1e>
		for (i = 0; i < n_bytes; i++) {
    2a2c:	2800      	cmp	r0, #0
    2a2e:	d0f6      	beq.n	2a1e <_spi_s_async_io_read+0x62>
    2a30:	2400      	movs	r4, #0
			ringbuffer_get(&spi->rx_rb, &tmp);
    2a32:	f8df 8024 	ldr.w	r8, [pc, #36]	; 2a58 <_spi_s_async_io_read+0x9c>
    2a36:	f10d 0107 	add.w	r1, sp, #7
    2a3a:	4630      	mov	r0, r6
    2a3c:	47c0      	blx	r8
		for (i = 0; i < n_bytes; i++) {
    2a3e:	3401      	adds	r4, #1
    2a40:	42a5      	cmp	r5, r4
    2a42:	d1f8      	bne.n	2a36 <_spi_s_async_io_read+0x7a>
    2a44:	e7eb      	b.n	2a1e <_spi_s_async_io_read+0x62>
		return 0;
    2a46:	2000      	movs	r0, #0
    2a48:	e7c7      	b.n	29da <_spi_s_async_io_read+0x1e>
    2a4a:	bf00      	nop
    2a4c:	00009814 	.word	0x00009814
    2a50:	00003205 	.word	0x00003205
    2a54:	00003341 	.word	0x00003341
    2a58:	000032bd 	.word	0x000032bd

00002a5c <spi_s_async_dev_rx>:
{
    2a5c:	b570      	push	{r4, r5, r6, lr}
    2a5e:	4604      	mov	r4, r0
	tmp.u16 = _spi_s_async_read_one(dev);
    2a60:	4b0a      	ldr	r3, [pc, #40]	; (2a8c <spi_s_async_dev_rx+0x30>)
    2a62:	4798      	blx	r3
    2a64:	4606      	mov	r6, r0
	ringbuffer_put(&spi->rx_rb, tmp.u8[0]);
    2a66:	f104 0538 	add.w	r5, r4, #56	; 0x38
    2a6a:	b2c1      	uxtb	r1, r0
    2a6c:	4628      	mov	r0, r5
    2a6e:	4b08      	ldr	r3, [pc, #32]	; (2a90 <spi_s_async_dev_rx+0x34>)
    2a70:	4798      	blx	r3
	if (dev->char_size > 1) {
    2a72:	7923      	ldrb	r3, [r4, #4]
    2a74:	2b01      	cmp	r3, #1
    2a76:	d904      	bls.n	2a82 <spi_s_async_dev_rx+0x26>
		ringbuffer_put(&spi->rx_rb, tmp.u8[1]);
    2a78:	f3c6 2107 	ubfx	r1, r6, #8, #8
    2a7c:	4628      	mov	r0, r5
    2a7e:	4b04      	ldr	r3, [pc, #16]	; (2a90 <spi_s_async_dev_rx+0x34>)
    2a80:	4798      	blx	r3
	spi->callbacks.rx(spi);
    2a82:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    2a84:	4620      	mov	r0, r4
    2a86:	4798      	blx	r3
    2a88:	bd70      	pop	{r4, r5, r6, pc}
    2a8a:	bf00      	nop
    2a8c:	000044d9 	.word	0x000044d9
    2a90:	00003301 	.word	0x00003301

00002a94 <spi_s_async_dev_tx>:
{
    2a94:	b510      	push	{r4, lr}
    2a96:	4604      	mov	r4, r0
	if (dev->char_size > 1) {
    2a98:	7903      	ldrb	r3, [r0, #4]
    2a9a:	2b01      	cmp	r3, #1
		_spi_s_async_write_one(dev, ((uint16_t *)spi->txbuf)[spi->txcnt++]);
    2a9c:	6b02      	ldr	r2, [r0, #48]	; 0x30
    2a9e:	8ec3      	ldrh	r3, [r0, #54]	; 0x36
    2aa0:	f103 0101 	add.w	r1, r3, #1
    2aa4:	86c1      	strh	r1, [r0, #54]	; 0x36
    2aa6:	bf8c      	ite	hi
    2aa8:	f832 1013 	ldrhhi.w	r1, [r2, r3, lsl #1]
		_spi_s_async_write_one(dev, spi->txbuf[spi->txcnt++]);
    2aac:	5cd1      	ldrbls	r1, [r2, r3]
    2aae:	4b0a      	ldr	r3, [pc, #40]	; (2ad8 <spi_s_async_dev_tx+0x44>)
    2ab0:	4798      	blx	r3
	if (spi->txcnt >= spi->txsize) {
    2ab2:	8ee2      	ldrh	r2, [r4, #54]	; 0x36
    2ab4:	8ea3      	ldrh	r3, [r4, #52]	; 0x34
    2ab6:	429a      	cmp	r2, r3
    2ab8:	d200      	bcs.n	2abc <spi_s_async_dev_tx+0x28>
    2aba:	bd10      	pop	{r4, pc}
		_spi_s_async_enable_tx(dev, false);
    2abc:	2100      	movs	r1, #0
    2abe:	4620      	mov	r0, r4
    2ac0:	4b06      	ldr	r3, [pc, #24]	; (2adc <spi_s_async_dev_tx+0x48>)
    2ac2:	4798      	blx	r3
		spi->busy = 0;
    2ac4:	f894 3049 	ldrb.w	r3, [r4, #73]	; 0x49
    2ac8:	f36f 0300 	bfc	r3, #0, #1
    2acc:	f884 3049 	strb.w	r3, [r4, #73]	; 0x49
		spi->callbacks.tx(spi);
    2ad0:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2ad2:	4620      	mov	r0, r4
    2ad4:	4798      	blx	r3
}
    2ad6:	e7f0      	b.n	2aba <spi_s_async_dev_tx+0x26>
    2ad8:	000044a9 	.word	0x000044a9
    2adc:	00004409 	.word	0x00004409

00002ae0 <spi_s_async_init>:
	(void)spi;
	(void)param;
}

int32_t spi_s_async_init(struct spi_s_async_descriptor *spi, void *const hw, uint8_t *const rxbuf, int16_t bufsize)
{
    2ae0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2ae2:	460f      	mov	r7, r1
    2ae4:	4615      	mov	r5, r2
    2ae6:	461e      	mov	r6, r3
	int32_t rc;

	ASSERT(spi && hw && rxbuf && bufsize);
    2ae8:	4604      	mov	r4, r0
    2aea:	2800      	cmp	r0, #0
    2aec:	d037      	beq.n	2b5e <spi_s_async_init+0x7e>
    2aee:	2900      	cmp	r1, #0
    2af0:	d037      	beq.n	2b62 <spi_s_async_init+0x82>
    2af2:	2a00      	cmp	r2, #0
    2af4:	d037      	beq.n	2b66 <spi_s_async_init+0x86>
    2af6:	1c18      	adds	r0, r3, #0
    2af8:	bf18      	it	ne
    2afa:	2001      	movne	r0, #1
    2afc:	22eb      	movs	r2, #235	; 0xeb
    2afe:	491b      	ldr	r1, [pc, #108]	; (2b6c <spi_s_async_init+0x8c>)
    2b00:	4b1b      	ldr	r3, [pc, #108]	; (2b70 <spi_s_async_init+0x90>)
    2b02:	4798      	blx	r3

	rc = ringbuffer_init(&spi->rx_rb, rxbuf, bufsize);
    2b04:	4632      	mov	r2, r6
    2b06:	4629      	mov	r1, r5
    2b08:	f104 0038 	add.w	r0, r4, #56	; 0x38
    2b0c:	4b19      	ldr	r3, [pc, #100]	; (2b74 <spi_s_async_init+0x94>)
    2b0e:	4798      	blx	r3
	if (rc < 0) {
    2b10:	2800      	cmp	r0, #0
    2b12:	db23      	blt.n	2b5c <spi_s_async_init+0x7c>
		return rc;
	}
	rc = _spi_s_async_init(&spi->dev, hw);
    2b14:	4639      	mov	r1, r7
    2b16:	4620      	mov	r0, r4
    2b18:	4b17      	ldr	r3, [pc, #92]	; (2b78 <spi_s_async_init+0x98>)
    2b1a:	4798      	blx	r3
	if (rc < 0) {
    2b1c:	2800      	cmp	r0, #0
    2b1e:	db1d      	blt.n	2b5c <spi_s_async_init+0x7c>
		return rc;
	}
	_spi_s_async_register_callback(&spi->dev, SPI_DEV_CB_TX, (const FUNC_PTR)spi_s_async_dev_tx);
    2b20:	4a16      	ldr	r2, [pc, #88]	; (2b7c <spi_s_async_init+0x9c>)
    2b22:	2100      	movs	r1, #0
    2b24:	4620      	mov	r0, r4
    2b26:	4d16      	ldr	r5, [pc, #88]	; (2b80 <spi_s_async_init+0xa0>)
    2b28:	47a8      	blx	r5
	_spi_s_async_register_callback(&spi->dev, SPI_DEV_CB_RX, (const FUNC_PTR)spi_s_async_dev_rx);
    2b2a:	4a16      	ldr	r2, [pc, #88]	; (2b84 <spi_s_async_init+0xa4>)
    2b2c:	2101      	movs	r1, #1
    2b2e:	4620      	mov	r0, r4
    2b30:	47a8      	blx	r5
	_spi_s_async_register_callback(&spi->dev, SPI_DEV_CB_COMPLETE, (const FUNC_PTR)spi_s_async_dev_complete);
    2b32:	4a15      	ldr	r2, [pc, #84]	; (2b88 <spi_s_async_init+0xa8>)
    2b34:	2102      	movs	r1, #2
    2b36:	4620      	mov	r0, r4
    2b38:	47a8      	blx	r5

	spi->enabled = 0;
    2b3a:	f894 3049 	ldrb.w	r3, [r4, #73]	; 0x49
	spi->busy    = 0;
    2b3e:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
    2b42:	f36f 0300 	bfc	r3, #0, #1
    2b46:	f884 3049 	strb.w	r3, [r4, #73]	; 0x49

	spi->callbacks.complete = (spi_s_async_cb_complete_t)spi_s_async_dummy_func;
    2b4a:	4b10      	ldr	r3, [pc, #64]	; (2b8c <spi_s_async_init+0xac>)
    2b4c:	6263      	str	r3, [r4, #36]	; 0x24
	spi->callbacks.tx       = (spi_s_async_cb_xfer_t)spi_s_async_dummy_func;
    2b4e:	62a3      	str	r3, [r4, #40]	; 0x28
	spi->callbacks.rx       = (spi_s_async_cb_xfer_t)spi_s_async_dummy_func;
    2b50:	62e3      	str	r3, [r4, #44]	; 0x2c

	spi->io.read  = _spi_s_async_io_read;
    2b52:	4b0f      	ldr	r3, [pc, #60]	; (2b90 <spi_s_async_init+0xb0>)
    2b54:	6223      	str	r3, [r4, #32]
	spi->io.write = _spi_s_async_io_write;
    2b56:	4b0f      	ldr	r3, [pc, #60]	; (2b94 <spi_s_async_init+0xb4>)
    2b58:	61e3      	str	r3, [r4, #28]

	return ERR_NONE;
    2b5a:	2000      	movs	r0, #0
}
    2b5c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	ASSERT(spi && hw && rxbuf && bufsize);
    2b5e:	2000      	movs	r0, #0
    2b60:	e7cc      	b.n	2afc <spi_s_async_init+0x1c>
    2b62:	2000      	movs	r0, #0
    2b64:	e7ca      	b.n	2afc <spi_s_async_init+0x1c>
    2b66:	2000      	movs	r0, #0
    2b68:	e7c8      	b.n	2afc <spi_s_async_init+0x1c>
    2b6a:	bf00      	nop
    2b6c:	00009814 	.word	0x00009814
    2b70:	00003205 	.word	0x00003205
    2b74:	0000326d 	.word	0x0000326d
    2b78:	00004399 	.word	0x00004399
    2b7c:	00002a95 	.word	0x00002a95
    2b80:	00004539 	.word	0x00004539
    2b84:	00002a5d 	.word	0x00002a5d
    2b88:	00002939 	.word	0x00002939
    2b8c:	00002941 	.word	0x00002941
    2b90:	000029bd 	.word	0x000029bd
    2b94:	00002945 	.word	0x00002945

00002b98 <spi_s_async_enable>:
	_spi_s_async_enable_tx(&spi->dev, false);
	_spi_s_async_deinit(&spi->dev);
}

void spi_s_async_enable(struct spi_s_async_descriptor *spi)
{
    2b98:	b510      	push	{r4, lr}
	ASSERT(spi);
    2b9a:	4604      	mov	r4, r0
    2b9c:	f44f 7289 	mov.w	r2, #274	; 0x112
    2ba0:	490f      	ldr	r1, [pc, #60]	; (2be0 <spi_s_async_enable+0x48>)
    2ba2:	3000      	adds	r0, #0
    2ba4:	bf18      	it	ne
    2ba6:	2001      	movne	r0, #1
    2ba8:	4b0e      	ldr	r3, [pc, #56]	; (2be4 <spi_s_async_enable+0x4c>)
    2baa:	4798      	blx	r3

	if (spi->enabled) {
    2bac:	f894 3049 	ldrb.w	r3, [r4, #73]	; 0x49
    2bb0:	f013 0f02 	tst.w	r3, #2
    2bb4:	d000      	beq.n	2bb8 <spi_s_async_enable+0x20>
    2bb6:	bd10      	pop	{r4, pc}
		return;
	}
	if (_spi_s_async_enable(&spi->dev) != 0) {
    2bb8:	4620      	mov	r0, r4
    2bba:	4b0b      	ldr	r3, [pc, #44]	; (2be8 <spi_s_async_enable+0x50>)
    2bbc:	4798      	blx	r3
    2bbe:	2800      	cmp	r0, #0
    2bc0:	d1f9      	bne.n	2bb6 <spi_s_async_enable+0x1e>
		return;
	}
	spi->enabled = 1;
    2bc2:	f894 3049 	ldrb.w	r3, [r4, #73]	; 0x49
    2bc6:	f043 0302 	orr.w	r3, r3, #2
    2bca:	f884 3049 	strb.w	r3, [r4, #73]	; 0x49
	_spi_s_async_enable_rx(&spi->dev, true);
    2bce:	2101      	movs	r1, #1
    2bd0:	4620      	mov	r0, r4
    2bd2:	4b06      	ldr	r3, [pc, #24]	; (2bec <spi_s_async_enable+0x54>)
    2bd4:	4798      	blx	r3
	_spi_s_async_enable_ss_detect(&spi->dev, true);
    2bd6:	2101      	movs	r1, #1
    2bd8:	4620      	mov	r0, r4
    2bda:	4b05      	ldr	r3, [pc, #20]	; (2bf0 <spi_s_async_enable+0x58>)
    2bdc:	4798      	blx	r3
    2bde:	e7ea      	b.n	2bb6 <spi_s_async_enable+0x1e>
    2be0:	00009814 	.word	0x00009814
    2be4:	00003205 	.word	0x00003205
    2be8:	000043a5 	.word	0x000043a5
    2bec:	00004455 	.word	0x00004455
    2bf0:	0000449d 	.word	0x0000449d

00002bf4 <spi_s_async_register_callback>:
	return spi->busy ? ERR_BUSY : spi->error;
}

void spi_s_async_register_callback(struct spi_s_async_descriptor *spi, const enum spi_s_async_cb_type type,
                                   const FUNC_PTR func)
{
    2bf4:	b570      	push	{r4, r5, r6, lr}
    2bf6:	460d      	mov	r5, r1
	FUNC_PTR f = (func == NULL) ? (FUNC_PTR)spi_s_async_dummy_func : (FUNC_PTR)func;
    2bf8:	4c0c      	ldr	r4, [pc, #48]	; (2c2c <spi_s_async_register_callback+0x38>)
    2bfa:	2a00      	cmp	r2, #0
    2bfc:	bf18      	it	ne
    2bfe:	4614      	movne	r4, r2

	ASSERT(spi);
    2c00:	4606      	mov	r6, r0
    2c02:	f44f 72b0 	mov.w	r2, #352	; 0x160
    2c06:	490a      	ldr	r1, [pc, #40]	; (2c30 <spi_s_async_register_callback+0x3c>)
    2c08:	3000      	adds	r0, #0
    2c0a:	bf18      	it	ne
    2c0c:	2001      	movne	r0, #1
    2c0e:	4b09      	ldr	r3, [pc, #36]	; (2c34 <spi_s_async_register_callback+0x40>)
    2c10:	4798      	blx	r3

	switch (type) {
    2c12:	2d01      	cmp	r5, #1
    2c14:	d005      	beq.n	2c22 <spi_s_async_register_callback+0x2e>
    2c16:	b115      	cbz	r5, 2c1e <spi_s_async_register_callback+0x2a>
    2c18:	2d02      	cmp	r5, #2
    2c1a:	d004      	beq.n	2c26 <spi_s_async_register_callback+0x32>
    2c1c:	bd70      	pop	{r4, r5, r6, pc}
	case SPI_S_CB_TX:
		spi->callbacks.tx = (spi_s_async_cb_xfer_t)f;
    2c1e:	62b4      	str	r4, [r6, #40]	; 0x28
		break;
    2c20:	bd70      	pop	{r4, r5, r6, pc}
	case SPI_S_CB_RX:
		spi->callbacks.rx = (spi_s_async_cb_xfer_t)f;
    2c22:	62f4      	str	r4, [r6, #44]	; 0x2c
		break;
    2c24:	bd70      	pop	{r4, r5, r6, pc}
	case SPI_S_CB_COMPLETE:
		spi->callbacks.complete = (spi_s_async_cb_complete_t)f;
    2c26:	6274      	str	r4, [r6, #36]	; 0x24
    2c28:	bd70      	pop	{r4, r5, r6, pc}
    2c2a:	bf00      	nop
    2c2c:	00002941 	.word	0x00002941
    2c30:	00009814 	.word	0x00009814
    2c34:	00003205 	.word	0x00003205

00002c38 <spi_s_async_get_io_descriptor>:
	_spi_s_async_enable_tx(&spi->dev, false);
	spi->busy = 0;
}

int32_t spi_s_async_get_io_descriptor(struct spi_s_async_descriptor *spi, struct io_descriptor **io)
{
    2c38:	b538      	push	{r3, r4, r5, lr}
    2c3a:	460d      	mov	r5, r1
	ASSERT(spi && io);
    2c3c:	4604      	mov	r4, r0
    2c3e:	b158      	cbz	r0, 2c58 <spi_s_async_get_io_descriptor+0x20>
    2c40:	1c08      	adds	r0, r1, #0
    2c42:	bf18      	it	ne
    2c44:	2001      	movne	r0, #1
    2c46:	f44f 72c3 	mov.w	r2, #390	; 0x186
    2c4a:	4904      	ldr	r1, [pc, #16]	; (2c5c <spi_s_async_get_io_descriptor+0x24>)
    2c4c:	4b04      	ldr	r3, [pc, #16]	; (2c60 <spi_s_async_get_io_descriptor+0x28>)
    2c4e:	4798      	blx	r3
	*io = &spi->io;
    2c50:	341c      	adds	r4, #28
    2c52:	602c      	str	r4, [r5, #0]
	return ERR_NONE;
}
    2c54:	2000      	movs	r0, #0
    2c56:	bd38      	pop	{r3, r4, r5, pc}
    2c58:	2000      	movs	r0, #0
    2c5a:	e7f4      	b.n	2c46 <spi_s_async_get_io_descriptor+0xe>
    2c5c:	00009814 	.word	0x00009814
    2c60:	00003205 	.word	0x00003205

00002c64 <_usb_d_find_ep>:
 */
static int8_t _usb_d_find_ep(const uint8_t ep)
{
	int8_t i;
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
		if (usb_d_inst.ep[i].xfer.hdr.ep == ep) {
    2c64:	4b0f      	ldr	r3, [pc, #60]	; (2ca4 <_usb_d_find_ep+0x40>)
    2c66:	7859      	ldrb	r1, [r3, #1]
    2c68:	4288      	cmp	r0, r1
    2c6a:	d018      	beq.n	2c9e <_usb_d_find_ep+0x3a>
{
    2c6c:	b430      	push	{r4, r5}
    2c6e:	461a      	mov	r2, r3
		if (usb_d_inst.ep[i].xfer.hdr.ep == ep) {
    2c70:	2300      	movs	r3, #0
			return i;
		}
		if (usb_d_inst.ep[i].xfer.hdr.type == USB_EP_XTYPE_CTRL
		    && (ep & USB_EP_N_MASK) == usb_d_inst.ep[i].xfer.hdr.ep) {
    2c72:	f000 050f 	and.w	r5, r0, #15
    2c76:	e007      	b.n	2c88 <_usb_d_find_ep+0x24>
    2c78:	3301      	adds	r3, #1
    2c7a:	b25b      	sxtb	r3, r3
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
    2c7c:	2b0d      	cmp	r3, #13
    2c7e:	d009      	beq.n	2c94 <_usb_d_find_ep+0x30>
    2c80:	3220      	adds	r2, #32
		if (usb_d_inst.ep[i].xfer.hdr.ep == ep) {
    2c82:	7851      	ldrb	r1, [r2, #1]
    2c84:	4281      	cmp	r1, r0
    2c86:	d007      	beq.n	2c98 <_usb_d_find_ep+0x34>
		if (usb_d_inst.ep[i].xfer.hdr.type == USB_EP_XTYPE_CTRL
    2c88:	7814      	ldrb	r4, [r2, #0]
    2c8a:	2c00      	cmp	r4, #0
    2c8c:	d1f4      	bne.n	2c78 <_usb_d_find_ep+0x14>
		    && (ep & USB_EP_N_MASK) == usb_d_inst.ep[i].xfer.hdr.ep) {
    2c8e:	428d      	cmp	r5, r1
    2c90:	d1f2      	bne.n	2c78 <_usb_d_find_ep+0x14>
    2c92:	e001      	b.n	2c98 <_usb_d_find_ep+0x34>
			return i;
		}
	}
	return -1;
    2c94:	f04f 33ff 	mov.w	r3, #4294967295
}
    2c98:	4618      	mov	r0, r3
    2c9a:	bc30      	pop	{r4, r5}
    2c9c:	4770      	bx	lr
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
    2c9e:	2300      	movs	r3, #0
}
    2ca0:	4618      	mov	r0, r3
    2ca2:	4770      	bx	lr
    2ca4:	20000118 	.word	0x20000118

00002ca8 <usb_d_dummy_cb_false>:
{
	(void)unused0;
	(void)unused1;
	(void)unused2;
	return false;
}
    2ca8:	2000      	movs	r0, #0
    2caa:	4770      	bx	lr

00002cac <usb_d_cb_trans_more>:
 * \brief Callback invoked when request more data
 * \param[in] ep Endpoint number with transfer direction on bit 8.
 * \param[in] transfered Number of bytes transfered.
 */
static bool usb_d_cb_trans_more(const uint8_t ep, const uint32_t transfered)
{
    2cac:	b538      	push	{r3, r4, r5, lr}
    2cae:	4604      	mov	r4, r0
    2cb0:	460d      	mov	r5, r1
	int8_t           ep_index = _usb_d_find_ep(ep);
    2cb2:	4b09      	ldr	r3, [pc, #36]	; (2cd8 <usb_d_cb_trans_more+0x2c>)
    2cb4:	4798      	blx	r3
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
	if (ept->xfer.hdr.state == USB_EP_S_X_DATA) {
    2cb6:	4b09      	ldr	r3, [pc, #36]	; (2cdc <usb_d_cb_trans_more+0x30>)
    2cb8:	eb03 1340 	add.w	r3, r3, r0, lsl #5
    2cbc:	789b      	ldrb	r3, [r3, #2]
    2cbe:	2b03      	cmp	r3, #3
    2cc0:	d001      	beq.n	2cc6 <usb_d_cb_trans_more+0x1a>
		return ept->callbacks.more(ep, transfered);
	}
	return false;
    2cc2:	2000      	movs	r0, #0
}
    2cc4:	bd38      	pop	{r3, r4, r5, pc}
		return ept->callbacks.more(ep, transfered);
    2cc6:	4b05      	ldr	r3, [pc, #20]	; (2cdc <usb_d_cb_trans_more+0x30>)
    2cc8:	eb03 1040 	add.w	r0, r3, r0, lsl #5
    2ccc:	6983      	ldr	r3, [r0, #24]
    2cce:	4629      	mov	r1, r5
    2cd0:	4620      	mov	r0, r4
    2cd2:	4798      	blx	r3
    2cd4:	bd38      	pop	{r3, r4, r5, pc}
    2cd6:	bf00      	nop
    2cd8:	00002c65 	.word	0x00002c65
    2cdc:	20000118 	.word	0x20000118

00002ce0 <_usb_d_cb_trans_done>:

/**
 * Callback when USB transactions are finished.
 */
static void _usb_d_cb_trans_done(const uint8_t ep, const int32_t code, const uint32_t transferred)
{
    2ce0:	b5f0      	push	{r4, r5, r6, r7, lr}
    2ce2:	b085      	sub	sp, #20
    2ce4:	4606      	mov	r6, r0
    2ce6:	460d      	mov	r5, r1
    2ce8:	4617      	mov	r7, r2
	int8_t           ep_index = _usb_d_find_ep(ep);
    2cea:	4b4d      	ldr	r3, [pc, #308]	; (2e20 <_usb_d_cb_trans_done+0x140>)
    2cec:	4798      	blx	r3
    2cee:	4604      	mov	r4, r0
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];

	if (code == USB_TRANS_DONE) {
    2cf0:	2d00      	cmp	r5, #0
    2cf2:	d15b      	bne.n	2dac <_usb_d_cb_trans_done+0xcc>
		ept->xfer.hdr.status = USB_XFER_DONE;
    2cf4:	4a4b      	ldr	r2, [pc, #300]	; (2e24 <_usb_d_cb_trans_done+0x144>)
    2cf6:	0143      	lsls	r3, r0, #5
    2cf8:	18d1      	adds	r1, r2, r3
    2cfa:	2000      	movs	r0, #0
    2cfc:	70c8      	strb	r0, [r1, #3]
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
    2cfe:	5cd3      	ldrb	r3, [r2, r3]
    2d00:	b173      	cbz	r3, 2d20 <_usb_d_cb_trans_done+0x40>
			usb_d_ctrl_trans_done(ept);
			return;
		}
		ept->xfer.hdr.state = USB_EP_S_IDLE;
    2d02:	4b48      	ldr	r3, [pc, #288]	; (2e24 <_usb_d_cb_trans_done+0x144>)
    2d04:	eb03 1344 	add.w	r3, r3, r4, lsl #5
    2d08:	2201      	movs	r2, #1
    2d0a:	709a      	strb	r2, [r3, #2]
	} else {
		ept->xfer.hdr.state  = USB_EP_S_ERROR;
		ept->xfer.hdr.status = USB_XFER_ERROR;
	}

	ept->callbacks.xfer(ep, (enum usb_xfer_code)ept->xfer.hdr.status, (void *)transferred);
    2d0c:	4845      	ldr	r0, [pc, #276]	; (2e24 <_usb_d_cb_trans_done+0x144>)
    2d0e:	eb00 1044 	add.w	r0, r0, r4, lsl #5
    2d12:	69c3      	ldr	r3, [r0, #28]
    2d14:	463a      	mov	r2, r7
    2d16:	78c1      	ldrb	r1, [r0, #3]
    2d18:	4630      	mov	r0, r6
    2d1a:	4798      	blx	r3
}
    2d1c:	b005      	add	sp, #20
    2d1e:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (state == USB_EP_S_X_DATA) {
    2d20:	788b      	ldrb	r3, [r1, #2]
    2d22:	2b03      	cmp	r3, #3
    2d24:	d00b      	beq.n	2d3e <_usb_d_cb_trans_done+0x5e>
		ept->callbacks.xfer(ept->xfer.hdr.ep, USB_XFER_DONE, ept->xfer.req);
    2d26:	483f      	ldr	r0, [pc, #252]	; (2e24 <_usb_d_cb_trans_done+0x144>)
    2d28:	eb00 1244 	add.w	r2, r0, r4, lsl #5
    2d2c:	4614      	mov	r4, r2
    2d2e:	69d3      	ldr	r3, [r2, #28]
    2d30:	320c      	adds	r2, #12
    2d32:	2100      	movs	r1, #0
    2d34:	7860      	ldrb	r0, [r4, #1]
    2d36:	4798      	blx	r3
		ept->xfer.hdr.state = USB_EP_S_X_SETUP;
    2d38:	2302      	movs	r3, #2
    2d3a:	70a3      	strb	r3, [r4, #2]
    2d3c:	e7ee      	b.n	2d1c <_usb_d_cb_trans_done+0x3c>
	bool    req_dir = USB_GET_bmRequestType(ept->xfer.req) & USB_REQ_TYPE_IN;
    2d3e:	460b      	mov	r3, r1
    2d40:	f991 500c 	ldrsb.w	r5, [r1, #12]
		bool err = ept->callbacks.xfer(ept->xfer.hdr.ep, USB_XFER_DATA, ept->xfer.req);
    2d44:	460a      	mov	r2, r1
    2d46:	69ce      	ldr	r6, [r1, #28]
    2d48:	320c      	adds	r2, #12
    2d4a:	2101      	movs	r1, #1
    2d4c:	7858      	ldrb	r0, [r3, #1]
    2d4e:	47b0      	blx	r6
		if (err) {
    2d50:	b1a0      	cbz	r0, 2d7c <_usb_d_cb_trans_done+0x9c>
			ept->xfer.hdr.state  = USB_EP_S_HALTED;
    2d52:	4b34      	ldr	r3, [pc, #208]	; (2e24 <_usb_d_cb_trans_done+0x144>)
    2d54:	eb03 1344 	add.w	r3, r3, r4, lsl #5
    2d58:	2205      	movs	r2, #5
    2d5a:	709a      	strb	r2, [r3, #2]
			ept->xfer.hdr.status = USB_XFER_HALT;
    2d5c:	2202      	movs	r2, #2
    2d5e:	70da      	strb	r2, [r3, #3]
			_usb_d_dev_ep_stall(req_dir ? ept->xfer.hdr.ep : (ept->xfer.hdr.ep | USB_EP_DIR), USB_EP_STALL_SET);
    2d60:	2d00      	cmp	r5, #0
    2d62:	db09      	blt.n	2d78 <_usb_d_cb_trans_done+0x98>
    2d64:	482f      	ldr	r0, [pc, #188]	; (2e24 <_usb_d_cb_trans_done+0x144>)
    2d66:	eb00 1044 	add.w	r0, r0, r4, lsl #5
    2d6a:	7840      	ldrb	r0, [r0, #1]
    2d6c:	f040 0080 	orr.w	r0, r0, #128	; 0x80
    2d70:	2101      	movs	r1, #1
    2d72:	4b2d      	ldr	r3, [pc, #180]	; (2e28 <_usb_d_cb_trans_done+0x148>)
    2d74:	4798      	blx	r3
    2d76:	e7d1      	b.n	2d1c <_usb_d_cb_trans_done+0x3c>
    2d78:	7858      	ldrb	r0, [r3, #1]
    2d7a:	e7f9      	b.n	2d70 <_usb_d_cb_trans_done+0x90>
			ept->xfer.hdr.state = USB_EP_S_X_STATUS;
    2d7c:	4829      	ldr	r0, [pc, #164]	; (2e24 <_usb_d_cb_trans_done+0x144>)
    2d7e:	eb00 1044 	add.w	r0, r0, r4, lsl #5
    2d82:	2304      	movs	r3, #4
    2d84:	7083      	strb	r3, [r0, #2]
			_usb_d_trans(ept->xfer.hdr.ep, !req_dir, NULL, 0, 1);
    2d86:	7843      	ldrb	r3, [r0, #1]
	struct usb_d_transfer trans
    2d88:	2200      	movs	r2, #0
    2d8a:	9201      	str	r2, [sp, #4]
    2d8c:	9202      	str	r2, [sp, #8]
    2d8e:	4295      	cmp	r5, r2
    2d90:	bfac      	ite	ge
    2d92:	f043 0380 	orrge.w	r3, r3, #128	; 0x80
    2d96:	f003 030f 	andlt.w	r3, r3, #15
    2d9a:	f88d 300c 	strb.w	r3, [sp, #12]
    2d9e:	2301      	movs	r3, #1
    2da0:	f88d 300d 	strb.w	r3, [sp, #13]
	return _usb_d_dev_ep_trans(&trans);
    2da4:	a801      	add	r0, sp, #4
    2da6:	4b21      	ldr	r3, [pc, #132]	; (2e2c <_usb_d_cb_trans_done+0x14c>)
    2da8:	4798      	blx	r3
    2daa:	e7b7      	b.n	2d1c <_usb_d_cb_trans_done+0x3c>
	} else if (code == USB_TRANS_STALL) {
    2dac:	2d01      	cmp	r5, #1
    2dae:	d00a      	beq.n	2dc6 <_usb_d_cb_trans_done+0xe6>
	} else if (code == USB_TRANS_ABORT) {
    2db0:	2d02      	cmp	r5, #2
    2db2:	d01c      	beq.n	2dee <_usb_d_cb_trans_done+0x10e>
	} else if (code == USB_TRANS_RESET) {
    2db4:	2d03      	cmp	r5, #3
    2db6:	d02a      	beq.n	2e0e <_usb_d_cb_trans_done+0x12e>
		ept->xfer.hdr.state  = USB_EP_S_ERROR;
    2db8:	4b1a      	ldr	r3, [pc, #104]	; (2e24 <_usb_d_cb_trans_done+0x144>)
    2dba:	eb03 1340 	add.w	r3, r3, r0, lsl #5
    2dbe:	2206      	movs	r2, #6
    2dc0:	709a      	strb	r2, [r3, #2]
		ept->xfer.hdr.status = USB_XFER_ERROR;
    2dc2:	70da      	strb	r2, [r3, #3]
    2dc4:	e7a2      	b.n	2d0c <_usb_d_cb_trans_done+0x2c>
		ept->xfer.hdr.status = USB_XFER_HALT;
    2dc6:	4a17      	ldr	r2, [pc, #92]	; (2e24 <_usb_d_cb_trans_done+0x144>)
    2dc8:	0143      	lsls	r3, r0, #5
    2dca:	18d1      	adds	r1, r2, r3
    2dcc:	2002      	movs	r0, #2
    2dce:	70c8      	strb	r0, [r1, #3]
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
    2dd0:	5cd3      	ldrb	r3, [r2, r3]
    2dd2:	b12b      	cbz	r3, 2de0 <_usb_d_cb_trans_done+0x100>
			ept->xfer.hdr.state = USB_EP_S_HALTED;
    2dd4:	4b13      	ldr	r3, [pc, #76]	; (2e24 <_usb_d_cb_trans_done+0x144>)
    2dd6:	eb03 1344 	add.w	r3, r3, r4, lsl #5
    2dda:	2205      	movs	r2, #5
    2ddc:	709a      	strb	r2, [r3, #2]
    2dde:	e795      	b.n	2d0c <_usb_d_cb_trans_done+0x2c>
			ept->xfer.hdr.state = USB_EP_S_X_SETUP;
    2de0:	460b      	mov	r3, r1
    2de2:	7098      	strb	r0, [r3, #2]
			_usb_d_dev_ep_stall(ep, USB_EP_STALL_CLR);
    2de4:	2100      	movs	r1, #0
    2de6:	4630      	mov	r0, r6
    2de8:	4b0f      	ldr	r3, [pc, #60]	; (2e28 <_usb_d_cb_trans_done+0x148>)
    2dea:	4798      	blx	r3
    2dec:	e78e      	b.n	2d0c <_usb_d_cb_trans_done+0x2c>
		ept->xfer.hdr.status = USB_XFER_ABORT;
    2dee:	4a0d      	ldr	r2, [pc, #52]	; (2e24 <_usb_d_cb_trans_done+0x144>)
    2df0:	0143      	lsls	r3, r0, #5
    2df2:	18d1      	adds	r1, r2, r3
    2df4:	2004      	movs	r0, #4
    2df6:	70c8      	strb	r0, [r1, #3]
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
    2df8:	5cd3      	ldrb	r3, [r2, r3]
    2dfa:	b12b      	cbz	r3, 2e08 <_usb_d_cb_trans_done+0x128>
		ept->xfer.hdr.state = USB_EP_S_IDLE;
    2dfc:	4b09      	ldr	r3, [pc, #36]	; (2e24 <_usb_d_cb_trans_done+0x144>)
    2dfe:	eb03 1344 	add.w	r3, r3, r4, lsl #5
    2e02:	2201      	movs	r2, #1
    2e04:	709a      	strb	r2, [r3, #2]
    2e06:	e781      	b.n	2d0c <_usb_d_cb_trans_done+0x2c>
			ept->xfer.hdr.state = USB_EP_S_X_SETUP;
    2e08:	2302      	movs	r3, #2
    2e0a:	708b      	strb	r3, [r1, #2]
			return;
    2e0c:	e786      	b.n	2d1c <_usb_d_cb_trans_done+0x3c>
		ept->xfer.hdr.state  = USB_EP_S_DISABLED;
    2e0e:	4b05      	ldr	r3, [pc, #20]	; (2e24 <_usb_d_cb_trans_done+0x144>)
    2e10:	eb03 1340 	add.w	r3, r3, r0, lsl #5
    2e14:	2200      	movs	r2, #0
    2e16:	709a      	strb	r2, [r3, #2]
		ept->xfer.hdr.status = USB_XFER_RESET;
    2e18:	2205      	movs	r2, #5
    2e1a:	70da      	strb	r2, [r3, #3]
    2e1c:	e776      	b.n	2d0c <_usb_d_cb_trans_done+0x2c>
    2e1e:	bf00      	nop
    2e20:	00002c65 	.word	0x00002c65
    2e24:	20000118 	.word	0x20000118
    2e28:	00005619 	.word	0x00005619
    2e2c:	000057c1 	.word	0x000057c1

00002e30 <usb_d_cb_trans_setup>:
{
    2e30:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    2e34:	4605      	mov	r5, r0
	int8_t           ep_index = _usb_d_find_ep(ep);
    2e36:	4b1c      	ldr	r3, [pc, #112]	; (2ea8 <usb_d_cb_trans_setup+0x78>)
    2e38:	4798      	blx	r3
    2e3a:	4606      	mov	r6, r0
	uint8_t *        req      = ept->xfer.req;
    2e3c:	4c1b      	ldr	r4, [pc, #108]	; (2eac <usb_d_cb_trans_setup+0x7c>)
    2e3e:	eb04 1440 	add.w	r4, r4, r0, lsl #5
    2e42:	340c      	adds	r4, #12
	uint8_t n = _usb_d_dev_ep_read_req(ep, req);
    2e44:	4621      	mov	r1, r4
    2e46:	4628      	mov	r0, r5
    2e48:	4b19      	ldr	r3, [pc, #100]	; (2eb0 <usb_d_cb_trans_setup+0x80>)
    2e4a:	4798      	blx	r3
	if (n != 8) {
    2e4c:	b2c0      	uxtb	r0, r0
    2e4e:	2808      	cmp	r0, #8
    2e50:	d009      	beq.n	2e66 <usb_d_cb_trans_setup+0x36>
		_usb_d_dev_ep_stall(ep, USB_EP_STALL_SET);
    2e52:	2101      	movs	r1, #1
    2e54:	4628      	mov	r0, r5
    2e56:	4c17      	ldr	r4, [pc, #92]	; (2eb4 <usb_d_cb_trans_setup+0x84>)
    2e58:	47a0      	blx	r4
		_usb_d_dev_ep_stall(ep | USB_EP_DIR, USB_EP_STALL_SET);
    2e5a:	2101      	movs	r1, #1
    2e5c:	f045 0080 	orr.w	r0, r5, #128	; 0x80
    2e60:	47a0      	blx	r4
		return;
    2e62:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	_usb_d_dev_ep_stall(ep, USB_EP_STALL_CLR);
    2e66:	2100      	movs	r1, #0
    2e68:	4628      	mov	r0, r5
    2e6a:	4f12      	ldr	r7, [pc, #72]	; (2eb4 <usb_d_cb_trans_setup+0x84>)
    2e6c:	47b8      	blx	r7
	_usb_d_dev_ep_stall(ep | USB_EP_DIR, USB_EP_STALL_CLR);
    2e6e:	f045 0880 	orr.w	r8, r5, #128	; 0x80
    2e72:	2100      	movs	r1, #0
    2e74:	4640      	mov	r0, r8
    2e76:	47b8      	blx	r7
	ept->xfer.hdr.state = USB_EP_S_IDLE;
    2e78:	4b0c      	ldr	r3, [pc, #48]	; (2eac <usb_d_cb_trans_setup+0x7c>)
    2e7a:	eb03 1346 	add.w	r3, r3, r6, lsl #5
    2e7e:	2201      	movs	r2, #1
    2e80:	709a      	strb	r2, [r3, #2]
	if (!ept->callbacks.req(ep, req)) {
    2e82:	695b      	ldr	r3, [r3, #20]
    2e84:	4621      	mov	r1, r4
    2e86:	4628      	mov	r0, r5
    2e88:	4798      	blx	r3
    2e8a:	b108      	cbz	r0, 2e90 <usb_d_cb_trans_setup+0x60>
    2e8c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		ept->xfer.hdr.state = USB_EP_S_HALTED;
    2e90:	4b06      	ldr	r3, [pc, #24]	; (2eac <usb_d_cb_trans_setup+0x7c>)
    2e92:	eb03 1646 	add.w	r6, r3, r6, lsl #5
    2e96:	2305      	movs	r3, #5
    2e98:	70b3      	strb	r3, [r6, #2]
		_usb_d_dev_ep_stall(ep, USB_EP_STALL_SET);
    2e9a:	2101      	movs	r1, #1
    2e9c:	4628      	mov	r0, r5
    2e9e:	47b8      	blx	r7
		_usb_d_dev_ep_stall(ep | USB_EP_DIR, USB_EP_STALL_SET);
    2ea0:	2101      	movs	r1, #1
    2ea2:	4640      	mov	r0, r8
    2ea4:	47b8      	blx	r7
    2ea6:	e7f1      	b.n	2e8c <usb_d_cb_trans_setup+0x5c>
    2ea8:	00002c65 	.word	0x00002c65
    2eac:	20000118 	.word	0x20000118
    2eb0:	00005761 	.word	0x00005761
    2eb4:	00005619 	.word	0x00005619

00002eb8 <usb_d_init>:

int32_t usb_d_init(void)
{
    2eb8:	b510      	push	{r4, lr}
	int32_t rc = _usb_d_dev_init();
    2eba:	4b11      	ldr	r3, [pc, #68]	; (2f00 <usb_d_init+0x48>)
    2ebc:	4798      	blx	r3
	uint8_t i;
	if (rc < 0) {
    2ebe:	2800      	cmp	r0, #0
    2ec0:	db1d      	blt.n	2efe <usb_d_init+0x46>
		return rc;
	}
	memset(usb_d_inst.ep, 0x00, sizeof(struct usb_d_ep) * CONF_USB_D_NUM_EP_SP);
    2ec2:	4c10      	ldr	r4, [pc, #64]	; (2f04 <usb_d_init+0x4c>)
    2ec4:	f44f 72d0 	mov.w	r2, #416	; 0x1a0
    2ec8:	2100      	movs	r1, #0
    2eca:	4620      	mov	r0, r4
    2ecc:	4b0e      	ldr	r3, [pc, #56]	; (2f08 <usb_d_init+0x50>)
    2ece:	4798      	blx	r3
    2ed0:	4623      	mov	r3, r4
    2ed2:	f504 70d0 	add.w	r0, r4, #416	; 0x1a0
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
		usb_d_inst.ep[i].xfer.hdr.ep    = 0xFF;
    2ed6:	21ff      	movs	r1, #255	; 0xff
		usb_d_inst.ep[i].callbacks.req  = (usb_d_ep_cb_setup_t)usb_d_dummy_cb_false;
    2ed8:	4a0c      	ldr	r2, [pc, #48]	; (2f0c <usb_d_init+0x54>)
		usb_d_inst.ep[i].xfer.hdr.ep    = 0xFF;
    2eda:	7059      	strb	r1, [r3, #1]
		usb_d_inst.ep[i].callbacks.req  = (usb_d_ep_cb_setup_t)usb_d_dummy_cb_false;
    2edc:	615a      	str	r2, [r3, #20]
		usb_d_inst.ep[i].callbacks.more = (usb_d_ep_cb_more_t)usb_d_dummy_cb_false;
    2ede:	619a      	str	r2, [r3, #24]
		usb_d_inst.ep[i].callbacks.xfer = (usb_d_ep_cb_xfer_t)usb_d_dummy_cb_false;
    2ee0:	61da      	str	r2, [r3, #28]
    2ee2:	3320      	adds	r3, #32
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
    2ee4:	4283      	cmp	r3, r0
    2ee6:	d1f8      	bne.n	2eda <usb_d_init+0x22>
	}
	/* Handles device driver endpoint callbacks to build transfer. */
	_usb_d_dev_register_ep_callback(USB_D_DEV_EP_CB_SETUP, (FUNC_PTR)usb_d_cb_trans_setup);
    2ee8:	4909      	ldr	r1, [pc, #36]	; (2f10 <usb_d_init+0x58>)
    2eea:	2000      	movs	r0, #0
    2eec:	4c09      	ldr	r4, [pc, #36]	; (2f14 <usb_d_init+0x5c>)
    2eee:	47a0      	blx	r4
	_usb_d_dev_register_ep_callback(USB_D_DEV_EP_CB_MORE, (FUNC_PTR)usb_d_cb_trans_more);
    2ef0:	4909      	ldr	r1, [pc, #36]	; (2f18 <usb_d_init+0x60>)
    2ef2:	2001      	movs	r0, #1
    2ef4:	47a0      	blx	r4
	_usb_d_dev_register_ep_callback(USB_D_DEV_EP_CB_DONE, (FUNC_PTR)_usb_d_cb_trans_done);
    2ef6:	4909      	ldr	r1, [pc, #36]	; (2f1c <usb_d_init+0x64>)
    2ef8:	2002      	movs	r0, #2
    2efa:	47a0      	blx	r4
	return ERR_NONE;
    2efc:	2000      	movs	r0, #0
}
    2efe:	bd10      	pop	{r4, pc}
    2f00:	00005035 	.word	0x00005035
    2f04:	20000118 	.word	0x20000118
    2f08:	000096ab 	.word	0x000096ab
    2f0c:	00002ca9 	.word	0x00002ca9
    2f10:	00002e31 	.word	0x00002e31
    2f14:	000059c5 	.word	0x000059c5
    2f18:	00002cad 	.word	0x00002cad
    2f1c:	00002ce1 	.word	0x00002ce1

00002f20 <usb_d_register_callback>:
{
	_usb_d_dev_deinit();
}

void usb_d_register_callback(const enum usb_d_cb_type type, const FUNC_PTR func)
{
    2f20:	b508      	push	{r3, lr}
	/* Directly uses device driver callback. */
	_usb_d_dev_register_callback(type, func);
    2f22:	4b01      	ldr	r3, [pc, #4]	; (2f28 <usb_d_register_callback+0x8>)
    2f24:	4798      	blx	r3
    2f26:	bd08      	pop	{r3, pc}
    2f28:	000059a1 	.word	0x000059a1

00002f2c <usb_d_enable>:
}

int32_t usb_d_enable(void)
{
    2f2c:	b508      	push	{r3, lr}
	return _usb_d_dev_enable();
    2f2e:	4b01      	ldr	r3, [pc, #4]	; (2f34 <usb_d_enable+0x8>)
    2f30:	4798      	blx	r3
}
    2f32:	bd08      	pop	{r3, pc}
    2f34:	0000510d 	.word	0x0000510d

00002f38 <usb_d_attach>:
{
	_usb_d_dev_disable();
}

void usb_d_attach(void)
{
    2f38:	b508      	push	{r3, lr}
	_usb_d_dev_attach();
    2f3a:	4b01      	ldr	r3, [pc, #4]	; (2f40 <usb_d_attach+0x8>)
    2f3c:	4798      	blx	r3
    2f3e:	bd08      	pop	{r3, pc}
    2f40:	00005165 	.word	0x00005165

00002f44 <usb_d_set_address>:
{
	return _usb_d_dev_get_uframe_n();
}

void usb_d_set_address(const uint8_t addr)
{
    2f44:	b508      	push	{r3, lr}
	_usb_d_dev_set_address(addr);
    2f46:	4b01      	ldr	r3, [pc, #4]	; (2f4c <usb_d_set_address+0x8>)
    2f48:	4798      	blx	r3
    2f4a:	bd08      	pop	{r3, pc}
    2f4c:	00005177 	.word	0x00005177

00002f50 <usb_d_ep_init>:
{
	return usb_d_ep_init(0, USB_EP_XTYPE_CTRL, max_pkt_size);
}

int32_t usb_d_ep_init(const uint8_t ep, const uint8_t attr, const uint16_t max_pkt_size)
{
    2f50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2f52:	4606      	mov	r6, r0
    2f54:	460c      	mov	r4, r1
    2f56:	4617      	mov	r7, r2
	int32_t          rc;
	int8_t           ep_index = _usb_d_find_ep(ep);
    2f58:	4b0f      	ldr	r3, [pc, #60]	; (2f98 <usb_d_ep_init+0x48>)
    2f5a:	4798      	blx	r3
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
	if (ep_index >= 0) {
    2f5c:	2800      	cmp	r0, #0
    2f5e:	da14      	bge.n	2f8a <usb_d_ep_init+0x3a>
		return -USB_ERR_REDO;
	} else {
		ep_index = _usb_d_find_ep(0xFF);
    2f60:	20ff      	movs	r0, #255	; 0xff
    2f62:	4b0d      	ldr	r3, [pc, #52]	; (2f98 <usb_d_ep_init+0x48>)
    2f64:	4798      	blx	r3
		if (ep_index < 0) {
    2f66:	1e05      	subs	r5, r0, #0
    2f68:	db12      	blt.n	2f90 <usb_d_ep_init+0x40>
			return -USB_ERR_ALLOC_FAIL;
		}
		ept = &usb_d_inst.ep[ep_index];
	}
	rc = _usb_d_dev_ep_init(ep, attr, max_pkt_size);
    2f6a:	463a      	mov	r2, r7
    2f6c:	4621      	mov	r1, r4
    2f6e:	4630      	mov	r0, r6
    2f70:	4b0a      	ldr	r3, [pc, #40]	; (2f9c <usb_d_ep_init+0x4c>)
    2f72:	4798      	blx	r3
	if (rc < 0) {
    2f74:	2800      	cmp	r0, #0
    2f76:	db0d      	blt.n	2f94 <usb_d_ep_init+0x44>
		return rc;
	}
	ept->xfer.hdr.ep   = ep;
    2f78:	4b09      	ldr	r3, [pc, #36]	; (2fa0 <usb_d_ep_init+0x50>)
    2f7a:	0168      	lsls	r0, r5, #5
    2f7c:	181a      	adds	r2, r3, r0
    2f7e:	7056      	strb	r6, [r2, #1]
	ept->xfer.hdr.type = attr & USB_EP_XTYPE_MASK;
    2f80:	f004 0403 	and.w	r4, r4, #3
    2f84:	541c      	strb	r4, [r3, r0]
	return ERR_NONE;
    2f86:	2000      	movs	r0, #0
    2f88:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return -USB_ERR_REDO;
    2f8a:	f06f 0013 	mvn.w	r0, #19
    2f8e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			return -USB_ERR_ALLOC_FAIL;
    2f90:	f06f 0014 	mvn.w	r0, #20
}
    2f94:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2f96:	bf00      	nop
    2f98:	00002c65 	.word	0x00002c65
    2f9c:	00005185 	.word	0x00005185
    2fa0:	20000118 	.word	0x20000118

00002fa4 <usb_d_ep0_init>:
{
    2fa4:	b508      	push	{r3, lr}
	return usb_d_ep_init(0, USB_EP_XTYPE_CTRL, max_pkt_size);
    2fa6:	4602      	mov	r2, r0
    2fa8:	2100      	movs	r1, #0
    2faa:	4608      	mov	r0, r1
    2fac:	4b01      	ldr	r3, [pc, #4]	; (2fb4 <usb_d_ep0_init+0x10>)
    2fae:	4798      	blx	r3
}
    2fb0:	bd08      	pop	{r3, pc}
    2fb2:	bf00      	nop
    2fb4:	00002f51 	.word	0x00002f51

00002fb8 <usb_d_ep_deinit>:

void usb_d_ep_deinit(const uint8_t ep)
{
    2fb8:	b538      	push	{r3, r4, r5, lr}
    2fba:	4605      	mov	r5, r0
	int8_t           ep_index = _usb_d_find_ep(ep);
    2fbc:	4b06      	ldr	r3, [pc, #24]	; (2fd8 <usb_d_ep_deinit+0x20>)
    2fbe:	4798      	blx	r3
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
	if (ep_index < 0) {
    2fc0:	1e04      	subs	r4, r0, #0
    2fc2:	db07      	blt.n	2fd4 <usb_d_ep_deinit+0x1c>
		return;
	}
	_usb_d_dev_ep_deinit(ep);
    2fc4:	4628      	mov	r0, r5
    2fc6:	4b05      	ldr	r3, [pc, #20]	; (2fdc <usb_d_ep_deinit+0x24>)
    2fc8:	4798      	blx	r3
	ept->xfer.hdr.ep = 0xFF;
    2fca:	4805      	ldr	r0, [pc, #20]	; (2fe0 <usb_d_ep_deinit+0x28>)
    2fcc:	eb00 1044 	add.w	r0, r0, r4, lsl #5
    2fd0:	23ff      	movs	r3, #255	; 0xff
    2fd2:	7043      	strb	r3, [r0, #1]
    2fd4:	bd38      	pop	{r3, r4, r5, pc}
    2fd6:	bf00      	nop
    2fd8:	00002c65 	.word	0x00002c65
    2fdc:	0000529d 	.word	0x0000529d
    2fe0:	20000118 	.word	0x20000118

00002fe4 <usb_d_ep_enable>:
}

int32_t usb_d_ep_enable(const uint8_t ep)
{
    2fe4:	b538      	push	{r3, r4, r5, lr}
    2fe6:	4605      	mov	r5, r0
	int8_t           ep_index = _usb_d_find_ep(ep);
    2fe8:	4b0e      	ldr	r3, [pc, #56]	; (3024 <usb_d_ep_enable+0x40>)
    2fea:	4798      	blx	r3
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
	int32_t          rc;
	if (ep_index < 0) {
    2fec:	1e04      	subs	r4, r0, #0
    2fee:	db16      	blt.n	301e <usb_d_ep_enable+0x3a>
		return -USB_ERR_PARAM;
	}
	ept->xfer.hdr.state = (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) ? USB_EP_S_X_SETUP : USB_EP_S_IDLE;
    2ff0:	0163      	lsls	r3, r4, #5
    2ff2:	4a0d      	ldr	r2, [pc, #52]	; (3028 <usb_d_ep_enable+0x44>)
    2ff4:	5cd3      	ldrb	r3, [r2, r3]
    2ff6:	2b00      	cmp	r3, #0
    2ff8:	bf0c      	ite	eq
    2ffa:	2202      	moveq	r2, #2
    2ffc:	2201      	movne	r2, #1
    2ffe:	4b0a      	ldr	r3, [pc, #40]	; (3028 <usb_d_ep_enable+0x44>)
    3000:	eb03 1344 	add.w	r3, r3, r4, lsl #5
    3004:	709a      	strb	r2, [r3, #2]
	rc                  = _usb_d_dev_ep_enable(ep);
    3006:	4628      	mov	r0, r5
    3008:	4b08      	ldr	r3, [pc, #32]	; (302c <usb_d_ep_enable+0x48>)
    300a:	4798      	blx	r3
	if (rc < 0) {
    300c:	2800      	cmp	r0, #0
    300e:	db00      	blt.n	3012 <usb_d_ep_enable+0x2e>
		ept->xfer.hdr.state = USB_EP_S_DISABLED;
	}
	return rc;
}
    3010:	bd38      	pop	{r3, r4, r5, pc}
		ept->xfer.hdr.state = USB_EP_S_DISABLED;
    3012:	4b05      	ldr	r3, [pc, #20]	; (3028 <usb_d_ep_enable+0x44>)
    3014:	eb03 1444 	add.w	r4, r3, r4, lsl #5
    3018:	2300      	movs	r3, #0
    301a:	70a3      	strb	r3, [r4, #2]
    301c:	bd38      	pop	{r3, r4, r5, pc}
		return -USB_ERR_PARAM;
    301e:	f06f 0011 	mvn.w	r0, #17
    3022:	e7f5      	b.n	3010 <usb_d_ep_enable+0x2c>
    3024:	00002c65 	.word	0x00002c65
    3028:	20000118 	.word	0x20000118
    302c:	00005361 	.word	0x00005361

00003030 <usb_d_ep_transfer>:
	}
	return usb_d_inst.ep[ep_index].xfer.req;
}

int32_t usb_d_ep_transfer(const struct usb_d_transfer *xfer)
{
    3030:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    3034:	b086      	sub	sp, #24
    3036:	4604      	mov	r4, r0
	int8_t                ep_index = _usb_d_find_ep(xfer->ep);
    3038:	7a07      	ldrb	r7, [r0, #8]
    303a:	4638      	mov	r0, r7
    303c:	4b3f      	ldr	r3, [pc, #252]	; (313c <usb_d_ep_transfer+0x10c>)
    303e:	4798      	blx	r3
	struct usb_d_ep *     ept      = &usb_d_inst.ep[ep_index];
	bool                  dir = USB_EP_GET_DIR(xfer->ep), zlp = xfer->zlp;
    3040:	7a65      	ldrb	r5, [r4, #9]
	uint32_t              len = xfer->size;
    3042:	f8d4 8004 	ldr.w	r8, [r4, #4]
	int32_t               rc;
	volatile uint8_t      state;
	volatile hal_atomic_t flags;

	if (ep_index < 0) {
    3046:	1e06      	subs	r6, r0, #0
    3048:	db72      	blt.n	3130 <usb_d_ep_transfer+0x100>
		return -USB_ERR_PARAM;
	}

	atomic_enter_critical(&flags);
    304a:	a804      	add	r0, sp, #16
    304c:	4b3c      	ldr	r3, [pc, #240]	; (3140 <usb_d_ep_transfer+0x110>)
    304e:	4798      	blx	r3
	state = ept->xfer.hdr.state;
    3050:	4b3c      	ldr	r3, [pc, #240]	; (3144 <usb_d_ep_transfer+0x114>)
    3052:	eb03 1346 	add.w	r3, r3, r6, lsl #5
    3056:	789b      	ldrb	r3, [r3, #2]
    3058:	f88d 3017 	strb.w	r3, [sp, #23]
	if (state == USB_EP_S_IDLE) {
    305c:	f89d 3017 	ldrb.w	r3, [sp, #23]
    3060:	b2db      	uxtb	r3, r3
    3062:	2b01      	cmp	r3, #1
    3064:	d011      	beq.n	308a <usb_d_ep_transfer+0x5a>
		ept->xfer.hdr.state = USB_EP_S_X_DATA;
		atomic_leave_critical(&flags);
	} else {
		atomic_leave_critical(&flags);
    3066:	a804      	add	r0, sp, #16
    3068:	4b37      	ldr	r3, [pc, #220]	; (3148 <usb_d_ep_transfer+0x118>)
    306a:	4798      	blx	r3
		switch (state) {
    306c:	f89d 3017 	ldrb.w	r3, [sp, #23]
    3070:	b2db      	uxtb	r3, r3
    3072:	2b05      	cmp	r3, #5
    3074:	d05f      	beq.n	3136 <usb_d_ep_transfer+0x106>
    3076:	2b06      	cmp	r3, #6
    3078:	d023      	beq.n	30c2 <usb_d_ep_transfer+0x92>
		case USB_EP_S_ERROR:
			return -USB_ERROR;
		case USB_EP_S_DISABLED:
			return -USB_ERR_FUNC;
		default: /* USB_EP_S_X_xxxx  */
			return USB_BUSY;
    307a:	2b00      	cmp	r3, #0
    307c:	bf0c      	ite	eq
    307e:	f06f 0012 	mvneq.w	r0, #18
    3082:	2001      	movne	r0, #1
		}
	}

	rc = _usb_d_trans(xfer->ep, dir, xfer->buf, len, zlp);
	return rc;
}
    3084:	b006      	add	sp, #24
    3086:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		ept->xfer.hdr.state = USB_EP_S_X_DATA;
    308a:	f8df a0b8 	ldr.w	sl, [pc, #184]	; 3144 <usb_d_ep_transfer+0x114>
    308e:	ea4f 1946 	mov.w	r9, r6, lsl #5
    3092:	eb0a 0309 	add.w	r3, sl, r9
    3096:	2203      	movs	r2, #3
    3098:	709a      	strb	r2, [r3, #2]
		atomic_leave_critical(&flags);
    309a:	a804      	add	r0, sp, #16
    309c:	4b2a      	ldr	r3, [pc, #168]	; (3148 <usb_d_ep_transfer+0x118>)
    309e:	4798      	blx	r3
	if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
    30a0:	f81a 3009 	ldrb.w	r3, [sl, r9]
    30a4:	b183      	cbz	r3, 30c8 <usb_d_ep_transfer+0x98>
	rc = _usb_d_trans(xfer->ep, dir, xfer->buf, len, zlp);
    30a6:	7a22      	ldrb	r2, [r4, #8]
    30a8:	3500      	adds	r5, #0
    30aa:	bf18      	it	ne
    30ac:	2501      	movne	r5, #1
	struct usb_d_transfer trans
    30ae:	6823      	ldr	r3, [r4, #0]
    30b0:	9301      	str	r3, [sp, #4]
    30b2:	f8cd 8008 	str.w	r8, [sp, #8]
    30b6:	f017 0f80 	tst.w	r7, #128	; 0x80
    30ba:	d119      	bne.n	30f0 <usb_d_ep_transfer+0xc0>
    30bc:	f002 030f 	and.w	r3, r2, #15
    30c0:	e018      	b.n	30f4 <usb_d_ep_transfer+0xc4>
			return -USB_ERROR;
    30c2:	f06f 000f 	mvn.w	r0, #15
    30c6:	e7dd      	b.n	3084 <usb_d_ep_transfer+0x54>
		uint16_t req_len = USB_GET_wLength(ept->xfer.req);
    30c8:	4b1e      	ldr	r3, [pc, #120]	; (3144 <usb_d_ep_transfer+0x114>)
    30ca:	eb03 1346 	add.w	r3, r3, r6, lsl #5
    30ce:	7cda      	ldrb	r2, [r3, #19]
    30d0:	7c9d      	ldrb	r5, [r3, #18]
    30d2:	eb05 2502 	add.w	r5, r5, r2, lsl #8
    30d6:	b2ad      	uxth	r5, r5
		if (req_len == 0) {
    30d8:	b9a5      	cbnz	r5, 3104 <usb_d_ep_transfer+0xd4>
			ept->xfer.hdr.state = USB_EP_S_X_STATUS;
    30da:	4b1a      	ldr	r3, [pc, #104]	; (3144 <usb_d_ep_transfer+0x114>)
    30dc:	eb03 1646 	add.w	r6, r3, r6, lsl #5
    30e0:	2304      	movs	r3, #4
    30e2:	70b3      	strb	r3, [r6, #2]
			len                 = 0;
    30e4:	2300      	movs	r3, #0
			zlp                 = true;
    30e6:	2501      	movs	r5, #1
	rc = _usb_d_trans(xfer->ep, dir, xfer->buf, len, zlp);
    30e8:	7a22      	ldrb	r2, [r4, #8]
	struct usb_d_transfer trans
    30ea:	6821      	ldr	r1, [r4, #0]
    30ec:	9101      	str	r1, [sp, #4]
    30ee:	9302      	str	r3, [sp, #8]
    30f0:	f042 0380 	orr.w	r3, r2, #128	; 0x80
    30f4:	f88d 300c 	strb.w	r3, [sp, #12]
    30f8:	f88d 500d 	strb.w	r5, [sp, #13]
	return _usb_d_dev_ep_trans(&trans);
    30fc:	a801      	add	r0, sp, #4
    30fe:	4b13      	ldr	r3, [pc, #76]	; (314c <usb_d_ep_transfer+0x11c>)
    3100:	4798      	blx	r3
	return rc;
    3102:	e7bf      	b.n	3084 <usb_d_ep_transfer+0x54>
    3104:	4643      	mov	r3, r8
    3106:	45a8      	cmp	r8, r5
    3108:	bf28      	it	cs
    310a:	462b      	movcs	r3, r5
			dir = (USB_GET_bmRequestType(ept->xfer.req) & USB_REQ_TYPE_IN);
    310c:	4a0d      	ldr	r2, [pc, #52]	; (3144 <usb_d_ep_transfer+0x114>)
    310e:	eb02 1646 	add.w	r6, r2, r6, lsl #5
			if (dir) {
    3112:	f996 200c 	ldrsb.w	r2, [r6, #12]
    3116:	2a00      	cmp	r2, #0
    3118:	db05      	blt.n	3126 <usb_d_ep_transfer+0xf6>
	rc = _usb_d_trans(xfer->ep, dir, xfer->buf, len, zlp);
    311a:	7a22      	ldrb	r2, [r4, #8]
	struct usb_d_transfer trans
    311c:	6821      	ldr	r1, [r4, #0]
    311e:	9101      	str	r1, [sp, #4]
    3120:	9302      	str	r3, [sp, #8]
	rc = _usb_d_trans(xfer->ep, dir, xfer->buf, len, zlp);
    3122:	2500      	movs	r5, #0
    3124:	e7ca      	b.n	30bc <usb_d_ep_transfer+0x8c>
				zlp = (req_len > len);
    3126:	429d      	cmp	r5, r3
    3128:	bf94      	ite	ls
    312a:	2500      	movls	r5, #0
    312c:	2501      	movhi	r5, #1
    312e:	e7db      	b.n	30e8 <usb_d_ep_transfer+0xb8>
		return -USB_ERR_PARAM;
    3130:	f06f 0011 	mvn.w	r0, #17
    3134:	e7a6      	b.n	3084 <usb_d_ep_transfer+0x54>
			return USB_HALTED;
    3136:	2002      	movs	r0, #2
    3138:	e7a4      	b.n	3084 <usb_d_ep_transfer+0x54>
    313a:	bf00      	nop
    313c:	00002c65 	.word	0x00002c65
    3140:	00002221 	.word	0x00002221
    3144:	20000118 	.word	0x20000118
    3148:	0000222f 	.word	0x0000222f
    314c:	000057c1 	.word	0x000057c1

00003150 <usb_d_ep_halt>:
	}
	return ERR_NONE;
}

int32_t usb_d_ep_halt(const uint8_t ep, const enum usb_ep_halt_ctrl ctrl)
{
    3150:	b538      	push	{r3, r4, r5, lr}
    3152:	4604      	mov	r4, r0
	if (ctrl == USB_EP_HALT_CLR) {
    3154:	b141      	cbz	r1, 3168 <usb_d_ep_halt+0x18>
		return _usb_d_ep_halt_clr(ep);
	} else if (ctrl == USB_EP_HALT_SET) {
    3156:	2901      	cmp	r1, #1
		return _usb_d_dev_ep_stall(ep, USB_EP_STALL_SET);
    3158:	bf0c      	ite	eq
    315a:	2101      	moveq	r1, #1
	} else {
		return _usb_d_dev_ep_stall(ep, USB_EP_STALL_GET);
    315c:	2102      	movne	r1, #2
    315e:	4b13      	ldr	r3, [pc, #76]	; (31ac <usb_d_ep_halt+0x5c>)
    3160:	4798      	blx	r3
    3162:	4603      	mov	r3, r0
	}
}
    3164:	4618      	mov	r0, r3
    3166:	bd38      	pop	{r3, r4, r5, pc}
	int8_t           ep_index = _usb_d_find_ep(ep);
    3168:	4b11      	ldr	r3, [pc, #68]	; (31b0 <usb_d_ep_halt+0x60>)
    316a:	4798      	blx	r3
	if (ep_index < 0) {
    316c:	1e05      	subs	r5, r0, #0
    316e:	db19      	blt.n	31a4 <usb_d_ep_halt+0x54>
	if (_usb_d_dev_ep_stall(ep, USB_EP_STALL_GET)) {
    3170:	2102      	movs	r1, #2
    3172:	4620      	mov	r0, r4
    3174:	4b0d      	ldr	r3, [pc, #52]	; (31ac <usb_d_ep_halt+0x5c>)
    3176:	4798      	blx	r3
    3178:	4603      	mov	r3, r0
    317a:	2800      	cmp	r0, #0
    317c:	d0f2      	beq.n	3164 <usb_d_ep_halt+0x14>
		rc = _usb_d_dev_ep_stall(ep, USB_EP_STALL_CLR);
    317e:	2100      	movs	r1, #0
    3180:	4620      	mov	r0, r4
    3182:	4b0a      	ldr	r3, [pc, #40]	; (31ac <usb_d_ep_halt+0x5c>)
    3184:	4798      	blx	r3
		if (rc < 0) {
    3186:	1e03      	subs	r3, r0, #0
    3188:	dbec      	blt.n	3164 <usb_d_ep_halt+0x14>
		ept->xfer.hdr.state  = USB_EP_S_IDLE;
    318a:	4b0a      	ldr	r3, [pc, #40]	; (31b4 <usb_d_ep_halt+0x64>)
    318c:	eb03 1345 	add.w	r3, r3, r5, lsl #5
    3190:	2201      	movs	r2, #1
    3192:	709a      	strb	r2, [r3, #2]
		ept->xfer.hdr.status = USB_XFER_UNHALT;
    3194:	2103      	movs	r1, #3
    3196:	70d9      	strb	r1, [r3, #3]
		ept->callbacks.xfer(ep, USB_XFER_UNHALT, NULL);
    3198:	69db      	ldr	r3, [r3, #28]
    319a:	2200      	movs	r2, #0
    319c:	4620      	mov	r0, r4
    319e:	4798      	blx	r3
	return ERR_NONE;
    31a0:	2300      	movs	r3, #0
    31a2:	e7df      	b.n	3164 <usb_d_ep_halt+0x14>
		return -USB_ERR_PARAM;
    31a4:	f06f 0311 	mvn.w	r3, #17
    31a8:	e7dc      	b.n	3164 <usb_d_ep_halt+0x14>
    31aa:	bf00      	nop
    31ac:	00005619 	.word	0x00005619
    31b0:	00002c65 	.word	0x00002c65
    31b4:	20000118 	.word	0x20000118

000031b8 <usb_d_ep_register_callback>:

void usb_d_ep_register_callback(const uint8_t ep, const enum usb_d_ep_cb_type type, const FUNC_PTR func)
{
    31b8:	b538      	push	{r3, r4, r5, lr}
    31ba:	460d      	mov	r5, r1
    31bc:	4614      	mov	r4, r2
	int8_t           ep_index = _usb_d_find_ep(ep);
    31be:	4b0e      	ldr	r3, [pc, #56]	; (31f8 <usb_d_ep_register_callback+0x40>)
    31c0:	4798      	blx	r3
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
	FUNC_PTR         f        = func ? (FUNC_PTR)func : (FUNC_PTR)usb_d_dummy_cb_false;
    31c2:	4b0e      	ldr	r3, [pc, #56]	; (31fc <usb_d_ep_register_callback+0x44>)
    31c4:	2c00      	cmp	r4, #0
    31c6:	bf08      	it	eq
    31c8:	461c      	moveq	r4, r3
	if (ep_index < 0) {
    31ca:	2800      	cmp	r0, #0
    31cc:	db13      	blt.n	31f6 <usb_d_ep_register_callback+0x3e>
		return;
	}
	switch (type) {
    31ce:	2d01      	cmp	r5, #1
    31d0:	d008      	beq.n	31e4 <usb_d_ep_register_callback+0x2c>
    31d2:	b115      	cbz	r5, 31da <usb_d_ep_register_callback+0x22>
    31d4:	2d02      	cmp	r5, #2
    31d6:	d00a      	beq.n	31ee <usb_d_ep_register_callback+0x36>
    31d8:	bd38      	pop	{r3, r4, r5, pc}
	case USB_D_EP_CB_SETUP:
		ept->callbacks.req = (usb_d_ep_cb_setup_t)f;
    31da:	4b09      	ldr	r3, [pc, #36]	; (3200 <usb_d_ep_register_callback+0x48>)
    31dc:	eb03 1040 	add.w	r0, r3, r0, lsl #5
    31e0:	6144      	str	r4, [r0, #20]
		break;
    31e2:	bd38      	pop	{r3, r4, r5, pc}
	case USB_D_EP_CB_MORE:
		ept->callbacks.more = (usb_d_ep_cb_more_t)f;
    31e4:	4b06      	ldr	r3, [pc, #24]	; (3200 <usb_d_ep_register_callback+0x48>)
    31e6:	eb03 1040 	add.w	r0, r3, r0, lsl #5
    31ea:	6184      	str	r4, [r0, #24]
		break;
    31ec:	bd38      	pop	{r3, r4, r5, pc}
	case USB_D_EP_CB_XFER:
		ept->callbacks.xfer = (usb_d_ep_cb_xfer_t)f;
    31ee:	4b04      	ldr	r3, [pc, #16]	; (3200 <usb_d_ep_register_callback+0x48>)
    31f0:	eb03 1040 	add.w	r0, r3, r0, lsl #5
    31f4:	61c4      	str	r4, [r0, #28]
    31f6:	bd38      	pop	{r3, r4, r5, pc}
    31f8:	00002c65 	.word	0x00002c65
    31fc:	00002ca9 	.word	0x00002ca9
    3200:	20000118 	.word	0x20000118

00003204 <assert>:
/**
 * \brief Assert function
 */
void assert(const bool condition, const char *const file, const int line)
{
	if (!(condition)) {
    3204:	b900      	cbnz	r0, 3208 <assert+0x4>
		__asm("BKPT #0");
    3206:	be00      	bkpt	0x0000
    3208:	4770      	bx	lr

0000320a <is_list_element>:
 * \brief Check whether element belongs to list
 */
bool is_list_element(const struct list_descriptor *const list, const void *const element)
{
	struct list_element *it;
	for (it = list->head; it; it = it->next) {
    320a:	6803      	ldr	r3, [r0, #0]
    320c:	b14b      	cbz	r3, 3222 <is_list_element+0x18>
		if (it == element) {
    320e:	428b      	cmp	r3, r1
    3210:	d009      	beq.n	3226 <is_list_element+0x1c>
	for (it = list->head; it; it = it->next) {
    3212:	681b      	ldr	r3, [r3, #0]
    3214:	b11b      	cbz	r3, 321e <is_list_element+0x14>
		if (it == element) {
    3216:	4299      	cmp	r1, r3
    3218:	d1fb      	bne.n	3212 <is_list_element+0x8>
			return true;
    321a:	2001      	movs	r0, #1
		}
	}

	return false;
}
    321c:	4770      	bx	lr
	return false;
    321e:	2000      	movs	r0, #0
    3220:	4770      	bx	lr
    3222:	2000      	movs	r0, #0
    3224:	4770      	bx	lr
			return true;
    3226:	2001      	movs	r0, #1
    3228:	4770      	bx	lr
	...

0000322c <list_insert_at_end>:

/**
 * \brief Insert an element at list end
 */
void list_insert_at_end(struct list_descriptor *const list, void *const element)
{
    322c:	b570      	push	{r4, r5, r6, lr}
    322e:	4605      	mov	r5, r0
    3230:	460e      	mov	r6, r1
	struct list_element *it = list->head;
    3232:	6804      	ldr	r4, [r0, #0]

	ASSERT(!is_list_element(list, element));
    3234:	4b0a      	ldr	r3, [pc, #40]	; (3260 <list_insert_at_end+0x34>)
    3236:	4798      	blx	r3
    3238:	f080 0001 	eor.w	r0, r0, #1
    323c:	2259      	movs	r2, #89	; 0x59
    323e:	4909      	ldr	r1, [pc, #36]	; (3264 <list_insert_at_end+0x38>)
    3240:	b2c0      	uxtb	r0, r0
    3242:	4b09      	ldr	r3, [pc, #36]	; (3268 <list_insert_at_end+0x3c>)
    3244:	4798      	blx	r3

	if (!list->head) {
    3246:	682b      	ldr	r3, [r5, #0]
    3248:	b91b      	cbnz	r3, 3252 <list_insert_at_end+0x26>
		list->head                             = (struct list_element *)element;
    324a:	602e      	str	r6, [r5, #0]
		((struct list_element *)element)->next = NULL;
    324c:	6033      	str	r3, [r6, #0]
		return;
    324e:	bd70      	pop	{r4, r5, r6, pc}
	}

	while (it->next) {
		it = it->next;
    3250:	461c      	mov	r4, r3
	while (it->next) {
    3252:	6823      	ldr	r3, [r4, #0]
    3254:	2b00      	cmp	r3, #0
    3256:	d1fb      	bne.n	3250 <list_insert_at_end+0x24>
	}
	it->next                               = (struct list_element *)element;
    3258:	6026      	str	r6, [r4, #0]
	((struct list_element *)element)->next = NULL;
    325a:	6033      	str	r3, [r6, #0]
    325c:	bd70      	pop	{r4, r5, r6, pc}
    325e:	bf00      	nop
    3260:	0000320b 	.word	0x0000320b
    3264:	00009834 	.word	0x00009834
    3268:	00003205 	.word	0x00003205

0000326c <ringbuffer_init>:

/**
 * \brief Ringbuffer init
 */
int32_t ringbuffer_init(struct ringbuffer *const rb, void *buf, uint32_t size)
{
    326c:	b570      	push	{r4, r5, r6, lr}
    326e:	460e      	mov	r6, r1
    3270:	4615      	mov	r5, r2
	ASSERT(rb && buf && size);
    3272:	4604      	mov	r4, r0
    3274:	b178      	cbz	r0, 3296 <ringbuffer_init+0x2a>
    3276:	b181      	cbz	r1, 329a <ringbuffer_init+0x2e>
    3278:	b1a2      	cbz	r2, 32a4 <ringbuffer_init+0x38>
    327a:	2001      	movs	r0, #1
    327c:	2232      	movs	r2, #50	; 0x32
    327e:	490d      	ldr	r1, [pc, #52]	; (32b4 <ringbuffer_init+0x48>)
    3280:	4b0d      	ldr	r3, [pc, #52]	; (32b8 <ringbuffer_init+0x4c>)
    3282:	4798      	blx	r3

	/*
	 * buf size must be aligned to power of 2
	 */
	if ((size & (size - 1)) != 0) {
    3284:	1e6b      	subs	r3, r5, #1
    3286:	421d      	tst	r5, r3
    3288:	d109      	bne.n	329e <ringbuffer_init+0x32>
		return ERR_INVALID_ARG;
	}

	/* size - 1 is faster in calculation */
	rb->size        = size - 1;
    328a:	6063      	str	r3, [r4, #4]
	rb->read_index  = 0;
    328c:	2000      	movs	r0, #0
    328e:	60a0      	str	r0, [r4, #8]
	rb->write_index = rb->read_index;
    3290:	60e0      	str	r0, [r4, #12]
	rb->buf         = (uint8_t *)buf;
    3292:	6026      	str	r6, [r4, #0]

	return ERR_NONE;
    3294:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(rb && buf && size);
    3296:	2000      	movs	r0, #0
    3298:	e7f0      	b.n	327c <ringbuffer_init+0x10>
    329a:	2000      	movs	r0, #0
    329c:	e7ee      	b.n	327c <ringbuffer_init+0x10>
		return ERR_INVALID_ARG;
    329e:	f06f 000c 	mvn.w	r0, #12
    32a2:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(rb && buf && size);
    32a4:	2232      	movs	r2, #50	; 0x32
    32a6:	4903      	ldr	r1, [pc, #12]	; (32b4 <ringbuffer_init+0x48>)
    32a8:	2000      	movs	r0, #0
    32aa:	4b03      	ldr	r3, [pc, #12]	; (32b8 <ringbuffer_init+0x4c>)
    32ac:	4798      	blx	r3
	if ((size & (size - 1)) != 0) {
    32ae:	1e6b      	subs	r3, r5, #1
    32b0:	e7eb      	b.n	328a <ringbuffer_init+0x1e>
    32b2:	bf00      	nop
    32b4:	00009854 	.word	0x00009854
    32b8:	00003205 	.word	0x00003205

000032bc <ringbuffer_get>:
/**
 * \brief Get one byte from ringbuffer
 *
 */
int32_t ringbuffer_get(struct ringbuffer *const rb, uint8_t *data)
{
    32bc:	b538      	push	{r3, r4, r5, lr}
    32be:	460d      	mov	r5, r1
	ASSERT(rb && data);
    32c0:	4604      	mov	r4, r0
    32c2:	b1a0      	cbz	r0, 32ee <ringbuffer_get+0x32>
    32c4:	1c08      	adds	r0, r1, #0
    32c6:	bf18      	it	ne
    32c8:	2001      	movne	r0, #1
    32ca:	224a      	movs	r2, #74	; 0x4a
    32cc:	490a      	ldr	r1, [pc, #40]	; (32f8 <ringbuffer_get+0x3c>)
    32ce:	4b0b      	ldr	r3, [pc, #44]	; (32fc <ringbuffer_get+0x40>)
    32d0:	4798      	blx	r3

	if (rb->write_index != rb->read_index) {
    32d2:	68a3      	ldr	r3, [r4, #8]
    32d4:	68e2      	ldr	r2, [r4, #12]
    32d6:	429a      	cmp	r2, r3
    32d8:	d00b      	beq.n	32f2 <ringbuffer_get+0x36>
		*data = rb->buf[rb->read_index & rb->size];
    32da:	6862      	ldr	r2, [r4, #4]
    32dc:	4013      	ands	r3, r2
    32de:	6822      	ldr	r2, [r4, #0]
    32e0:	5cd3      	ldrb	r3, [r2, r3]
    32e2:	702b      	strb	r3, [r5, #0]
		rb->read_index++;
    32e4:	68a3      	ldr	r3, [r4, #8]
    32e6:	3301      	adds	r3, #1
    32e8:	60a3      	str	r3, [r4, #8]
		return ERR_NONE;
    32ea:	2000      	movs	r0, #0
    32ec:	bd38      	pop	{r3, r4, r5, pc}
    32ee:	2000      	movs	r0, #0
    32f0:	e7eb      	b.n	32ca <ringbuffer_get+0xe>
	}

	return ERR_NOT_FOUND;
    32f2:	f06f 0009 	mvn.w	r0, #9
}
    32f6:	bd38      	pop	{r3, r4, r5, pc}
    32f8:	00009854 	.word	0x00009854
    32fc:	00003205 	.word	0x00003205

00003300 <ringbuffer_put>:
/**
 * \brief Put one byte to ringbuffer
 *
 */
int32_t ringbuffer_put(struct ringbuffer *const rb, uint8_t data)
{
    3300:	b538      	push	{r3, r4, r5, lr}
    3302:	460d      	mov	r5, r1
	ASSERT(rb);
    3304:	4604      	mov	r4, r0
    3306:	225b      	movs	r2, #91	; 0x5b
    3308:	490b      	ldr	r1, [pc, #44]	; (3338 <ringbuffer_put+0x38>)
    330a:	3000      	adds	r0, #0
    330c:	bf18      	it	ne
    330e:	2001      	movne	r0, #1
    3310:	4b0a      	ldr	r3, [pc, #40]	; (333c <ringbuffer_put+0x3c>)
    3312:	4798      	blx	r3

	rb->buf[rb->write_index & rb->size] = data;
    3314:	68e3      	ldr	r3, [r4, #12]
    3316:	6862      	ldr	r2, [r4, #4]
    3318:	4013      	ands	r3, r2
    331a:	6822      	ldr	r2, [r4, #0]
    331c:	54d5      	strb	r5, [r2, r3]

	/*
	 * buffer full strategy: new data will overwrite the oldest data in
	 * the buffer
	 */
	if ((rb->write_index - rb->read_index) > rb->size) {
    331e:	68e3      	ldr	r3, [r4, #12]
    3320:	6861      	ldr	r1, [r4, #4]
    3322:	68a2      	ldr	r2, [r4, #8]
    3324:	1a9a      	subs	r2, r3, r2
    3326:	428a      	cmp	r2, r1
		rb->read_index = rb->write_index - rb->size;
    3328:	bf84      	itt	hi
    332a:	1a59      	subhi	r1, r3, r1
    332c:	60a1      	strhi	r1, [r4, #8]
	}

	rb->write_index++;
    332e:	3301      	adds	r3, #1
    3330:	60e3      	str	r3, [r4, #12]

	return ERR_NONE;
}
    3332:	2000      	movs	r0, #0
    3334:	bd38      	pop	{r3, r4, r5, pc}
    3336:	bf00      	nop
    3338:	00009854 	.word	0x00009854
    333c:	00003205 	.word	0x00003205

00003340 <ringbuffer_num>:

/**
 * \brief Return the element number of ringbuffer
 */
uint32_t ringbuffer_num(const struct ringbuffer *const rb)
{
    3340:	b510      	push	{r4, lr}
	ASSERT(rb);
    3342:	4604      	mov	r4, r0
    3344:	2271      	movs	r2, #113	; 0x71
    3346:	4905      	ldr	r1, [pc, #20]	; (335c <ringbuffer_num+0x1c>)
    3348:	3000      	adds	r0, #0
    334a:	bf18      	it	ne
    334c:	2001      	movne	r0, #1
    334e:	4b04      	ldr	r3, [pc, #16]	; (3360 <ringbuffer_num+0x20>)
    3350:	4798      	blx	r3

	return rb->write_index - rb->read_index;
    3352:	68e0      	ldr	r0, [r4, #12]
    3354:	68a3      	ldr	r3, [r4, #8]
}
    3356:	1ac0      	subs	r0, r0, r3
    3358:	bd10      	pop	{r4, pc}
    335a:	bf00      	nop
    335c:	00009854 	.word	0x00009854
    3360:	00003205 	.word	0x00003205

00003364 <_init_chip>:

/**
 * \brief Initialize the hardware abstraction layer
 */
void _init_chip(void)
{
    3364:	b508      	push	{r3, lr}
}

static inline void hri_nvmctrl_set_CTRLA_RWS_bf(const void *const hw, hri_nvmctrl_ctrla_reg_t mask)
{
	NVMCTRL_CRITICAL_SECTION_ENTER();
	((Nvmctrl *)hw)->CTRLA.reg |= NVMCTRL_CTRLA_RWS(mask);
    3366:	4a07      	ldr	r2, [pc, #28]	; (3384 <_init_chip+0x20>)
    3368:	8813      	ldrh	r3, [r2, #0]
    336a:	b29b      	uxth	r3, r3
    336c:	8013      	strh	r3, [r2, #0]
	hri_nvmctrl_set_CTRLA_RWS_bf(NVMCTRL, CONF_NVM_WAIT_STATE);

	_osc32kctrl_init_sources();
    336e:	4b06      	ldr	r3, [pc, #24]	; (3388 <_init_chip+0x24>)
    3370:	4798      	blx	r3
	_oscctrl_init_sources();
    3372:	4b06      	ldr	r3, [pc, #24]	; (338c <_init_chip+0x28>)
    3374:	4798      	blx	r3
	_mclk_init();
    3376:	4b06      	ldr	r3, [pc, #24]	; (3390 <_init_chip+0x2c>)
    3378:	4798      	blx	r3
#if _GCLK_INIT_1ST
    337a:	4b06      	ldr	r3, [pc, #24]	; (3394 <_init_chip+0x30>)
    337c:	4798      	blx	r3
	_gclk_init_generators_by_fref(_GCLK_INIT_1ST);
    337e:	4b06      	ldr	r3, [pc, #24]	; (3398 <_init_chip+0x34>)
    3380:	4798      	blx	r3
    3382:	bd08      	pop	{r3, pc}
    3384:	41004000 	.word	0x41004000
    3388:	00003619 	.word	0x00003619
    338c:	00003639 	.word	0x00003639
    3390:	0000360d 	.word	0x0000360d
    3394:	000035f5 	.word	0x000035f5
    3398:	00003655 	.word	0x00003655

0000339c <_ext_irq_handler>:

/**
 * \brief Inter EIC interrupt handler
 */
static void _ext_irq_handler(void)
{
    339c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    33a0:	b082      	sub	sp, #8
	return tmp;
}

static inline hri_eic_intflag_reg_t hri_eic_read_INTFLAG_reg(const void *const hw)
{
	return ((Eic *)hw)->INTFLAG.reg;
    33a2:	4b32      	ldr	r3, [pc, #200]	; (346c <_ext_irq_handler+0xd0>)
    33a4:	695a      	ldr	r2, [r3, #20]
	volatile uint32_t flags = hri_eic_read_INTFLAG_reg(EIC);
    33a6:	9201      	str	r2, [sp, #4]
	int8_t            pos;
	uint32_t          pin = INVALID_PIN_NUMBER;

	hri_eic_clear_INTFLAG_reg(EIC, flags);
    33a8:	9a01      	ldr	r2, [sp, #4]
}

static inline void hri_eic_clear_INTFLAG_reg(const void *const hw, hri_eic_intflag_reg_t mask)
{
	((Eic *)hw)->INTFLAG.reg = mask;
    33aa:	615a      	str	r2, [r3, #20]

	ASSERT(callback);
    33ac:	4b30      	ldr	r3, [pc, #192]	; (3470 <_ext_irq_handler+0xd4>)
    33ae:	6818      	ldr	r0, [r3, #0]
    33b0:	f44f 7294 	mov.w	r2, #296	; 0x128
    33b4:	492f      	ldr	r1, [pc, #188]	; (3474 <_ext_irq_handler+0xd8>)
    33b6:	3000      	adds	r0, #0
    33b8:	bf18      	it	ne
    33ba:	2001      	movne	r0, #1
    33bc:	4b2e      	ldr	r3, [pc, #184]	; (3478 <_ext_irq_handler+0xdc>)
    33be:	4798      	blx	r3

	while (flags) {
    33c0:	9b01      	ldr	r3, [sp, #4]
    33c2:	2b00      	cmp	r3, #0
    33c4:	d04e      	beq.n	3464 <_ext_irq_handler+0xc8>
    33c6:	f04f 36ff 	mov.w	r6, #4294967295
			uint8_t lower = 0, middle, upper = EXT_IRQ_AMOUNT;

			while (upper >= lower) {
				middle = (upper + lower) >> 1;
				if (_map[middle].extint == pos) {
					pin = _map[middle].pin;
    33ca:	4d2c      	ldr	r5, [pc, #176]	; (347c <_ext_irq_handler+0xe0>)
					upper = middle - 1;
				}
			}

			if (INVALID_PIN_NUMBER != pin) {
				callback(pin);
    33cc:	4f28      	ldr	r7, [pc, #160]	; (3470 <_ext_irq_handler+0xd4>)
	return ((Eic *)hw)->INTFLAG.reg;
    33ce:	f8df 809c 	ldr.w	r8, [pc, #156]	; 346c <_ext_irq_handler+0xd0>
    33d2:	e03c      	b.n	344e <_ext_irq_handler+0xb2>
					pin = _map[middle].pin;
    33d4:	eb05 0ece 	add.w	lr, r5, lr, lsl #3
    33d8:	f8de 6004 	ldr.w	r6, [lr, #4]
			if (INVALID_PIN_NUMBER != pin) {
    33dc:	f1b6 3fff 	cmp.w	r6, #4294967295
    33e0:	d002      	beq.n	33e8 <_ext_irq_handler+0x4c>
				callback(pin);
    33e2:	4630      	mov	r0, r6
    33e4:	683b      	ldr	r3, [r7, #0]
    33e6:	4798      	blx	r3
			}
			flags &= ~(1ul << pos);
    33e8:	9b01      	ldr	r3, [sp, #4]
    33ea:	2201      	movs	r2, #1
    33ec:	fa02 f404 	lsl.w	r4, r2, r4
    33f0:	ea23 0404 	bic.w	r4, r3, r4
    33f4:	9401      	str	r4, [sp, #4]
			pos = ffs(flags) - 1;
    33f6:	9b01      	ldr	r3, [sp, #4]
    33f8:	fa93 fea3 	rbit	lr, r3
    33fc:	fabe fe8e 	clz	lr, lr
    3400:	2b00      	cmp	r3, #0
		while (-1 != pos) {
    3402:	bf08      	it	eq
    3404:	f04f 3eff 	moveq.w	lr, #4294967295
    3408:	d019      	beq.n	343e <_ext_irq_handler+0xa2>
				if (_map[middle].extint == pos) {
    340a:	4674      	mov	r4, lr
    340c:	f1be 0f02 	cmp.w	lr, #2
    3410:	d0e0      	beq.n	33d4 <_ext_irq_handler+0x38>
    3412:	2202      	movs	r2, #2
    3414:	4613      	mov	r3, r2
    3416:	2004      	movs	r0, #4
    3418:	2100      	movs	r1, #0
				if (_map[middle].extint < pos) {
    341a:	4294      	cmp	r4, r2
					lower = middle + 1;
    341c:	bfc7      	ittee	gt
    341e:	3301      	addgt	r3, #1
    3420:	b2d9      	uxtbgt	r1, r3
					upper = middle - 1;
    3422:	f103 33ff 	addle.w	r3, r3, #4294967295
    3426:	b2d8      	uxtble	r0, r3
			while (upper >= lower) {
    3428:	4281      	cmp	r1, r0
    342a:	d8d7      	bhi.n	33dc <_ext_irq_handler+0x40>
				middle = (upper + lower) >> 1;
    342c:	1843      	adds	r3, r0, r1
    342e:	f3c3 0347 	ubfx	r3, r3, #1, #8
    3432:	469e      	mov	lr, r3
				if (_map[middle].extint == pos) {
    3434:	f815 2033 	ldrb.w	r2, [r5, r3, lsl #3]
    3438:	42a2      	cmp	r2, r4
    343a:	d1ee      	bne.n	341a <_ext_irq_handler+0x7e>
    343c:	e7ca      	b.n	33d4 <_ext_irq_handler+0x38>
    343e:	f8d8 3014 	ldr.w	r3, [r8, #20]
		}
		flags = hri_eic_read_INTFLAG_reg(EIC);
    3442:	9301      	str	r3, [sp, #4]
		hri_eic_clear_INTFLAG_reg(EIC, flags);
    3444:	9b01      	ldr	r3, [sp, #4]
	((Eic *)hw)->INTFLAG.reg = mask;
    3446:	f8c8 3014 	str.w	r3, [r8, #20]
	while (flags) {
    344a:	9b01      	ldr	r3, [sp, #4]
    344c:	b153      	cbz	r3, 3464 <_ext_irq_handler+0xc8>
		pos = ffs(flags) - 1;
    344e:	9b01      	ldr	r3, [sp, #4]
    3450:	fa93 fea3 	rbit	lr, r3
    3454:	fabe fe8e 	clz	lr, lr
    3458:	2b00      	cmp	r3, #0
		while (-1 != pos) {
    345a:	bf08      	it	eq
    345c:	f04f 3eff 	moveq.w	lr, #4294967295
    3460:	d1d3      	bne.n	340a <_ext_irq_handler+0x6e>
    3462:	e7ec      	b.n	343e <_ext_irq_handler+0xa2>
	}
}
    3464:	b002      	add	sp, #8
    3466:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    346a:	bf00      	nop
    346c:	40002800 	.word	0x40002800
    3470:	200002b8 	.word	0x200002b8
    3474:	00009898 	.word	0x00009898
    3478:	00003205 	.word	0x00003205
    347c:	00009878 	.word	0x00009878

00003480 <_ext_irq_init>:
	while (((Eic *)hw)->SYNCBUSY.reg & reg) {
    3480:	4a37      	ldr	r2, [pc, #220]	; (3560 <_ext_irq_init+0xe0>)
    3482:	6853      	ldr	r3, [r2, #4]
    3484:	f013 0f01 	tst.w	r3, #1
    3488:	d1fb      	bne.n	3482 <_ext_irq_init+0x2>
    348a:	4a35      	ldr	r2, [pc, #212]	; (3560 <_ext_irq_init+0xe0>)
    348c:	6853      	ldr	r3, [r2, #4]
    348e:	f013 0f03 	tst.w	r3, #3
    3492:	d1fb      	bne.n	348c <_ext_irq_init+0xc>

static inline bool hri_eic_get_CTRLA_ENABLE_bit(const void *const hw)
{
	uint8_t tmp;
	hri_eic_wait_for_sync(hw, EIC_SYNCBUSY_SWRST | EIC_SYNCBUSY_ENABLE);
	tmp = ((Eic *)hw)->CTRLA.reg;
    3494:	4b32      	ldr	r3, [pc, #200]	; (3560 <_ext_irq_init+0xe0>)
    3496:	781b      	ldrb	r3, [r3, #0]
	if (hri_eic_get_CTRLA_ENABLE_bit(EIC)) {
    3498:	f013 0f02 	tst.w	r3, #2
    349c:	d15d      	bne.n	355a <_ext_irq_init+0xda>
	while (((Eic *)hw)->SYNCBUSY.reg & reg) {
    349e:	4a30      	ldr	r2, [pc, #192]	; (3560 <_ext_irq_init+0xe0>)
    34a0:	6853      	ldr	r3, [r2, #4]
    34a2:	f013 0f01 	tst.w	r3, #1
    34a6:	d1fb      	bne.n	34a0 <_ext_irq_init+0x20>
	((Eic *)hw)->CTRLA.reg |= EIC_CTRLA_SWRST;
    34a8:	4a2d      	ldr	r2, [pc, #180]	; (3560 <_ext_irq_init+0xe0>)
    34aa:	7813      	ldrb	r3, [r2, #0]
    34ac:	f043 0301 	orr.w	r3, r3, #1
    34b0:	7013      	strb	r3, [r2, #0]
	while (((Eic *)hw)->SYNCBUSY.reg & reg) {
    34b2:	6853      	ldr	r3, [r2, #4]
    34b4:	f013 0f01 	tst.w	r3, #1
    34b8:	d1fb      	bne.n	34b2 <_ext_irq_init+0x32>
    34ba:	4a29      	ldr	r2, [pc, #164]	; (3560 <_ext_irq_init+0xe0>)
    34bc:	6853      	ldr	r3, [r2, #4]
    34be:	f013 0f03 	tst.w	r3, #3
    34c2:	d1fb      	bne.n	34bc <_ext_irq_init+0x3c>
static inline void hri_eic_write_CTRLA_CKSEL_bit(const void *const hw, bool value)
{
	uint8_t tmp;
	EIC_CRITICAL_SECTION_ENTER();
	hri_eic_wait_for_sync(hw, EIC_SYNCBUSY_MASK);
	tmp = ((Eic *)hw)->CTRLA.reg;
    34c4:	4b26      	ldr	r3, [pc, #152]	; (3560 <_ext_irq_init+0xe0>)
    34c6:	781a      	ldrb	r2, [r3, #0]
	tmp &= ~EIC_CTRLA_CKSEL;
    34c8:	f002 02ef 	and.w	r2, r2, #239	; 0xef
	tmp |= value << EIC_CTRLA_CKSEL_Pos;
	((Eic *)hw)->CTRLA.reg = tmp;
    34cc:	701a      	strb	r2, [r3, #0]
}

static inline void hri_eic_write_NMICTRL_reg(const void *const hw, hri_eic_nmictrl_reg_t data)
{
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->NMICTRL.reg = data;
    34ce:	2200      	movs	r2, #0
    34d0:	705a      	strb	r2, [r3, #1]
}

static inline void hri_eic_write_EVCTRL_reg(const void *const hw, hri_eic_evctrl_reg_t data)
{
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->EVCTRL.reg = data;
    34d2:	609a      	str	r2, [r3, #8]
}

static inline void hri_eic_write_ASYNCH_reg(const void *const hw, hri_eic_asynch_reg_t data)
{
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->ASYNCH.reg = data;
    34d4:	619a      	str	r2, [r3, #24]
}

static inline void hri_eic_write_DEBOUNCEN_reg(const void *const hw, hri_eic_debouncen_reg_t data)
{
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->DEBOUNCEN.reg = data;
    34d6:	210a      	movs	r1, #10
    34d8:	6319      	str	r1, [r3, #48]	; 0x30
}

static inline void hri_eic_write_DPRESCALER_reg(const void *const hw, hri_eic_dprescaler_reg_t data)
{
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->DPRESCALER.reg = data;
    34da:	635a      	str	r2, [r3, #52]	; 0x34
	((Eic *)hw)->CONFIG[index].reg = data;
    34dc:	f241 1111 	movw	r1, #4369	; 0x1111
    34e0:	61d9      	str	r1, [r3, #28]
    34e2:	621a      	str	r2, [r3, #32]
	while (((Eic *)hw)->SYNCBUSY.reg & reg) {
    34e4:	461a      	mov	r2, r3
    34e6:	6853      	ldr	r3, [r2, #4]
    34e8:	f013 0f03 	tst.w	r3, #3
    34ec:	d1fb      	bne.n	34e6 <_ext_irq_init+0x66>
	((Eic *)hw)->CTRLA.reg |= EIC_CTRLA_ENABLE;
    34ee:	4a1c      	ldr	r2, [pc, #112]	; (3560 <_ext_irq_init+0xe0>)
    34f0:	7813      	ldrb	r3, [r2, #0]
    34f2:	f043 0302 	orr.w	r3, r3, #2
    34f6:	7013      	strb	r3, [r2, #0]
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    34f8:	4b1a      	ldr	r3, [pc, #104]	; (3564 <_ext_irq_init+0xe4>)
    34fa:	f44f 5280 	mov.w	r2, #4096	; 0x1000
    34fe:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  __ASM volatile ("dsb 0xF":::"memory");
    3502:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    3506:	f3bf 8f6f 	isb	sy
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    350a:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    350e:	601a      	str	r2, [r3, #0]
    NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    3510:	f44f 5200 	mov.w	r2, #8192	; 0x2000
    3514:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  __ASM volatile ("dsb 0xF":::"memory");
    3518:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    351c:	f3bf 8f6f 	isb	sy
    NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    3520:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    3524:	601a      	str	r2, [r3, #0]
    NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    3526:	f44f 4280 	mov.w	r2, #16384	; 0x4000
    352a:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  __ASM volatile ("dsb 0xF":::"memory");
    352e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    3532:	f3bf 8f6f 	isb	sy
    NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    3536:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    353a:	601a      	str	r2, [r3, #0]
    NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    353c:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    3540:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  __ASM volatile ("dsb 0xF":::"memory");
    3544:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    3548:	f3bf 8f6f 	isb	sy
    NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    354c:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    3550:	601a      	str	r2, [r3, #0]
	callback = cb;
    3552:	4b05      	ldr	r3, [pc, #20]	; (3568 <_ext_irq_init+0xe8>)
    3554:	6018      	str	r0, [r3, #0]
	return ERR_NONE;
    3556:	2000      	movs	r0, #0
    3558:	4770      	bx	lr
		return ERR_DENIED;
    355a:	f06f 0010 	mvn.w	r0, #16
}
    355e:	4770      	bx	lr
    3560:	40002800 	.word	0x40002800
    3564:	e000e100 	.word	0xe000e100
    3568:	200002b8 	.word	0x200002b8

0000356c <_ext_irq_enable>:
		if (_map[i].pin == pin) {
    356c:	2810      	cmp	r0, #16
    356e:	d00e      	beq.n	358e <_ext_irq_enable+0x22>
    3570:	2811      	cmp	r0, #17
    3572:	d008      	beq.n	3586 <_ext_irq_enable+0x1a>
    3574:	2812      	cmp	r0, #18
    3576:	d008      	beq.n	358a <_ext_irq_enable+0x1e>
    3578:	2813      	cmp	r0, #19
    357a:	bf08      	it	eq
    357c:	2203      	moveq	r2, #3
    357e:	d007      	beq.n	3590 <_ext_irq_enable+0x24>
		return -1;
    3580:	f04f 30ff 	mov.w	r0, #4294967295
    3584:	4770      	bx	lr
		if (_map[i].pin == pin) {
    3586:	2201      	movs	r2, #1
    3588:	e002      	b.n	3590 <_ext_irq_enable+0x24>
    358a:	2202      	movs	r2, #2
    358c:	e000      	b.n	3590 <_ext_irq_enable+0x24>
    358e:	2200      	movs	r2, #0
			extint = _map[i].extint;
    3590:	4b0a      	ldr	r3, [pc, #40]	; (35bc <_ext_irq_enable+0x50>)
    3592:	f813 2032 	ldrb.w	r2, [r3, r2, lsl #3]
	if (INVALID_EXTINT_NUMBER == extint) {
    3596:	2aff      	cmp	r2, #255	; 0xff
    3598:	d00d      	beq.n	35b6 <_ext_irq_enable+0x4a>
	if (enable) {
    359a:	b931      	cbnz	r1, 35aa <_ext_irq_enable+0x3e>
		hri_eic_clear_INTEN_reg(EIC, 1ul << extint);
    359c:	2301      	movs	r3, #1
    359e:	4093      	lsls	r3, r2
	((Eic *)hw)->INTENCLR.reg = mask;
    35a0:	4a07      	ldr	r2, [pc, #28]	; (35c0 <_ext_irq_enable+0x54>)
    35a2:	60d3      	str	r3, [r2, #12]
	((Eic *)hw)->INTFLAG.reg = mask;
    35a4:	6153      	str	r3, [r2, #20]
	return ERR_NONE;
    35a6:	2000      	movs	r0, #0
    35a8:	4770      	bx	lr
		hri_eic_set_INTEN_reg(EIC, 1ul << extint);
    35aa:	2301      	movs	r3, #1
    35ac:	4093      	lsls	r3, r2
	((Eic *)hw)->INTENSET.reg = mask;
    35ae:	4a04      	ldr	r2, [pc, #16]	; (35c0 <_ext_irq_enable+0x54>)
    35b0:	6113      	str	r3, [r2, #16]
	return ERR_NONE;
    35b2:	2000      	movs	r0, #0
    35b4:	4770      	bx	lr
		return -1;
    35b6:	f04f 30ff 	mov.w	r0, #4294967295
}
    35ba:	4770      	bx	lr
    35bc:	00009878 	.word	0x00009878
    35c0:	40002800 	.word	0x40002800

000035c4 <EIC_0_Handler>:

/**
* \brief EIC interrupt handler
*/
void EIC_0_Handler(void)
{
    35c4:	b508      	push	{r3, lr}
	_ext_irq_handler();
    35c6:	4b01      	ldr	r3, [pc, #4]	; (35cc <EIC_0_Handler+0x8>)
    35c8:	4798      	blx	r3
    35ca:	bd08      	pop	{r3, pc}
    35cc:	0000339d 	.word	0x0000339d

000035d0 <EIC_1_Handler>:
} /**
 * \brief EIC interrupt handler
 */
void EIC_1_Handler(void)
{
    35d0:	b508      	push	{r3, lr}
	_ext_irq_handler();
    35d2:	4b01      	ldr	r3, [pc, #4]	; (35d8 <EIC_1_Handler+0x8>)
    35d4:	4798      	blx	r3
    35d6:	bd08      	pop	{r3, pc}
    35d8:	0000339d 	.word	0x0000339d

000035dc <EIC_2_Handler>:
} /**
 * \brief EIC interrupt handler
 */
void EIC_2_Handler(void)
{
    35dc:	b508      	push	{r3, lr}
	_ext_irq_handler();
    35de:	4b01      	ldr	r3, [pc, #4]	; (35e4 <EIC_2_Handler+0x8>)
    35e0:	4798      	blx	r3
    35e2:	bd08      	pop	{r3, pc}
    35e4:	0000339d 	.word	0x0000339d

000035e8 <EIC_3_Handler>:
} /**
 * \brief EIC interrupt handler
 */
void EIC_3_Handler(void)
{
    35e8:	b508      	push	{r3, lr}
	_ext_irq_handler();
    35ea:	4b01      	ldr	r3, [pc, #4]	; (35f0 <EIC_3_Handler+0x8>)
    35ec:	4798      	blx	r3
    35ee:	bd08      	pop	{r3, pc}
    35f0:	0000339d 	.word	0x0000339d

000035f4 <_gclk_init_generators>:
}

static inline void hri_gclk_write_GENCTRL_reg(const void *const hw, uint8_t index, hri_gclk_genctrl_reg_t data)
{
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->GENCTRL[index].reg = data;
    35f4:	4b03      	ldr	r3, [pc, #12]	; (3604 <_gclk_init_generators+0x10>)
    35f6:	4a04      	ldr	r2, [pc, #16]	; (3608 <_gclk_init_generators+0x14>)
    35f8:	621a      	str	r2, [r3, #32]
    35fa:	3205      	adds	r2, #5
    35fc:	625a      	str	r2, [r3, #36]	; 0x24
    35fe:	3a01      	subs	r2, #1
    3600:	62da      	str	r2, [r3, #44]	; 0x2c
    3602:	4770      	bx	lr
    3604:	40001c00 	.word	0x40001c00
    3608:	00010101 	.word	0x00010101

0000360c <_mclk_init>:
}

static inline void hri_mclk_write_CPUDIV_reg(const void *const hw, hri_mclk_cpudiv_reg_t data)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->CPUDIV.reg = data;
    360c:	2201      	movs	r2, #1
    360e:	4b01      	ldr	r3, [pc, #4]	; (3614 <_mclk_init+0x8>)
    3610:	715a      	strb	r2, [r3, #5]
    3612:	4770      	bx	lr
    3614:	40000800 	.word	0x40000800

00003618 <_osc32kctrl_init_sources>:
}

static inline void hri_osc32kctrl_write_XOSC32K_reg(const void *const hw, hri_osc32kctrl_xosc32k_reg_t data)
{
	OSC32KCTRL_CRITICAL_SECTION_ENTER();
	((Osc32kctrl *)hw)->XOSC32K.reg = data;
    3618:	4b06      	ldr	r3, [pc, #24]	; (3634 <_osc32kctrl_init_sources+0x1c>)
    361a:	f242 028e 	movw	r2, #8334	; 0x208e
    361e:	829a      	strh	r2, [r3, #20]
}

static inline void hri_osc32kctrl_write_CFDCTRL_reg(const void *const hw, hri_osc32kctrl_cfdctrl_reg_t data)
{
	OSC32KCTRL_CRITICAL_SECTION_ENTER();
	((Osc32kctrl *)hw)->CFDCTRL.reg = data;
    3620:	2200      	movs	r2, #0
    3622:	759a      	strb	r2, [r3, #22]
}

static inline void hri_osc32kctrl_write_EVCTRL_reg(const void *const hw, hri_osc32kctrl_evctrl_reg_t data)
{
	OSC32KCTRL_CRITICAL_SECTION_ENTER();
	((Osc32kctrl *)hw)->EVCTRL.reg = data;
    3624:	75da      	strb	r2, [r3, #23]
}

static inline hri_osc32kctrl_osculp32k_reg_t hri_osc32kctrl_read_OSCULP32K_CALIB_bf(const void *const hw)
{
	uint32_t tmp;
	tmp = ((Osc32kctrl *)hw)->OSCULP32K.reg;
    3626:	69d9      	ldr	r1, [r3, #28]
	calib = hri_osc32kctrl_read_OSCULP32K_CALIB_bf(hw);
	hri_osc32kctrl_write_OSCULP32K_reg(hw,
#if CONF_OSCULP32K_CALIB_ENABLE == 1
	                                   OSC32KCTRL_OSCULP32K_CALIB(CONF_OSCULP32K_CALIB)
#else
	                                   OSC32KCTRL_OSCULP32K_CALIB(calib)
    3628:	f401 517c 	and.w	r1, r1, #16128	; 0x3f00
}

static inline void hri_osc32kctrl_write_OSCULP32K_reg(const void *const hw, hri_osc32kctrl_osculp32k_reg_t data)
{
	OSC32KCTRL_CRITICAL_SECTION_ENTER();
	((Osc32kctrl *)hw)->OSCULP32K.reg = data;
    362c:	61d9      	str	r1, [r3, #28]
	((Osc32kctrl *)hw)->RTCCTRL.reg = data;
    362e:	741a      	strb	r2, [r3, #16]
    3630:	4770      	bx	lr
    3632:	bf00      	nop
    3634:	40001400 	.word	0x40001400

00003638 <_oscctrl_init_sources>:
}

static inline void hri_oscctrl_write_XOSCCTRL_reg(const void *const hw, uint8_t index, hri_oscctrl_xoscctrl_reg_t data)
{
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->XOSCCTRL[index].reg = data;
    3638:	4a04      	ldr	r2, [pc, #16]	; (364c <_oscctrl_init_sources+0x14>)
    363a:	4b05      	ldr	r3, [pc, #20]	; (3650 <_oscctrl_init_sources+0x18>)
    363c:	619a      	str	r2, [r3, #24]
	return (((Oscctrl *)hw)->STATUS.reg & OSCCTRL_STATUS_XOSCRDY0) >> OSCCTRL_STATUS_XOSCRDY0_Pos;
}

static inline bool hri_oscctrl_get_STATUS_XOSCRDY1_bit(const void *const hw)
{
	return (((Oscctrl *)hw)->STATUS.reg & OSCCTRL_STATUS_XOSCRDY1) >> OSCCTRL_STATUS_XOSCRDY1_Pos;
    363e:	461a      	mov	r2, r3
    3640:	6913      	ldr	r3, [r2, #16]
	                                   | (CONF_XOSC1_ENABLE << OSCCTRL_XOSCCTRL_ENABLE_Pos));
#endif

#if CONF_XOSC1_CONFIG == 1
#if CONF_XOSC1_ENABLE == 1
	while (!hri_oscctrl_get_STATUS_XOSCRDY1_bit(hw))
    3642:	f013 0f02 	tst.w	r3, #2
    3646:	d0fb      	beq.n	3640 <_oscctrl_init_sources+0x8>
	hri_oscctrl_set_XOSCCTRL_ONDEMAND_bit(hw, 1);
#endif
#endif

	(void)hw;
}
    3648:	4770      	bx	lr
    364a:	bf00      	nop
    364c:	03002606 	.word	0x03002606
    3650:	40001000 	.word	0x40001000

00003654 <_oscctrl_init_referenced_generators>:
	tmp = ((Gclk *)hw)->GENCTRL[index].reg;
    3654:	4a2b      	ldr	r2, [pc, #172]	; (3704 <_oscctrl_init_referenced_generators+0xb0>)
    3656:	6a13      	ldr	r3, [r2, #32]
	tmp &= ~GCLK_GENCTRL_SRC_Msk;
    3658:	f023 030f 	bic.w	r3, r3, #15
	tmp |= GCLK_GENCTRL_SRC(data);
    365c:	f043 0304 	orr.w	r3, r3, #4
	((Gclk *)hw)->GENCTRL[index].reg = tmp;
    3660:	6213      	str	r3, [r2, #32]
	((Oscctrl *)hw)->DFLLCTRLA.reg = data;
    3662:	4b29      	ldr	r3, [pc, #164]	; (3708 <_oscctrl_init_referenced_generators+0xb4>)
    3664:	2200      	movs	r2, #0
    3666:	771a      	strb	r2, [r3, #28]
	((Oscctrl *)hw)->DFLLMUL.reg = data;
    3668:	4a28      	ldr	r2, [pc, #160]	; (370c <_oscctrl_init_referenced_generators+0xb8>)
    366a:	629a      	str	r2, [r3, #40]	; 0x28
	tmp = ((Oscctrl *)hw)->DFLLSYNC.reg;
    366c:	461a      	mov	r2, r3
    366e:	f892 302c 	ldrb.w	r3, [r2, #44]	; 0x2c
#endif

	hri_oscctrl_write_DFLLMUL_reg(hw,
	                              OSCCTRL_DFLLMUL_CSTEP(CONF_DFLL_CSTEP) | OSCCTRL_DFLLMUL_FSTEP(CONF_DFLL_FSTEP)
	                                  | OSCCTRL_DFLLMUL_MUL(CONF_DFLL_MUL));
	while (hri_oscctrl_get_DFLLSYNC_DFLLMUL_bit(hw))
    3672:	f013 0f10 	tst.w	r3, #16
    3676:	d1fa      	bne.n	366e <_oscctrl_init_referenced_generators+0x1a>
	((Oscctrl *)hw)->DFLLCTRLB.reg = data;
    3678:	2200      	movs	r2, #0
    367a:	4b23      	ldr	r3, [pc, #140]	; (3708 <_oscctrl_init_referenced_generators+0xb4>)
    367c:	f883 2020 	strb.w	r2, [r3, #32]
	tmp = ((Oscctrl *)hw)->DFLLSYNC.reg;
    3680:	461a      	mov	r2, r3
    3682:	f892 302c 	ldrb.w	r3, [r2, #44]	; 0x2c
		;

	hri_oscctrl_write_DFLLCTRLB_reg(hw, 0);
	while (hri_oscctrl_get_DFLLSYNC_DFLLCTRLB_bit(hw))
    3686:	f013 0f04 	tst.w	r3, #4
    368a:	d1fa      	bne.n	3682 <_oscctrl_init_referenced_generators+0x2e>
	((Oscctrl *)hw)->DFLLCTRLA.reg = data;
    368c:	2202      	movs	r2, #2
    368e:	4b1e      	ldr	r3, [pc, #120]	; (3708 <_oscctrl_init_referenced_generators+0xb4>)
    3690:	771a      	strb	r2, [r3, #28]
	tmp = ((Oscctrl *)hw)->DFLLSYNC.reg;
    3692:	461a      	mov	r2, r3
    3694:	f892 302c 	ldrb.w	r3, [r2, #44]	; 0x2c
		;

	tmp = (CONF_DFLL_RUNSTDBY << OSCCTRL_DFLLCTRLA_RUNSTDBY_Pos) | OSCCTRL_DFLLCTRLA_ENABLE;
	hri_oscctrl_write_DFLLCTRLA_reg(hw, tmp);
	while (hri_oscctrl_get_DFLLSYNC_ENABLE_bit(hw))
    3698:	f013 0f02 	tst.w	r3, #2
    369c:	d1fa      	bne.n	3694 <_oscctrl_init_referenced_generators+0x40>
	return ((Oscctrl *)hw)->DFLLVAL.reg;
    369e:	4b1a      	ldr	r3, [pc, #104]	; (3708 <_oscctrl_init_referenced_generators+0xb4>)
    36a0:	6a5a      	ldr	r2, [r3, #36]	; 0x24
	((Oscctrl *)hw)->DFLLVAL.reg = data;
    36a2:	625a      	str	r2, [r3, #36]	; 0x24
	tmp = ((Oscctrl *)hw)->DFLLSYNC.reg;
    36a4:	461a      	mov	r2, r3
    36a6:	f892 302c 	ldrb.w	r3, [r2, #44]	; 0x2c

#if CONF_DFLL_OVERWRITE_CALIBRATION == 1
	hri_oscctrl_write_DFLLVAL_reg(hw, OSCCTRL_DFLLVAL_COARSE(CONF_DFLL_COARSE) | OSCCTRL_DFLLVAL_FINE(CONF_DFLL_FINE));
#endif
	hri_oscctrl_write_DFLLVAL_reg(hw, hri_oscctrl_read_DFLLVAL_reg(hw));
	while (hri_oscctrl_get_DFLLSYNC_DFLLVAL_bit(hw))
    36aa:	f013 0f08 	tst.w	r3, #8
    36ae:	d1fa      	bne.n	36a6 <_oscctrl_init_referenced_generators+0x52>
	((Oscctrl *)hw)->DFLLCTRLB.reg = data;
    36b0:	2219      	movs	r2, #25
    36b2:	4b15      	ldr	r3, [pc, #84]	; (3708 <_oscctrl_init_referenced_generators+0xb4>)
    36b4:	f883 2020 	strb.w	r2, [r3, #32]
	tmp = ((Oscctrl *)hw)->DFLLSYNC.reg;
    36b8:	461a      	mov	r2, r3
    36ba:	f892 302c 	ldrb.w	r3, [r2, #44]	; 0x2c
	tmp = (CONF_DFLL_WAITLOCK << OSCCTRL_DFLLCTRLB_WAITLOCK_Pos) | (CONF_DFLL_BPLCKC << OSCCTRL_DFLLCTRLB_BPLCKC_Pos)
	      | (CONF_DFLL_QLDIS << OSCCTRL_DFLLCTRLB_QLDIS_Pos) | (CONF_DFLL_CCDIS << OSCCTRL_DFLLCTRLB_CCDIS_Pos)
	      | (CONF_DFLL_USBCRM << OSCCTRL_DFLLCTRLB_USBCRM_Pos) | (CONF_DFLL_LLAW << OSCCTRL_DFLLCTRLB_LLAW_Pos)
	      | (CONF_DFLL_STABLE << OSCCTRL_DFLLCTRLB_STABLE_Pos) | (CONF_DFLL_MODE << OSCCTRL_DFLLCTRLB_MODE_Pos) | 0;
	hri_oscctrl_write_DFLLCTRLB_reg(hw, tmp);
	while (hri_oscctrl_get_DFLLSYNC_DFLLCTRLB_bit(hw))
    36be:	f013 0f04 	tst.w	r3, #4
    36c2:	d1fa      	bne.n	36ba <_oscctrl_init_referenced_generators+0x66>
	tmp = ((Oscctrl *)hw)->DFLLCTRLB.reg;
    36c4:	4b10      	ldr	r3, [pc, #64]	; (3708 <_oscctrl_init_referenced_generators+0xb4>)
    36c6:	f893 3020 	ldrb.w	r3, [r3, #32]
	                                (CONF_FDPLL1_RUNSTDBY << OSCCTRL_DPLLCTRLA_RUNSTDBY_Pos)
	                                    | (CONF_FDPLL1_ENABLE << OSCCTRL_DPLLCTRLA_ENABLE_Pos));
#endif

#if CONF_DFLL_CONFIG == 1
	if (hri_oscctrl_get_DFLLCTRLB_MODE_bit(hw)) {
    36ca:	f013 0f01 	tst.w	r3, #1
    36ce:	d012      	beq.n	36f6 <_oscctrl_init_referenced_generators+0xa2>
}

static inline hri_oscctrl_status_reg_t hri_oscctrl_get_STATUS_reg(const void *const hw, hri_oscctrl_status_reg_t mask)
{
	uint32_t tmp;
	tmp = ((Oscctrl *)hw)->STATUS.reg;
    36d0:	4a0d      	ldr	r2, [pc, #52]	; (3708 <_oscctrl_init_referenced_generators+0xb4>)
    36d2:	6913      	ldr	r3, [r2, #16]
	tmp &= mask;
    36d4:	f403 6310 	and.w	r3, r3, #2304	; 0x900
		hri_oscctrl_status_reg_t status_mask = OSCCTRL_STATUS_DFLLRDY | OSCCTRL_STATUS_DFLLLCKC;

		while (hri_oscctrl_get_STATUS_reg(hw, status_mask) != status_mask)
    36d8:	f5b3 6f10 	cmp.w	r3, #2304	; 0x900
    36dc:	d1f9      	bne.n	36d2 <_oscctrl_init_referenced_generators+0x7e>
	return tmp;
}

static inline hri_gclk_syncbusy_reg_t hri_gclk_read_SYNCBUSY_reg(const void *const hw)
{
	return ((Gclk *)hw)->SYNCBUSY.reg;
    36de:	4a09      	ldr	r2, [pc, #36]	; (3704 <_oscctrl_init_referenced_generators+0xb0>)
    36e0:	6853      	ldr	r3, [r2, #4]
	hri_oscctrl_set_DPLLCTRLA_ONDEMAND_bit(hw, 1);
#endif
#endif

#if CONF_DFLL_CONFIG == 1
	while (hri_gclk_read_SYNCBUSY_reg(GCLK))
    36e2:	2b00      	cmp	r3, #0
    36e4:	d1fc      	bne.n	36e0 <_oscctrl_init_referenced_generators+0x8c>
	tmp = ((Gclk *)hw)->GENCTRL[index].reg;
    36e6:	4a07      	ldr	r2, [pc, #28]	; (3704 <_oscctrl_init_referenced_generators+0xb0>)
    36e8:	6a13      	ldr	r3, [r2, #32]
	tmp &= ~GCLK_GENCTRL_SRC_Msk;
    36ea:	f023 030f 	bic.w	r3, r3, #15
	tmp |= GCLK_GENCTRL_SRC(data);
    36ee:	f043 0301 	orr.w	r3, r3, #1
	((Gclk *)hw)->GENCTRL[index].reg = tmp;
    36f2:	6213      	str	r3, [r2, #32]
    36f4:	4770      	bx	lr
	return (((Oscctrl *)hw)->STATUS.reg & OSCCTRL_STATUS_DFLLRDY) >> OSCCTRL_STATUS_DFLLRDY_Pos;
    36f6:	4a04      	ldr	r2, [pc, #16]	; (3708 <_oscctrl_init_referenced_generators+0xb4>)
    36f8:	6913      	ldr	r3, [r2, #16]
		while (!hri_oscctrl_get_STATUS_DFLLRDY_bit(hw))
    36fa:	f413 7f80 	tst.w	r3, #256	; 0x100
    36fe:	d0fb      	beq.n	36f8 <_oscctrl_init_referenced_generators+0xa4>
    3700:	e7ed      	b.n	36de <_oscctrl_init_referenced_generators+0x8a>
    3702:	bf00      	nop
    3704:	40001c00 	.word	0x40001c00
    3708:	40001000 	.word	0x40001000
    370c:	0401bb80 	.word	0x0401bb80

00003710 <PDEC_0_Handler>:

/**
 * \internal PDEC interrupt handler
 */
void PDEC_0_Handler(void)
{
    3710:	b508      	push	{r3, lr}
	void *const hw = _pdecs_dev->hw;
    3712:	4b1d      	ldr	r3, [pc, #116]	; (3788 <PDEC_0_Handler+0x78>)
    3714:	6818      	ldr	r0, [r3, #0]
    3716:	6902      	ldr	r2, [r0, #16]
	((Pdec *)hw)->INTFLAG.reg = PDEC_INTFLAG_MC1;
}

static inline bool hri_pdec_get_interrupt_OVF_bit(const void *const hw)
{
	return (((Pdec *)hw)->INTFLAG.reg & PDEC_INTFLAG_OVF) >> PDEC_INTFLAG_OVF_Pos;
    3718:	7a93      	ldrb	r3, [r2, #10]

	if (hri_pdec_get_interrupt_OVF_bit(hw)) {
    371a:	f013 0f01 	tst.w	r3, #1
    371e:	d011      	beq.n	3744 <PDEC_0_Handler+0x34>
}

static inline void hri_pdec_clear_interrupt_OVF_bit(const void *const hw)
{
	((Pdec *)hw)->INTFLAG.reg = PDEC_INTFLAG_OVF;
    3720:	2301      	movs	r3, #1
    3722:	7293      	strb	r3, [r2, #10]
	while (((Pdec *)hw)->SYNCBUSY.reg & reg) {
    3724:	6913      	ldr	r3, [r2, #16]
    3726:	f3c3 0308 	ubfx	r3, r3, #0, #9
    372a:	2b00      	cmp	r3, #0
    372c:	d1fa      	bne.n	3724 <PDEC_0_Handler+0x14>
}

static inline bool hri_pdec_get_STATUS_DIR_bit(const void *const hw)
{
	hri_pdec_wait_for_sync(hw, PDEC_SYNCBUSY_MASK);
	return (((Pdec *)hw)->STATUS.reg & PDEC_STATUS_DIR) >> PDEC_STATUS_DIR_Pos;
    372e:	8993      	ldrh	r3, [r2, #12]
		hri_pdec_clear_interrupt_OVF_bit(hw);
		if (hri_pdec_get_STATUS_DIR_bit(hw)) {
    3730:	f013 0f80 	tst.w	r3, #128	; 0x80
			_pdecs_dev->pdec_async_cb.irq_handler(_pdecs_dev, PDEC_IRQ_UNDERFLOW, 0);
    3734:	6843      	ldr	r3, [r0, #4]
    3736:	f04f 0200 	mov.w	r2, #0
    373a:	bf14      	ite	ne
    373c:	2102      	movne	r1, #2
		} else {
			_pdecs_dev->pdec_async_cb.irq_handler(_pdecs_dev, PDEC_IRQ_OVERFLOW, 0);
    373e:	2101      	moveq	r1, #1
    3740:	4798      	blx	r3
    3742:	bd08      	pop	{r3, pc}
	return (((Pdec *)hw)->INTFLAG.reg & PDEC_INTFLAG_DIR) >> PDEC_INTFLAG_DIR_Pos;
    3744:	7a93      	ldrb	r3, [r2, #10]
		}
	} else if (hri_pdec_get_interrupt_DIR_bit(hw)) {
    3746:	f013 0f04 	tst.w	r3, #4
    374a:	d108      	bne.n	375e <PDEC_0_Handler+0x4e>
	return (((Pdec *)hw)->INTFLAG.reg & PDEC_INTFLAG_VLC) >> PDEC_INTFLAG_VLC_Pos;
    374c:	7a93      	ldrb	r3, [r2, #10]
		hri_pdec_clear_interrupt_DIR_bit(hw);
		_pdecs_dev->pdec_async_cb.irq_handler(_pdecs_dev, PDEC_IRQ_DIRECTION, 0);
	} else if (hri_pdec_get_interrupt_VLC_bit(hw)) {
    374e:	f013 0f08 	tst.w	r3, #8
    3752:	d10b      	bne.n	376c <PDEC_0_Handler+0x5c>
	return (((Pdec *)hw)->INTFLAG.reg & PDEC_INTFLAG_ERR) >> PDEC_INTFLAG_ERR_Pos;
    3754:	7a93      	ldrb	r3, [r2, #10]
		hri_pdec_clear_interrupt_VLC_bit(hw);
		_pdecs_dev->pdec_async_cb.pos_changed(_pdecs_dev, 0);
	} else if (hri_pdec_get_interrupt_ERR_bit(hw)) {
    3756:	f013 0f02 	tst.w	r3, #2
    375a:	d10d      	bne.n	3778 <PDEC_0_Handler+0x68>
    375c:	bd08      	pop	{r3, pc}
	((Pdec *)hw)->INTFLAG.reg = PDEC_INTFLAG_DIR;
    375e:	2304      	movs	r3, #4
    3760:	7293      	strb	r3, [r2, #10]
		_pdecs_dev->pdec_async_cb.irq_handler(_pdecs_dev, PDEC_IRQ_DIRECTION, 0);
    3762:	6843      	ldr	r3, [r0, #4]
    3764:	2200      	movs	r2, #0
    3766:	4611      	mov	r1, r2
    3768:	4798      	blx	r3
    376a:	bd08      	pop	{r3, pc}
	((Pdec *)hw)->INTFLAG.reg = PDEC_INTFLAG_VLC;
    376c:	2308      	movs	r3, #8
    376e:	7293      	strb	r3, [r2, #10]
		_pdecs_dev->pdec_async_cb.pos_changed(_pdecs_dev, 0);
    3770:	6803      	ldr	r3, [r0, #0]
    3772:	2100      	movs	r1, #0
    3774:	4798      	blx	r3
    3776:	bd08      	pop	{r3, pc}
	((Pdec *)hw)->INTFLAG.reg = PDEC_INTFLAG_ERR;
    3778:	2302      	movs	r3, #2
    377a:	7293      	strb	r3, [r2, #10]
		hri_pdec_clear_interrupt_ERR_bit(hw);
		_pdecs_dev->pdec_async_cb.irq_handler(_pdecs_dev, PDEC_IRQ_ERROR, 0);
    377c:	6843      	ldr	r3, [r0, #4]
    377e:	2200      	movs	r2, #0
    3780:	2103      	movs	r1, #3
    3782:	4798      	blx	r3
	}
}
    3784:	e7ea      	b.n	375c <PDEC_0_Handler+0x4c>
    3786:	bf00      	nop
    3788:	200002bc 	.word	0x200002bc

0000378c <RAMECC_Handler>:

/**
 * \internal RAMECC interrupt handler
 */
void RAMECC_Handler(void)
{
    378c:	b500      	push	{lr}
    378e:	b083      	sub	sp, #12
	return tmp;
}

static inline hri_ramecc_intflag_reg_t hri_ramecc_read_INTFLAG_reg(const void *const hw)
{
	return ((Ramecc *)hw)->INTFLAG.reg;
    3790:	4b0d      	ldr	r3, [pc, #52]	; (37c8 <RAMECC_Handler+0x3c>)
    3792:	789b      	ldrb	r3, [r3, #2]
    3794:	b2db      	uxtb	r3, r3
	struct _ramecc_device *dev      = (struct _ramecc_device *)&device;
	volatile uint32_t      int_mask = hri_ramecc_read_INTFLAG_reg(RAMECC);
    3796:	9301      	str	r3, [sp, #4]

	if (int_mask & RAMECC_INTFLAG_DUALE && dev->ramecc_cb.dual_bit_err) {
    3798:	9b01      	ldr	r3, [sp, #4]
    379a:	f013 0f02 	tst.w	r3, #2
    379e:	d006      	beq.n	37ae <RAMECC_Handler+0x22>
    37a0:	4b0a      	ldr	r3, [pc, #40]	; (37cc <RAMECC_Handler+0x40>)
    37a2:	681b      	ldr	r3, [r3, #0]
    37a4:	b11b      	cbz	r3, 37ae <RAMECC_Handler+0x22>
	return tmp;
}

static inline hri_ramecc_erraddr_reg_t hri_ramecc_read_ERRADDR_reg(const void *const hw)
{
	return ((Ramecc *)hw)->ERRADDR.reg;
    37a6:	4a08      	ldr	r2, [pc, #32]	; (37c8 <RAMECC_Handler+0x3c>)
    37a8:	6850      	ldr	r0, [r2, #4]
		dev->ramecc_cb.dual_bit_err((uint32_t)hri_ramecc_read_ERRADDR_reg(RAMECC));
    37aa:	4798      	blx	r3
    37ac:	e009      	b.n	37c2 <RAMECC_Handler+0x36>
	} else if (int_mask & RAMECC_INTFLAG_SINGLEE && dev->ramecc_cb.single_bit_err) {
    37ae:	9b01      	ldr	r3, [sp, #4]
    37b0:	f013 0f01 	tst.w	r3, #1
    37b4:	d005      	beq.n	37c2 <RAMECC_Handler+0x36>
    37b6:	4b05      	ldr	r3, [pc, #20]	; (37cc <RAMECC_Handler+0x40>)
    37b8:	685b      	ldr	r3, [r3, #4]
    37ba:	b113      	cbz	r3, 37c2 <RAMECC_Handler+0x36>
    37bc:	4a02      	ldr	r2, [pc, #8]	; (37c8 <RAMECC_Handler+0x3c>)
    37be:	6850      	ldr	r0, [r2, #4]
		dev->ramecc_cb.single_bit_err((uint32_t)hri_ramecc_read_ERRADDR_reg(RAMECC));
    37c0:	4798      	blx	r3
	} else {
		return;
	}
}
    37c2:	b003      	add	sp, #12
    37c4:	f85d fb04 	ldr.w	pc, [sp], #4
    37c8:	41020000 	.word	0x41020000
    37cc:	20001678 	.word	0x20001678

000037d0 <_calendar_init>:

/**
 * \brief Initializes the RTC module with given configurations.
 */
int32_t _calendar_init(struct calendar_dev *const dev)
{
    37d0:	b510      	push	{r4, lr}
	ASSERT(dev && dev->hw);
    37d2:	4604      	mov	r4, r0
    37d4:	2800      	cmp	r0, #0
    37d6:	d03b      	beq.n	3850 <_calendar_init+0x80>
    37d8:	6800      	ldr	r0, [r0, #0]
    37da:	3000      	adds	r0, #0
    37dc:	bf18      	it	ne
    37de:	2001      	movne	r0, #1
    37e0:	2239      	movs	r2, #57	; 0x39
    37e2:	491c      	ldr	r1, [pc, #112]	; (3854 <_calendar_init+0x84>)
    37e4:	4b1c      	ldr	r3, [pc, #112]	; (3858 <_calendar_init+0x88>)
    37e6:	4798      	blx	r3

	_rtc_dev = dev;
    37e8:	4b1c      	ldr	r3, [pc, #112]	; (385c <_calendar_init+0x8c>)
    37ea:	601c      	str	r4, [r3, #0]

	hri_rtcmode0_wait_for_sync(dev->hw, RTC_MODE0_SYNCBUSY_SWRST);
    37ec:	6823      	ldr	r3, [r4, #0]
typedef uint8_t  hri_rtcmode2_freqcorr_reg_t;
typedef uint8_t  hri_rtcmode2_mask_reg_t;

static inline void hri_rtcmode0_wait_for_sync(const void *const hw, hri_rtcmode0_syncbusy_reg_t reg)
{
	while (((Rtc *)hw)->MODE0.SYNCBUSY.reg & reg) {
    37ee:	691a      	ldr	r2, [r3, #16]
    37f0:	f012 0f01 	tst.w	r2, #1
    37f4:	d1fb      	bne.n	37ee <_calendar_init+0x1e>
    37f6:	f248 0103 	movw	r1, #32771	; 0x8003
    37fa:	691a      	ldr	r2, [r3, #16]
    37fc:	420a      	tst	r2, r1
    37fe:	d1fc      	bne.n	37fa <_calendar_init+0x2a>

static inline bool hri_rtcmode0_get_CTRLA_ENABLE_bit(const void *const hw)
{
	uint16_t tmp;
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_SWRST | RTC_MODE0_SYNCBUSY_ENABLE | RTC_MODE0_SYNCBUSY_COUNTSYNC);
	tmp = ((Rtc *)hw)->MODE0.CTRLA.reg;
    3800:	881a      	ldrh	r2, [r3, #0]
	if (hri_rtcmode0_get_CTRLA_ENABLE_bit(dev->hw)) {
    3802:	f012 0f02 	tst.w	r2, #2
    3806:	d00f      	beq.n	3828 <_calendar_init+0x58>
	while (((Rtc *)hw)->MODE0.SYNCBUSY.reg & reg) {
    3808:	f248 0103 	movw	r1, #32771	; 0x8003
    380c:	691a      	ldr	r2, [r3, #16]
    380e:	420a      	tst	r2, r1
    3810:	d1fc      	bne.n	380c <_calendar_init+0x3c>

static inline void hri_rtcmode0_clear_CTRLA_ENABLE_bit(const void *const hw)
{
	RTC_CRITICAL_SECTION_ENTER();
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_SWRST | RTC_MODE0_SYNCBUSY_ENABLE | RTC_MODE0_SYNCBUSY_COUNTSYNC);
	((Rtc *)hw)->MODE0.CTRLA.reg &= ~RTC_MODE0_CTRLA_ENABLE;
    3812:	881a      	ldrh	r2, [r3, #0]
    3814:	f022 0202 	bic.w	r2, r2, #2
    3818:	0412      	lsls	r2, r2, #16
    381a:	0c12      	lsrs	r2, r2, #16
    381c:	801a      	strh	r2, [r3, #0]
#if !CONF_RTC_INIT_RESET
		return ERR_DENIED;
#else
		hri_rtcmode0_clear_CTRLA_ENABLE_bit(dev->hw);
		hri_rtcmode0_wait_for_sync(dev->hw, RTC_MODE0_SYNCBUSY_ENABLE);
    381e:	6822      	ldr	r2, [r4, #0]
	while (((Rtc *)hw)->MODE0.SYNCBUSY.reg & reg) {
    3820:	6913      	ldr	r3, [r2, #16]
    3822:	f013 0f02 	tst.w	r3, #2
    3826:	d1fb      	bne.n	3820 <_calendar_init+0x50>
#endif
	}
	hri_rtcmode0_set_CTRLA_SWRST_bit(dev->hw);
    3828:	6822      	ldr	r2, [r4, #0]
    382a:	6913      	ldr	r3, [r2, #16]
    382c:	f013 0f01 	tst.w	r3, #1
    3830:	d1fb      	bne.n	382a <_calendar_init+0x5a>
	((Rtc *)hw)->MODE0.CTRLA.reg |= RTC_MODE0_CTRLA_SWRST;
    3832:	8813      	ldrh	r3, [r2, #0]
    3834:	b29b      	uxth	r3, r3
    3836:	f043 0301 	orr.w	r3, r3, #1
    383a:	8013      	strh	r3, [r2, #0]
	hri_rtcmode0_wait_for_sync(dev->hw, RTC_MODE0_SYNCBUSY_SWRST);
    383c:	6822      	ldr	r2, [r4, #0]
	while (((Rtc *)hw)->MODE0.SYNCBUSY.reg & reg) {
    383e:	6913      	ldr	r3, [r2, #16]
    3840:	f013 0f01 	tst.w	r3, #1
    3844:	d1fb      	bne.n	383e <_calendar_init+0x6e>
}

static inline void hri_rtcmode0_write_CTRLA_reg(const void *const hw, hri_rtcmode0_ctrla_reg_t data)
{
	RTC_CRITICAL_SECTION_ENTER();
	((Rtc *)hw)->MODE0.CTRLA.reg = data;
    3846:	f44f 4301 	mov.w	r3, #33024	; 0x8100
    384a:	8013      	strh	r3, [r2, #0]
#endif

	hri_rtcmode0_write_CTRLA_reg(dev->hw, RTC_MODE0_CTRLA_PRESCALER(CONF_RTC_PRESCALER) | RTC_MODE0_CTRLA_COUNTSYNC);

	return ERR_NONE;
}
    384c:	2000      	movs	r0, #0
    384e:	bd10      	pop	{r4, pc}
    3850:	2000      	movs	r0, #0
    3852:	e7c5      	b.n	37e0 <_calendar_init+0x10>
    3854:	000098b0 	.word	0x000098b0
    3858:	00003205 	.word	0x00003205
    385c:	200002c0 	.word	0x200002c0

00003860 <_calendar_get_counter>:

/**
 * \brief Get current counter
 */
uint32_t _calendar_get_counter(struct calendar_dev *const dev)
{
    3860:	b510      	push	{r4, lr}
	ASSERT(dev && dev->hw);
    3862:	4604      	mov	r4, r0
    3864:	b150      	cbz	r0, 387c <_calendar_get_counter+0x1c>
    3866:	6800      	ldr	r0, [r0, #0]
    3868:	3000      	adds	r0, #0
    386a:	bf18      	it	ne
    386c:	2001      	movne	r0, #1
    386e:	2298      	movs	r2, #152	; 0x98
    3870:	4903      	ldr	r1, [pc, #12]	; (3880 <_calendar_get_counter+0x20>)
    3872:	4b04      	ldr	r3, [pc, #16]	; (3884 <_calendar_get_counter+0x24>)
    3874:	4798      	blx	r3

	return hri_rtcmode0_read_COUNT_reg(dev->hw);
    3876:	6823      	ldr	r3, [r4, #0]
	RTC_CRITICAL_SECTION_LEAVE();
}

static inline hri_rtcmode0_count_reg_t hri_rtcmode0_read_COUNT_reg(const void *const hw)
{
	return ((Rtc *)hw)->MODE0.COUNT.reg;
    3878:	6998      	ldr	r0, [r3, #24]
}
    387a:	bd10      	pop	{r4, pc}
    387c:	2000      	movs	r0, #0
    387e:	e7f6      	b.n	386e <_calendar_get_counter+0xe>
    3880:	000098b0 	.word	0x000098b0
    3884:	00003205 	.word	0x00003205

00003888 <RTC_Handler>:

/**
* \brief Rtc interrupt handler
*/
void RTC_Handler(void)
{
    3888:	b510      	push	{r4, lr}
	_rtc_interrupt_handler(_rtc_dev);
    388a:	4b08      	ldr	r3, [pc, #32]	; (38ac <RTC_Handler+0x24>)
    388c:	681c      	ldr	r4, [r3, #0]
	uint16_t interrupt_status = hri_rtcmode0_read_INTFLAG_reg(dev->hw);
    388e:	6823      	ldr	r3, [r4, #0]
	return ((Rtc *)hw)->MODE0.INTFLAG.reg;
    3890:	899b      	ldrh	r3, [r3, #12]
	if (interrupt_status & RTC_MODE0_INTFLAG_CMP0) {
    3892:	f413 7f80 	tst.w	r3, #256	; 0x100
    3896:	d100      	bne.n	389a <RTC_Handler+0x12>
    3898:	bd10      	pop	{r4, pc}
		dev->callback(dev);
    389a:	6863      	ldr	r3, [r4, #4]
    389c:	4620      	mov	r0, r4
    389e:	4798      	blx	r3
		hri_rtcmode0_clear_interrupt_CMP0_bit(dev->hw);
    38a0:	6823      	ldr	r3, [r4, #0]
	((Rtc *)hw)->MODE0.INTFLAG.reg = RTC_MODE0_INTFLAG_CMP0;
    38a2:	f44f 7280 	mov.w	r2, #256	; 0x100
    38a6:	819a      	strh	r2, [r3, #12]
}
    38a8:	e7f6      	b.n	3898 <RTC_Handler+0x10>
    38aa:	bf00      	nop
    38ac:	200002c0 	.word	0x200002c0

000038b0 <_mci_reset>:
 * \brief Reset the SDHC interface
 *
 * \param hw The pointer to MCI hardware instance
 */
static void _mci_reset(const void *const hw)
{
    38b0:	b510      	push	{r4, lr}
	ASSERT(hw);
    38b2:	4604      	mov	r4, r0
    38b4:	223e      	movs	r2, #62	; 0x3e
    38b6:	4906      	ldr	r1, [pc, #24]	; (38d0 <_mci_reset+0x20>)
    38b8:	3000      	adds	r0, #0
    38ba:	bf18      	it	ne
    38bc:	2001      	movne	r0, #1
    38be:	4b05      	ldr	r3, [pc, #20]	; (38d4 <_mci_reset+0x24>)
    38c0:	4798      	blx	r3
}

static inline void hri_sdhc_set_SRR_SWRSTCMD_bit(const void *const hw)
{
	SDHC_CRITICAL_SECTION_ENTER();
	((Sdhc *)hw)->SRR.reg |= SDHC_SRR_SWRSTCMD;
    38c2:	f894 302f 	ldrb.w	r3, [r4, #47]	; 0x2f
    38c6:	f043 0302 	orr.w	r3, r3, #2
    38ca:	f884 302f 	strb.w	r3, [r4, #47]	; 0x2f
    38ce:	bd10      	pop	{r4, pc}
    38d0:	000098c8 	.word	0x000098c8
    38d4:	00003205 	.word	0x00003205

000038d8 <_mci_send_cmd_execute>:
 * \param arg        Argument of the command
 *
 * \return true if success, otherwise false
 */
static bool _mci_send_cmd_execute(const void *const hw, uint32_t cmdr, uint32_t cmd, uint32_t arg)
{
    38d8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    38dc:	4688      	mov	r8, r1
    38de:	4615      	mov	r5, r2
    38e0:	461f      	mov	r7, r3
	uint32_t sr;
	ASSERT(hw);
    38e2:	4604      	mov	r4, r0
    38e4:	1c06      	adds	r6, r0, #0
    38e6:	bf18      	it	ne
    38e8:	2601      	movne	r6, #1
    38ea:	22a3      	movs	r2, #163	; 0xa3
    38ec:	493c      	ldr	r1, [pc, #240]	; (39e0 <_mci_send_cmd_execute+0x108>)
    38ee:	4630      	mov	r0, r6
    38f0:	4b3c      	ldr	r3, [pc, #240]	; (39e4 <_mci_send_cmd_execute+0x10c>)
    38f2:	4798      	blx	r3

	cmdr |= SDHC_CR_CMDIDX(cmd) | SDHC_CR_CMDTYP_NORMAL;
    38f4:	0229      	lsls	r1, r5, #8
    38f6:	f401 517c 	and.w	r1, r1, #16128	; 0x3f00
    38fa:	ea41 0108 	orr.w	r1, r1, r8

	if (cmd & MCI_RESP_PRESENT) {
    38fe:	f415 7f80 	tst.w	r5, #256	; 0x100
    3902:	d004      	beq.n	390e <_mci_send_cmd_execute+0x36>

		if (cmd & MCI_RESP_136) {
    3904:	f415 6f00 	tst.w	r5, #2048	; 0x800
    3908:	d016      	beq.n	3938 <_mci_send_cmd_execute+0x60>
			cmdr |= SDHC_CR_RESPTYP_136_BIT;
    390a:	f041 0101 	orr.w	r1, r1, #1
		} else {
			cmdr |= SDHC_CR_RESPTYP_48_BIT;
		}
	}

	if (cmd & MCI_CMD_OPENDRAIN) {
    390e:	f415 4f80 	tst.w	r5, #16384	; 0x4000
}

static inline void hri_sdhc_set_MC1R_OPD_bit(const void *const hw)
{
	SDHC_CRITICAL_SECTION_ENTER();
	((Sdhc *)hw)->MC1R.reg |= SDHC_MC1R_OPD;
    3912:	f894 3204 	ldrb.w	r3, [r4, #516]	; 0x204
    3916:	bf14      	ite	ne
    3918:	f043 0310 	orrne.w	r3, r3, #16
}

static inline void hri_sdhc_clear_MC1R_OPD_bit(const void *const hw)
{
	SDHC_CRITICAL_SECTION_ENTER();
	((Sdhc *)hw)->MC1R.reg &= ~SDHC_MC1R_OPD;
    391c:	f003 03ef 	andeq.w	r3, r3, #239	; 0xef
    3920:	f884 3204 	strb.w	r3, [r4, #516]	; 0x204
	((Sdhc *)hw)->ARG1R.reg = data;
    3924:	60a7      	str	r7, [r4, #8]
	} else {
		hri_sdhc_clear_MC1R_OPD_bit(hw);
	}

	hri_sdhc_write_ARG1R_reg(hw, arg);
	hri_sdhc_write_CR_reg(hw, cmdr);
    3926:	b28b      	uxth	r3, r1
	((Sdhc *)hw)->CR.reg = data;
    3928:	81e3      	strh	r3, [r4, #14]

	/* Wait end of command */
	do {
		sr = hri_sdhc_read_EISTR_reg(hw);

		if (cmd & MCI_RESP_CRC) {
    392a:	f405 5280 	and.w	r2, r5, #4096	; 0x1000
				_mci_reset(hw);
				hri_sdhc_set_EISTR_reg(hw, SDHC_EISTR_MASK);
				return false;
			}
		} else {
			if (sr & (SDHC_EISTR_CMDTEO | SDHC_EISTR_CMDEND | SDHC_EISTR_CMDIDX | SDHC_EISTR_CMDCRC | SDHC_EISTR_DATCRC
    392e:	f240 277f 	movw	r7, #639	; 0x27f
			if (sr & (SDHC_EISTR_CMDTEO | SDHC_EISTR_CMDEND | SDHC_EISTR_CMDIDX | SDHC_EISTR_DATTEO | SDHC_EISTR_DATEND
    3932:	f240 205d 	movw	r0, #605	; 0x25d
    3936:	e00d      	b.n	3954 <_mci_send_cmd_execute+0x7c>
		} else if (cmd & MCI_RESP_BUSY) {
    3938:	f415 5f00 	tst.w	r5, #8192	; 0x2000
			cmdr |= SDHC_CR_RESPTYP_48_BIT_BUSY;
    393c:	bf14      	ite	ne
    393e:	f041 0103 	orrne.w	r1, r1, #3
			cmdr |= SDHC_CR_RESPTYP_48_BIT;
    3942:	f041 0102 	orreq.w	r1, r1, #2
    3946:	e7e2      	b.n	390e <_mci_send_cmd_execute+0x36>
			if (sr & (SDHC_EISTR_CMDTEO | SDHC_EISTR_CMDEND | SDHC_EISTR_CMDIDX | SDHC_EISTR_CMDCRC | SDHC_EISTR_DATCRC
    3948:	423b      	tst	r3, r7
    394a:	d116      	bne.n	397a <_mci_send_cmd_execute+0xa2>
	tmp = ((Sdhc *)hw)->NISTR.reg;
    394c:	8e23      	ldrh	r3, [r4, #48]	; 0x30
				_mci_reset(hw);
				hri_sdhc_set_EISTR_reg(hw, SDHC_EISTR_MASK);
				return false;
			}
		}
	} while (!hri_sdhc_get_NISTR_CMDC_bit(hw));
    394e:	f013 0f01 	tst.w	r3, #1
    3952:	d11f      	bne.n	3994 <_mci_send_cmd_execute+0xbc>
	return ((Sdhc *)hw)->EISTR.reg;
    3954:	8e63      	ldrh	r3, [r4, #50]	; 0x32
    3956:	b29b      	uxth	r3, r3
		if (cmd & MCI_RESP_CRC) {
    3958:	2a00      	cmp	r2, #0
    395a:	d0f5      	beq.n	3948 <_mci_send_cmd_execute+0x70>
			if (sr & (SDHC_EISTR_CMDTEO | SDHC_EISTR_CMDEND | SDHC_EISTR_CMDIDX | SDHC_EISTR_DATTEO | SDHC_EISTR_DATEND
    395c:	4203      	tst	r3, r0
    395e:	d0f5      	beq.n	394c <_mci_send_cmd_execute+0x74>
				_mci_reset(hw);
    3960:	4620      	mov	r0, r4
    3962:	4b21      	ldr	r3, [pc, #132]	; (39e8 <_mci_send_cmd_execute+0x110>)
    3964:	4798      	blx	r3
	((Sdhc *)hw)->EISTR.reg |= mask;
    3966:	8e63      	ldrh	r3, [r4, #50]	; 0x32
    3968:	b29b      	uxth	r3, r3
    396a:	ea6f 2393 	mvn.w	r3, r3, lsr #10
    396e:	ea6f 2383 	mvn.w	r3, r3, lsl #10
    3972:	8663      	strh	r3, [r4, #50]	; 0x32
				return false;
    3974:	2000      	movs	r0, #0
    3976:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				_mci_reset(hw);
    397a:	4620      	mov	r0, r4
    397c:	4b1a      	ldr	r3, [pc, #104]	; (39e8 <_mci_send_cmd_execute+0x110>)
    397e:	4798      	blx	r3
    3980:	8e63      	ldrh	r3, [r4, #50]	; 0x32
    3982:	b29b      	uxth	r3, r3
    3984:	ea6f 2393 	mvn.w	r3, r3, lsr #10
    3988:	ea6f 2383 	mvn.w	r3, r3, lsl #10
    398c:	8663      	strh	r3, [r4, #50]	; 0x32
				return false;
    398e:	2000      	movs	r0, #0
    3990:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (!(cmdr & SDHC_CR_DPSEL_DATA)) {
    3994:	f011 0f20 	tst.w	r1, #32
    3998:	d104      	bne.n	39a4 <_mci_send_cmd_execute+0xcc>
	((Sdhc *)hw)->NISTR.reg |= SDHC_NISTR_CMDC;
    399a:	8e23      	ldrh	r3, [r4, #48]	; 0x30
    399c:	b29b      	uxth	r3, r3
    399e:	f043 0301 	orr.w	r3, r3, #1
    39a2:	8623      	strh	r3, [r4, #48]	; 0x30
		hri_sdhc_set_NISTR_CMDC_bit(hw);
	}
	if (cmd & MCI_RESP_BUSY) {
    39a4:	f415 5f00 	tst.w	r5, #8192	; 0x2000
    39a8:	d102      	bne.n	39b0 <_mci_send_cmd_execute+0xd8>
		if (!_mci_wait_busy(hw)) {
			return false;
		}
	}

	return true;
    39aa:	2001      	movs	r0, #1
}
    39ac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	ASSERT(hw);
    39b0:	2289      	movs	r2, #137	; 0x89
    39b2:	490b      	ldr	r1, [pc, #44]	; (39e0 <_mci_send_cmd_execute+0x108>)
    39b4:	4630      	mov	r0, r6
    39b6:	4b0b      	ldr	r3, [pc, #44]	; (39e4 <_mci_send_cmd_execute+0x10c>)
    39b8:	4798      	blx	r3
	return tmp;
}

static inline hri_sdhc_psr_reg_t hri_sdhc_read_PSR_reg(const void *const hw)
{
	return ((Sdhc *)hw)->PSR.reg;
    39ba:	6a62      	ldr	r2, [r4, #36]	; 0x24
    39bc:	f04f 33ff 	mov.w	r3, #4294967295
	} while (!(psr & SDHC_PSR_DATLL(1)));
    39c0:	f412 1f80 	tst.w	r2, #1048576	; 0x100000
    39c4:	d108      	bne.n	39d8 <_mci_send_cmd_execute+0x100>
    39c6:	6a62      	ldr	r2, [r4, #36]	; 0x24
		if (busy_wait-- == 0) {
    39c8:	3b01      	subs	r3, #1
    39ca:	d1f9      	bne.n	39c0 <_mci_send_cmd_execute+0xe8>
			_mci_reset(hw);
    39cc:	4620      	mov	r0, r4
    39ce:	4b06      	ldr	r3, [pc, #24]	; (39e8 <_mci_send_cmd_execute+0x110>)
    39d0:	4798      	blx	r3
			return false;
    39d2:	2000      	movs	r0, #0
    39d4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	return true;
    39d8:	2001      	movs	r0, #1
    39da:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    39de:	bf00      	nop
    39e0:	000098c8 	.word	0x000098c8
    39e4:	00003205 	.word	0x00003205
    39e8:	000038b1 	.word	0x000038b1

000039ec <_mci_sync_init>:

/**
 *  \brief Initialize MCI low level driver.
 */
int32_t _mci_sync_init(struct _mci_sync_device *const mci_dev, void *const hw)
{
    39ec:	b538      	push	{r3, r4, r5, lr}
    39ee:	460c      	mov	r4, r1
	ASSERT(mci_dev && hw);
    39f0:	4605      	mov	r5, r0
    39f2:	b340      	cbz	r0, 3a46 <_mci_sync_init+0x5a>
    39f4:	1c08      	adds	r0, r1, #0
    39f6:	bf18      	it	ne
    39f8:	2001      	movne	r0, #1
    39fa:	22e2      	movs	r2, #226	; 0xe2
    39fc:	4913      	ldr	r1, [pc, #76]	; (3a4c <_mci_sync_init+0x60>)
    39fe:	4b14      	ldr	r3, [pc, #80]	; (3a50 <_mci_sync_init+0x64>)
    3a00:	4798      	blx	r3

	mci_dev->hw = hw;
    3a02:	602c      	str	r4, [r5, #0]
	((Sdhc *)hw)->SRR.reg |= SDHC_SRR_SWRSTALL;
    3a04:	f894 302f 	ldrb.w	r3, [r4, #47]	; 0x2f
    3a08:	f043 0301 	orr.w	r3, r3, #1
    3a0c:	f884 302f 	strb.w	r3, [r4, #47]	; 0x2f
	tmp = ((Sdhc *)hw)->SRR.reg;
    3a10:	f894 302f 	ldrb.w	r3, [r4, #47]	; 0x2f

	hri_sdhc_set_SRR_SWRSTALL_bit(hw);
	while (hri_sdhc_get_SRR_SWRSTALL_bit(hw))
    3a14:	f013 0f01 	tst.w	r3, #1
    3a18:	d1fa      	bne.n	3a10 <_mci_sync_init+0x24>
	((Sdhc *)hw)->TCR.reg = data;
    3a1a:	230e      	movs	r3, #14
    3a1c:	f884 302e 	strb.w	r3, [r4, #46]	; 0x2e
	((Sdhc *)hw)->PCR.reg = data;
    3a20:	230f      	movs	r3, #15
    3a22:	f884 3029 	strb.w	r3, [r4, #41]	; 0x29
	((Sdhc *)hw)->NISTER.reg |= mask;
    3a26:	8ea3      	ldrh	r3, [r4, #52]	; 0x34
    3a28:	b29b      	uxth	r3, r3
    3a2a:	ea6f 2353 	mvn.w	r3, r3, lsr #9
    3a2e:	ea6f 2343 	mvn.w	r3, r3, lsl #9
    3a32:	86a3      	strh	r3, [r4, #52]	; 0x34
	((Sdhc *)hw)->EISTER.reg |= mask;
    3a34:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
    3a36:	b29b      	uxth	r3, r3
    3a38:	ea6f 2393 	mvn.w	r3, r3, lsr #10
    3a3c:	ea6f 2383 	mvn.w	r3, r3, lsl #10
    3a40:	86e3      	strh	r3, [r4, #54]	; 0x36

	hri_sdhc_set_NISTER_reg(hw, SDHC_NISTER_MASK);
	hri_sdhc_set_EISTER_reg(hw, SDHC_EISTER_MASK);

	return ERR_NONE;
}
    3a42:	2000      	movs	r0, #0
    3a44:	bd38      	pop	{r3, r4, r5, pc}
    3a46:	2000      	movs	r0, #0
    3a48:	e7d7      	b.n	39fa <_mci_sync_init+0xe>
    3a4a:	bf00      	nop
    3a4c:	000098c8 	.word	0x000098c8
    3a50:	00003205 	.word	0x00003205

00003a54 <_mci_sync_select_device>:
/**
 *  \brief Select a device and initialize it
 */
int32_t _mci_sync_select_device(struct _mci_sync_device *const mci_dev, uint8_t slot, uint32_t clock, uint8_t bus_width,
                                bool high_speed)
{
    3a54:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3a56:	4615      	mov	r5, r2
    3a58:	461c      	mov	r4, r3
    3a5a:	f89d 7018 	ldrb.w	r7, [sp, #24]
	(void)(slot);
	void *hw;

	ASSERT(mci_dev && mci_dev->hw);
    3a5e:	4606      	mov	r6, r0
    3a60:	b1d8      	cbz	r0, 3a9a <_mci_sync_select_device+0x46>
    3a62:	6800      	ldr	r0, [r0, #0]
    3a64:	3000      	adds	r0, #0
    3a66:	bf18      	it	ne
    3a68:	2001      	movne	r0, #1
    3a6a:	f44f 7285 	mov.w	r2, #266	; 0x10a
    3a6e:	493a      	ldr	r1, [pc, #232]	; (3b58 <_mci_sync_select_device+0x104>)
    3a70:	4b3a      	ldr	r3, [pc, #232]	; (3b5c <_mci_sync_select_device+0x108>)
    3a72:	4798      	blx	r3
	hw = mci_dev->hw;
    3a74:	6833      	ldr	r3, [r6, #0]

	if (high_speed) {
    3a76:	b197      	cbz	r7, 3a9e <_mci_sync_select_device+0x4a>
	((Sdhc *)hw)->HC1R.reg |= SDHC_HC1R_HSEN;
    3a78:	f893 2028 	ldrb.w	r2, [r3, #40]	; 0x28
    3a7c:	f042 0204 	orr.w	r2, r2, #4
    3a80:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
	tmp = ((Sdhc *)hw)->HC2R.reg;
    3a84:	8fda      	ldrh	r2, [r3, #62]	; 0x3e
		hri_sdhc_set_HC1R_HSEN_bit(hw);
	} else {
		hri_sdhc_clear_HC1R_HSEN_bit(hw);
	}

	if (hri_sdhc_get_HC2R_PVALEN_bit(hw) == 0) {
    3a86:	f412 4f00 	tst.w	r2, #32768	; 0x8000
    3a8a:	d00f      	beq.n	3aac <_mci_sync_select_device+0x58>
		_mci_set_speed(hw, clock, CONF_SDHC1_CLK_GEN_SEL);
	}

	switch (bus_width) {
    3a8c:	2c01      	cmp	r4, #1
    3a8e:	d053      	beq.n	3b38 <_mci_sync_select_device+0xe4>
    3a90:	2c04      	cmp	r4, #4
    3a92:	d059      	beq.n	3b48 <_mci_sync_select_device+0xf4>
	case 4:
		hri_sdhc_set_HC1R_DW_bit(hw);
		break;

	default:
		return ERR_INVALID_ARG;
    3a94:	f06f 000c 	mvn.w	r0, #12
	}

	return ERR_NONE;
}
    3a98:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    3a9a:	2000      	movs	r0, #0
    3a9c:	e7e5      	b.n	3a6a <_mci_sync_select_device+0x16>
	((Sdhc *)hw)->HC1R.reg &= ~SDHC_HC1R_HSEN;
    3a9e:	f893 2028 	ldrb.w	r2, [r3, #40]	; 0x28
    3aa2:	f002 02fb 	and.w	r2, r2, #251	; 0xfb
    3aa6:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
    3aaa:	e7eb      	b.n	3a84 <_mci_sync_select_device+0x30>
	tmp = ((Sdhc *)hw)->CCR.reg;
    3aac:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
	if (hri_sdhc_get_CCR_SDCLKEN_bit(hw)) {
    3aae:	f012 0f04 	tst.w	r2, #4
    3ab2:	d009      	beq.n	3ac8 <_mci_sync_select_device+0x74>
	return ((Sdhc *)hw)->PSR.reg;
    3ab4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
		while (hri_sdhc_read_PSR_reg(hw) & (SDHC_PSR_CMDINHC_CANNOT | SDHC_PSR_CMDINHD_CANNOT))
    3ab6:	f012 0f03 	tst.w	r2, #3
    3aba:	d1fb      	bne.n	3ab4 <_mci_sync_select_device+0x60>
	((Sdhc *)hw)->CCR.reg &= ~SDHC_CCR_SDCLKEN;
    3abc:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
    3abe:	f022 0204 	bic.w	r2, r2, #4
    3ac2:	0412      	lsls	r2, r2, #16
    3ac4:	0c12      	lsrs	r2, r2, #16
    3ac6:	859a      	strh	r2, [r3, #44]	; 0x2c
	return (((Sdhc *)hw)->CA1R.reg & SDHC_CA1R_CLKMULT(mask)) >> SDHC_CA1R_CLKMULT_Pos;
}

static inline hri_sdhc_ca1r_reg_t hri_sdhc_read_CA1R_CLKMULT_bf(const void *const hw)
{
	return (((Sdhc *)hw)->CA1R.reg & SDHC_CA1R_CLKMULT_Msk) >> SDHC_CA1R_CLKMULT_Pos;
    3ac8:	6c59      	ldr	r1, [r3, #68]	; 0x44
    3aca:	f3c1 4107 	ubfx	r1, r1, #16, #8
		clkbase = clkbase / 2;
    3ace:	4824      	ldr	r0, [pc, #144]	; (3b60 <_mci_sync_select_device+0x10c>)
    3ad0:	4a24      	ldr	r2, [pc, #144]	; (3b64 <_mci_sync_select_device+0x110>)
    3ad2:	2900      	cmp	r1, #0
    3ad4:	bf18      	it	ne
    3ad6:	4602      	movne	r2, r0
	((Sdhc *)hw)->CCR.reg &= ~SDHC_CCR_CLKGSEL;
    3ad8:	8d99      	ldrh	r1, [r3, #44]	; 0x2c
    3ada:	f021 0120 	bic.w	r1, r1, #32
    3ade:	0409      	lsls	r1, r1, #16
    3ae0:	0c09      	lsrs	r1, r1, #16
    3ae2:	8599      	strh	r1, [r3, #44]	; 0x2c
		div = (clkbase / speed) / 2;
    3ae4:	fbb2 f2f5 	udiv	r2, r2, r5
    3ae8:	0852      	lsrs	r2, r2, #1
	tmp = ((Sdhc *)hw)->HC1R.reg;
    3aea:	f893 1028 	ldrb.w	r1, [r3, #40]	; 0x28
	if ((hri_sdhc_get_HC1R_HSEN_bit(hw)) && (div == 0)) {
    3aee:	f011 0f04 	tst.w	r1, #4
    3af2:	d002      	beq.n	3afa <_mci_sync_select_device+0xa6>
		div = 1;
    3af4:	2a00      	cmp	r2, #0
    3af6:	bf08      	it	eq
    3af8:	2201      	moveq	r2, #1
	tmp = ((Sdhc *)hw)->CCR.reg;
    3afa:	8d99      	ldrh	r1, [r3, #44]	; 0x2c
	tmp &= ~SDHC_CCR_SDCLKFSEL_Msk;
    3afc:	b2c9      	uxtb	r1, r1
	tmp |= SDHC_CCR_SDCLKFSEL(data);
    3afe:	ea41 2102 	orr.w	r1, r1, r2, lsl #8
    3b02:	b289      	uxth	r1, r1
	((Sdhc *)hw)->CCR.reg = tmp;
    3b04:	8599      	strh	r1, [r3, #44]	; 0x2c
	tmp = ((Sdhc *)hw)->CCR.reg;
    3b06:	8d99      	ldrh	r1, [r3, #44]	; 0x2c
	tmp &= ~SDHC_CCR_USDCLKFSEL_Msk;
    3b08:	f021 01c0 	bic.w	r1, r1, #192	; 0xc0
    3b0c:	0409      	lsls	r1, r1, #16
    3b0e:	0c09      	lsrs	r1, r1, #16
	tmp |= SDHC_CCR_USDCLKFSEL(data);
    3b10:	0892      	lsrs	r2, r2, #2
    3b12:	f002 02c0 	and.w	r2, r2, #192	; 0xc0
    3b16:	430a      	orrs	r2, r1
	((Sdhc *)hw)->CCR.reg = tmp;
    3b18:	859a      	strh	r2, [r3, #44]	; 0x2c
	((Sdhc *)hw)->CCR.reg |= SDHC_CCR_INTCLKEN;
    3b1a:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
    3b1c:	b292      	uxth	r2, r2
    3b1e:	f042 0201 	orr.w	r2, r2, #1
    3b22:	859a      	strh	r2, [r3, #44]	; 0x2c
	tmp = ((Sdhc *)hw)->CCR.reg;
    3b24:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
	while (hri_sdhc_get_CCR_INTCLKS_bit(hw) == 0)
    3b26:	f012 0f02 	tst.w	r2, #2
    3b2a:	d0fb      	beq.n	3b24 <_mci_sync_select_device+0xd0>
	((Sdhc *)hw)->CCR.reg |= SDHC_CCR_SDCLKEN;
    3b2c:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
    3b2e:	b292      	uxth	r2, r2
    3b30:	f042 0204 	orr.w	r2, r2, #4
    3b34:	859a      	strh	r2, [r3, #44]	; 0x2c
    3b36:	e7a9      	b.n	3a8c <_mci_sync_select_device+0x38>
	((Sdhc *)hw)->HC1R.reg &= ~SDHC_HC1R_DW;
    3b38:	f893 2028 	ldrb.w	r2, [r3, #40]	; 0x28
    3b3c:	f002 02fd 	and.w	r2, r2, #253	; 0xfd
    3b40:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
	return ERR_NONE;
    3b44:	2000      	movs	r0, #0
    3b46:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	((Sdhc *)hw)->HC1R.reg |= SDHC_HC1R_DW;
    3b48:	f893 2028 	ldrb.w	r2, [r3, #40]	; 0x28
    3b4c:	f042 0202 	orr.w	r2, r2, #2
    3b50:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
    3b54:	2000      	movs	r0, #0
    3b56:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    3b58:	000098c8 	.word	0x000098c8
    3b5c:	00003205 	.word	0x00003205
    3b60:	005b8d80 	.word	0x005b8d80
    3b64:	00b71b00 	.word	0x00b71b00

00003b68 <_mci_sync_deselect_device>:
	/* Nothing to do */
	(void)(mci_dev);
	(void)(slot);

	return ERR_NONE;
}
    3b68:	2000      	movs	r0, #0
    3b6a:	4770      	bx	lr

00003b6c <_mci_sync_get_bus_width>:
 */
uint8_t _mci_sync_get_bus_width(struct _mci_sync_device *const mci_dev, uint8_t slot)
{
	(void)(mci_dev);

	switch (slot) {
    3b6c:	2900      	cmp	r1, #0

	default:
		/* Slot number wrong */
		return 0;
	}
}
    3b6e:	bf0c      	ite	eq
    3b70:	2004      	moveq	r0, #4
    3b72:	2000      	movne	r0, #0
    3b74:	4770      	bx	lr

00003b76 <_mci_sync_is_high_speed_capable>:
/**
 *  \brief Get the high speed capability of the device.
 */
bool _mci_sync_is_high_speed_capable(struct _mci_sync_device *const mci_dev)
{
	return hri_sdhc_get_CA0R_HSSUP_bit(mci_dev->hw);
    3b76:	6803      	ldr	r3, [r0, #0]
	return (((Sdhc *)hw)->CA0R.reg & SDHC_CA0R_HSSUP) >> SDHC_CA0R_HSSUP_Pos;
    3b78:	6c18      	ldr	r0, [r3, #64]	; 0x40
}
    3b7a:	f3c0 5040 	ubfx	r0, r0, #21, #1
    3b7e:	4770      	bx	lr

00003b80 <_mci_sync_send_clock>:
/**
 *  \brief Send 74 clock cycles on the line.
 *   Note: It is required after card plug and before card install.
 */
void _mci_sync_send_clock(struct _mci_sync_device *const mci_dev)
{
    3b80:	b500      	push	{lr}
    3b82:	b083      	sub	sp, #12
	ASSERT(mci_dev);
    3b84:	f240 1253 	movw	r2, #339	; 0x153
    3b88:	490b      	ldr	r1, [pc, #44]	; (3bb8 <_mci_sync_send_clock+0x38>)
    3b8a:	3000      	adds	r0, #0
    3b8c:	bf18      	it	ne
    3b8e:	2001      	movne	r0, #1
    3b90:	4b0a      	ldr	r3, [pc, #40]	; (3bbc <_mci_sync_send_clock+0x3c>)
    3b92:	4798      	blx	r3

	volatile uint32_t i;
	for (i = 0; i < 5000; i++)
    3b94:	2300      	movs	r3, #0
    3b96:	9301      	str	r3, [sp, #4]
    3b98:	9a01      	ldr	r2, [sp, #4]
    3b9a:	f241 3387 	movw	r3, #4999	; 0x1387
    3b9e:	429a      	cmp	r2, r3
    3ba0:	d806      	bhi.n	3bb0 <_mci_sync_send_clock+0x30>
    3ba2:	461a      	mov	r2, r3
    3ba4:	9b01      	ldr	r3, [sp, #4]
    3ba6:	3301      	adds	r3, #1
    3ba8:	9301      	str	r3, [sp, #4]
    3baa:	9b01      	ldr	r3, [sp, #4]
    3bac:	4293      	cmp	r3, r2
    3bae:	d9f9      	bls.n	3ba4 <_mci_sync_send_clock+0x24>
		;
}
    3bb0:	b003      	add	sp, #12
    3bb2:	f85d fb04 	ldr.w	pc, [sp], #4
    3bb6:	bf00      	nop
    3bb8:	000098c8 	.word	0x000098c8
    3bbc:	00003205 	.word	0x00003205

00003bc0 <_mci_sync_send_cmd>:

/**
 *  \brief Send a command on the selected slot
 */
bool _mci_sync_send_cmd(struct _mci_sync_device *const mci_dev, uint32_t cmd, uint32_t arg)
{
    3bc0:	b570      	push	{r4, r5, r6, lr}
    3bc2:	460d      	mov	r5, r1
    3bc4:	4616      	mov	r6, r2
	void *hw;
	ASSERT(mci_dev && mci_dev->hw);
    3bc6:	4604      	mov	r4, r0
    3bc8:	b178      	cbz	r0, 3bea <_mci_sync_send_cmd+0x2a>
    3bca:	6800      	ldr	r0, [r0, #0]
    3bcc:	3000      	adds	r0, #0
    3bce:	bf18      	it	ne
    3bd0:	2001      	movne	r0, #1
    3bd2:	f44f 72b0 	mov.w	r2, #352	; 0x160
    3bd6:	490c      	ldr	r1, [pc, #48]	; (3c08 <_mci_sync_send_cmd+0x48>)
    3bd8:	4b0c      	ldr	r3, [pc, #48]	; (3c0c <_mci_sync_send_cmd+0x4c>)
    3bda:	4798      	blx	r3
	hw = mci_dev->hw;
    3bdc:	6820      	ldr	r0, [r4, #0]
	return (((Sdhc *)hw)->PSR.reg & SDHC_PSR_CMDINHC) >> SDHC_PSR_CMDINHC_Pos;
    3bde:	6a43      	ldr	r3, [r0, #36]	; 0x24

	/* Check Command Inhibit (CMD) in the Present State register */
	if (hri_sdhc_get_PSR_CMDINHC_bit(hw)) {
    3be0:	f013 0f01 	tst.w	r3, #1
    3be4:	d003      	beq.n	3bee <_mci_sync_send_cmd+0x2e>
		return false;
    3be6:	2000      	movs	r0, #0

	hri_sdhc_clear_TMR_DMAEN_bit(hw);
	hri_sdhc_write_BCR_reg(hw, 0);

	return _mci_send_cmd_execute(hw, 0, cmd, arg);
}
    3be8:	bd70      	pop	{r4, r5, r6, pc}
    3bea:	2000      	movs	r0, #0
    3bec:	e7f1      	b.n	3bd2 <_mci_sync_send_cmd+0x12>
	((Sdhc *)hw)->TMR.reg &= ~SDHC_TMR_DMAEN;
    3bee:	8983      	ldrh	r3, [r0, #12]
    3bf0:	f023 0301 	bic.w	r3, r3, #1
    3bf4:	041b      	lsls	r3, r3, #16
    3bf6:	0c1b      	lsrs	r3, r3, #16
    3bf8:	8183      	strh	r3, [r0, #12]
	((Sdhc *)hw)->BCR.reg = data;
    3bfa:	2100      	movs	r1, #0
    3bfc:	80c1      	strh	r1, [r0, #6]
	return _mci_send_cmd_execute(hw, 0, cmd, arg);
    3bfe:	4633      	mov	r3, r6
    3c00:	462a      	mov	r2, r5
    3c02:	4c03      	ldr	r4, [pc, #12]	; (3c10 <_mci_sync_send_cmd+0x50>)
    3c04:	47a0      	blx	r4
    3c06:	bd70      	pop	{r4, r5, r6, pc}
    3c08:	000098c8 	.word	0x000098c8
    3c0c:	00003205 	.word	0x00003205
    3c10:	000038d9 	.word	0x000038d9

00003c14 <_mci_sync_get_response>:

/**
 *  \brief Get 32 bits response of the last command.
 */
uint32_t _mci_sync_get_response(struct _mci_sync_device *const mci_dev)
{
    3c14:	b510      	push	{r4, lr}
	void *hw;
	ASSERT(mci_dev && mci_dev->hw);
    3c16:	4604      	mov	r4, r0
    3c18:	b158      	cbz	r0, 3c32 <_mci_sync_get_response+0x1e>
    3c1a:	6800      	ldr	r0, [r0, #0]
    3c1c:	3000      	adds	r0, #0
    3c1e:	bf18      	it	ne
    3c20:	2001      	movne	r0, #1
    3c22:	f44f 72ba 	mov.w	r2, #372	; 0x174
    3c26:	4904      	ldr	r1, [pc, #16]	; (3c38 <_mci_sync_get_response+0x24>)
    3c28:	4b04      	ldr	r3, [pc, #16]	; (3c3c <_mci_sync_get_response+0x28>)
    3c2a:	4798      	blx	r3
	hw = mci_dev->hw;
    3c2c:	6823      	ldr	r3, [r4, #0]
	return ((Sdhc *)hw)->RR[index].reg;
    3c2e:	6918      	ldr	r0, [r3, #16]

	return hri_sdhc_read_RR_reg(hw, 0);
}
    3c30:	bd10      	pop	{r4, pc}
    3c32:	2000      	movs	r0, #0
    3c34:	e7f5      	b.n	3c22 <_mci_sync_get_response+0xe>
    3c36:	bf00      	nop
    3c38:	000098c8 	.word	0x000098c8
    3c3c:	00003205 	.word	0x00003205

00003c40 <_mci_sync_get_response_128>:

/**
 *  \brief Get 128 bits response of the last command.
 */
void _mci_sync_get_response_128(struct _mci_sync_device *const mci_dev, uint8_t *response)
{
    3c40:	b538      	push	{r3, r4, r5, lr}
    3c42:	460c      	mov	r4, r1
	uint32_t response_32;
	void *   hw;
	ASSERT(mci_dev && mci_dev->hw);
    3c44:	4605      	mov	r5, r0
    3c46:	b160      	cbz	r0, 3c62 <_mci_sync_get_response_128+0x22>
    3c48:	6800      	ldr	r0, [r0, #0]
    3c4a:	3000      	adds	r0, #0
    3c4c:	bf18      	it	ne
    3c4e:	2001      	movne	r0, #1
    3c50:	f240 1281 	movw	r2, #385	; 0x181
    3c54:	4911      	ldr	r1, [pc, #68]	; (3c9c <_mci_sync_get_response_128+0x5c>)
    3c56:	4b12      	ldr	r3, [pc, #72]	; (3ca0 <_mci_sync_get_response_128+0x60>)
    3c58:	4798      	blx	r3
	hw = mci_dev->hw;
    3c5a:	682d      	ldr	r5, [r5, #0]
    3c5c:	2102      	movs	r1, #2
    3c5e:	2303      	movs	r3, #3
    3c60:	e00b      	b.n	3c7a <_mci_sync_get_response_128+0x3a>
    3c62:	2000      	movs	r0, #0
    3c64:	e7f4      	b.n	3c50 <_mci_sync_get_response_128+0x10>
		response_32 = hri_sdhc_read_RR_reg(hw, i);
		if (i != 3) {
			*response = (response_32 >> 24) & 0xFF;
			response++;
		}
		*response = (response_32 >> 16) & 0xFF;
    3c66:	0c10      	lsrs	r0, r2, #16
    3c68:	7020      	strb	r0, [r4, #0]
		response++;
		*response = (response_32 >> 8) & 0xFF;
    3c6a:	0a10      	lsrs	r0, r2, #8
    3c6c:	7060      	strb	r0, [r4, #1]
		response++;
		*response = (response_32 >> 0) & 0xFF;
    3c6e:	70a2      	strb	r2, [r4, #2]
		response++;
    3c70:	3403      	adds	r4, #3
    3c72:	3b01      	subs	r3, #1
    3c74:	b2db      	uxtb	r3, r3
    3c76:	3901      	subs	r1, #1
    3c78:	b2c9      	uxtb	r1, r1
    3c7a:	1d1a      	adds	r2, r3, #4
    3c7c:	f855 2022 	ldr.w	r2, [r5, r2, lsl #2]
		if (i != 3) {
    3c80:	2b03      	cmp	r3, #3
    3c82:	d0f0      	beq.n	3c66 <_mci_sync_get_response_128+0x26>
			*response = (response_32 >> 24) & 0xFF;
    3c84:	0e10      	lsrs	r0, r2, #24
    3c86:	7020      	strb	r0, [r4, #0]
		*response = (response_32 >> 16) & 0xFF;
    3c88:	0c10      	lsrs	r0, r2, #16
    3c8a:	7060      	strb	r0, [r4, #1]
		*response = (response_32 >> 8) & 0xFF;
    3c8c:	0a10      	lsrs	r0, r2, #8
    3c8e:	70a0      	strb	r0, [r4, #2]
		*response = (response_32 >> 0) & 0xFF;
    3c90:	70e2      	strb	r2, [r4, #3]
		response++;
    3c92:	3404      	adds	r4, #4
	for (int8_t i = 3; i >= 0; i--) {
    3c94:	f011 0f80 	tst.w	r1, #128	; 0x80
    3c98:	d0eb      	beq.n	3c72 <_mci_sync_get_response_128+0x32>
    3c9a:	bd38      	pop	{r3, r4, r5, pc}
    3c9c:	000098c8 	.word	0x000098c8
    3ca0:	00003205 	.word	0x00003205

00003ca4 <_mci_sync_adtc_start>:
 *         An ADTC (Addressed Data Transfer Commands)
 *         command is used for read/write access.
 */
bool _mci_sync_adtc_start(struct _mci_sync_device *const mci_dev, uint32_t cmd, uint32_t arg, uint16_t block_size,
                          uint16_t nb_block, bool access_block)
{
    3ca4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    3ca8:	460d      	mov	r5, r1
    3caa:	4690      	mov	r8, r2
    3cac:	461f      	mov	r7, r3
    3cae:	f8bd 6018 	ldrh.w	r6, [sp, #24]
	uint32_t tmr;
	void *   hw;
	ASSERT(mci_dev && mci_dev->hw);
    3cb2:	4604      	mov	r4, r0
    3cb4:	2800      	cmp	r0, #0
    3cb6:	d032      	beq.n	3d1e <_mci_sync_adtc_start+0x7a>
    3cb8:	6800      	ldr	r0, [r0, #0]
    3cba:	3000      	adds	r0, #0
    3cbc:	bf18      	it	ne
    3cbe:	2001      	movne	r0, #1
    3cc0:	f240 129d 	movw	r2, #413	; 0x19d
    3cc4:	4920      	ldr	r1, [pc, #128]	; (3d48 <_mci_sync_adtc_start+0xa4>)
    3cc6:	4b21      	ldr	r3, [pc, #132]	; (3d4c <_mci_sync_adtc_start+0xa8>)
    3cc8:	4798      	blx	r3
	hw = mci_dev->hw;
    3cca:	6820      	ldr	r0, [r4, #0]
	return (((Sdhc *)hw)->PSR.reg & SDHC_PSR_CMDINHC) >> SDHC_PSR_CMDINHC_Pos;
    3ccc:	6a43      	ldr	r3, [r0, #36]	; 0x24

	/* No use without dma support */
	(void)access_block;

	/* Check Command Inhibit (CMD/DAT) in the Present State register */
	if (hri_sdhc_get_PSR_CMDINHC_bit(hw) || hri_sdhc_get_PSR_CMDINHD_bit(hw)) {
    3cce:	f013 0f01 	tst.w	r3, #1
    3cd2:	d12f      	bne.n	3d34 <_mci_sync_adtc_start+0x90>
	return (((Sdhc *)hw)->PSR.reg & SDHC_PSR_CMDINHD) >> SDHC_PSR_CMDINHD_Pos;
    3cd4:	6a43      	ldr	r3, [r0, #36]	; 0x24
    3cd6:	f013 0f02 	tst.w	r3, #2
    3cda:	d12e      	bne.n	3d3a <_mci_sync_adtc_start+0x96>
		return false;
	}

	if (cmd & MCI_CMD_WRITE) {
    3cdc:	f405 4300 	and.w	r3, r5, #32768	; 0x8000
		tmr = SDHC_TMR_DTDSEL_WRITE;
	} else {
		tmr = SDHC_TMR_DTDSEL_READ;
    3ce0:	2b00      	cmp	r3, #0
    3ce2:	bf14      	ite	ne
    3ce4:	2300      	movne	r3, #0
    3ce6:	2310      	moveq	r3, #16
	}

	if (cmd & MCI_CMD_SDIO_BYTE) {
    3ce8:	f415 3f80 	tst.w	r5, #65536	; 0x10000
    3cec:	d104      	bne.n	3cf8 <_mci_sync_adtc_start+0x54>
		tmr |= SDHC_TMR_MSBSEL_SINGLE;
	} else if (cmd & MCI_CMD_SDIO_BLOCK) {
    3cee:	f415 3f00 	tst.w	r5, #131072	; 0x20000
    3cf2:	d016      	beq.n	3d22 <_mci_sync_adtc_start+0x7e>
		tmr |= SDHC_TMR_BCEN | SDHC_TMR_MSBSEL_MULTIPLE;
    3cf4:	f043 0322 	orr.w	r3, r3, #34	; 0x22
	} else if (cmd & MCI_CMD_MULTI_BLOCK) {
		tmr |= SDHC_TMR_BCEN | SDHC_TMR_MSBSEL_MULTIPLE;
	} else {
		return false;
	}
	hri_sdhc_write_TMR_reg(hw, tmr);
    3cf8:	b29b      	uxth	r3, r3
	((Sdhc *)hw)->TMR.reg = data;
    3cfa:	8183      	strh	r3, [r0, #12]
	hri_sdhc_write_BSR_reg(hw, SDHC_BSR_BLOCKSIZE(block_size) | SDHC_BSR_BOUNDARY_4K);
    3cfc:	f3c7 0309 	ubfx	r3, r7, #0, #10
	((Sdhc *)hw)->BSR.reg = data;
    3d00:	8083      	strh	r3, [r0, #4]
	((Sdhc *)hw)->BCR.reg = data;
    3d02:	80c6      	strh	r6, [r0, #6]
	hri_sdhc_write_BCR_reg(hw, SDHC_BCR_BCNT(nb_block));

	mci_dev->mci_sync_trans_pos  = 0;
    3d04:	2200      	movs	r2, #0
    3d06:	2300      	movs	r3, #0
    3d08:	e9c4 2302 	strd	r2, r3, [r4, #8]
	mci_dev->mci_sync_block_size = block_size;
    3d0c:	8227      	strh	r7, [r4, #16]
	mci_dev->mci_sync_nb_block   = nb_block;
    3d0e:	8266      	strh	r6, [r4, #18]

	return _mci_send_cmd_execute(hw, SDHC_CR_DPSEL_DATA, cmd, arg);
    3d10:	4643      	mov	r3, r8
    3d12:	462a      	mov	r2, r5
    3d14:	2120      	movs	r1, #32
    3d16:	4c0e      	ldr	r4, [pc, #56]	; (3d50 <_mci_sync_adtc_start+0xac>)
    3d18:	47a0      	blx	r4
    3d1a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    3d1e:	2000      	movs	r0, #0
    3d20:	e7ce      	b.n	3cc0 <_mci_sync_adtc_start+0x1c>
	} else if (cmd & MCI_CMD_SINGLE_BLOCK) {
    3d22:	f415 2f00 	tst.w	r5, #524288	; 0x80000
    3d26:	d1e7      	bne.n	3cf8 <_mci_sync_adtc_start+0x54>
	} else if (cmd & MCI_CMD_MULTI_BLOCK) {
    3d28:	f415 1f80 	tst.w	r5, #1048576	; 0x100000
    3d2c:	d008      	beq.n	3d40 <_mci_sync_adtc_start+0x9c>
		tmr |= SDHC_TMR_BCEN | SDHC_TMR_MSBSEL_MULTIPLE;
    3d2e:	f043 0322 	orr.w	r3, r3, #34	; 0x22
    3d32:	e7e1      	b.n	3cf8 <_mci_sync_adtc_start+0x54>
		return false;
    3d34:	2000      	movs	r0, #0
    3d36:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    3d3a:	2000      	movs	r0, #0
    3d3c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return false;
    3d40:	2000      	movs	r0, #0
}
    3d42:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    3d46:	bf00      	nop
    3d48:	000098c8 	.word	0x000098c8
    3d4c:	00003205 	.word	0x00003205
    3d50:	000038d9 	.word	0x000038d9

00003d54 <_mci_sync_read_word>:

/**
 *  \brief Read a word on the line.
 */
bool _mci_sync_read_word(struct _mci_sync_device *const mci_dev, uint32_t *value)
{
    3d54:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    3d58:	460f      	mov	r7, r1
	uint32_t sr;
	uint8_t  nbytes;
	void *   hw;

	ASSERT(mci_dev && mci_dev->hw);
    3d5a:	4605      	mov	r5, r0
    3d5c:	b378      	cbz	r0, 3dbe <_mci_sync_read_word+0x6a>
    3d5e:	6800      	ldr	r0, [r0, #0]
    3d60:	3000      	adds	r0, #0
    3d62:	bf18      	it	ne
    3d64:	2001      	movne	r0, #1
    3d66:	f44f 72ed 	mov.w	r2, #474	; 0x1da
    3d6a:	493e      	ldr	r1, [pc, #248]	; (3e64 <_mci_sync_read_word+0x110>)
    3d6c:	4b3e      	ldr	r3, [pc, #248]	; (3e68 <_mci_sync_read_word+0x114>)
    3d6e:	4798      	blx	r3
	hw = mci_dev->hw;
    3d70:	682c      	ldr	r4, [r5, #0]

	/* Wait data available */
	nbytes = (mci_dev->mci_sync_block_size * mci_dev->mci_sync_nb_block - mci_dev->mci_sync_trans_pos < 4)
    3d72:	8a2a      	ldrh	r2, [r5, #16]
    3d74:	e9d5 0102 	ldrd	r0, r1, [r5, #8]
    3d78:	f8b5 8012 	ldrh.w	r8, [r5, #18]
    3d7c:	fb02 f808 	mul.w	r8, r2, r8
    3d80:	ea4f 79e8 	mov.w	r9, r8, asr #31
    3d84:	ebb8 0800 	subs.w	r8, r8, r0
    3d88:	eb69 0901 	sbc.w	r9, r9, r1
    3d8c:	f1b9 0f00 	cmp.w	r9, #0
    3d90:	bf08      	it	eq
    3d92:	f1b8 0f04 	cmpeq.w	r8, #4
    3d96:	d24f      	bcs.n	3e38 <_mci_sync_read_word+0xe4>
    3d98:	f002 0603 	and.w	r6, r2, #3
	             ? (mci_dev->mci_sync_block_size % 4)
	             : 4;

	if (mci_dev->mci_sync_trans_pos % mci_dev->mci_sync_block_size == 0) {
    3d9c:	b292      	uxth	r2, r2
    3d9e:	2300      	movs	r3, #0
    3da0:	f8df 80cc 	ldr.w	r8, [pc, #204]	; 3e70 <_mci_sync_read_word+0x11c>
    3da4:	47c0      	blx	r8
    3da6:	4313      	orrs	r3, r2
    3da8:	d04d      	beq.n	3e46 <_mci_sync_read_word+0xf2>
		} while (!hri_sdhc_get_NISTR_BRDRDY_bit(hw));
		hri_sdhc_set_NISTR_BRDRDY_bit(hw);
	}

	/* Read data */
	if (nbytes == 4) {
    3daa:	2e04      	cmp	r6, #4
    3dac:	d00f      	beq.n	3dce <_mci_sync_read_word+0x7a>
	return ((Sdhc *)hw)->BDPR.reg;
    3dae:	6a23      	ldr	r3, [r4, #32]
		*value = hri_sdhc_read_BDPR_reg(hw);
	} else {
		sr = hri_sdhc_read_BDPR_reg(hw);
		switch (nbytes) {
    3db0:	2e02      	cmp	r6, #2
    3db2:	d013      	beq.n	3ddc <_mci_sync_read_word+0x88>
    3db4:	2e03      	cmp	r6, #3
    3db6:	d00e      	beq.n	3dd6 <_mci_sync_read_word+0x82>
    3db8:	2e01      	cmp	r6, #1
    3dba:	d114      	bne.n	3de6 <_mci_sync_read_word+0x92>
    3dbc:	e011      	b.n	3de2 <_mci_sync_read_word+0x8e>
    3dbe:	2000      	movs	r0, #0
    3dc0:	e7d1      	b.n	3d66 <_mci_sync_read_word+0x12>
				_mci_reset(hw);
    3dc2:	4620      	mov	r0, r4
    3dc4:	4b29      	ldr	r3, [pc, #164]	; (3e6c <_mci_sync_read_word+0x118>)
    3dc6:	4798      	blx	r3
				return false;
    3dc8:	2000      	movs	r0, #0
    3dca:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    3dce:	6a23      	ldr	r3, [r4, #32]
		*value = hri_sdhc_read_BDPR_reg(hw);
    3dd0:	603b      	str	r3, [r7, #0]
    3dd2:	2604      	movs	r6, #4
    3dd4:	e007      	b.n	3de6 <_mci_sync_read_word+0x92>
		case 3:
			value[2] = sr >> 16 & 0xFF;
    3dd6:	f3c3 4207 	ubfx	r2, r3, #16, #8
    3dda:	60ba      	str	r2, [r7, #8]
		case 2:
			value[1] = sr >> 8 & 0xFF;
    3ddc:	f3c3 2207 	ubfx	r2, r3, #8, #8
    3de0:	607a      	str	r2, [r7, #4]
		case 1:
			value[0] = sr & 0xFF;
    3de2:	b2db      	uxtb	r3, r3
    3de4:	603b      	str	r3, [r7, #0]
			break;
		}
	}
	mci_dev->mci_sync_trans_pos += nbytes;
    3de6:	b2f6      	uxtb	r6, r6
    3de8:	2700      	movs	r7, #0
    3dea:	e9d5 2302 	ldrd	r2, r3, [r5, #8]
    3dee:	18b6      	adds	r6, r6, r2
    3df0:	415f      	adcs	r7, r3
    3df2:	e9c5 6702 	strd	r6, r7, [r5, #8]

	if (((uint64_t)mci_dev->mci_sync_block_size * mci_dev->mci_sync_nb_block) > mci_dev->mci_sync_trans_pos) {
    3df6:	8a2a      	ldrh	r2, [r5, #16]
    3df8:	8a68      	ldrh	r0, [r5, #18]
    3dfa:	fba2 2300 	umull	r2, r3, r2, r0
    3dfe:	429f      	cmp	r7, r3
    3e00:	bf08      	it	eq
    3e02:	4296      	cmpeq	r6, r2
    3e04:	d315      	bcc.n	3e32 <_mci_sync_read_word+0xde>
	return ((Sdhc *)hw)->EISTR.reg;
    3e06:	8e63      	ldrh	r3, [r4, #50]	; 0x32

	/* Wait end of transfer */
	do {
		sr = hri_sdhc_read_EISTR_reg(hw);

		if (sr & (SDHC_EISTR_DATTEO | SDHC_EISTR_DATCRC | SDHC_EISTR_DATEND)) {
    3e08:	f003 0370 	and.w	r3, r3, #112	; 0x70
    3e0c:	b95b      	cbnz	r3, 3e26 <_mci_sync_read_word+0xd2>
	tmp = ((Sdhc *)hw)->NISTR.reg;
    3e0e:	8e23      	ldrh	r3, [r4, #48]	; 0x30
			_mci_reset(hw);
			return false;
		}
	} while (!hri_sdhc_get_NISTR_TRFC_bit(hw));
    3e10:	f013 0f02 	tst.w	r3, #2
    3e14:	d0f7      	beq.n	3e06 <_mci_sync_read_word+0xb2>
	((Sdhc *)hw)->NISTR.reg |= SDHC_NISTR_TRFC;
    3e16:	8e23      	ldrh	r3, [r4, #48]	; 0x30
    3e18:	b29b      	uxth	r3, r3
    3e1a:	f043 0302 	orr.w	r3, r3, #2
    3e1e:	8623      	strh	r3, [r4, #48]	; 0x30
	hri_sdhc_set_NISTR_TRFC_bit(hw);
	return true;
    3e20:	2001      	movs	r0, #1
    3e22:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			_mci_reset(hw);
    3e26:	4620      	mov	r0, r4
    3e28:	4b10      	ldr	r3, [pc, #64]	; (3e6c <_mci_sync_read_word+0x118>)
    3e2a:	4798      	blx	r3
			return false;
    3e2c:	2000      	movs	r0, #0
    3e2e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return true;
    3e32:	2001      	movs	r0, #1
    3e34:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if (mci_dev->mci_sync_trans_pos % mci_dev->mci_sync_block_size == 0) {
    3e38:	b292      	uxth	r2, r2
    3e3a:	2300      	movs	r3, #0
    3e3c:	4e0c      	ldr	r6, [pc, #48]	; (3e70 <_mci_sync_read_word+0x11c>)
    3e3e:	47b0      	blx	r6
    3e40:	4313      	orrs	r3, r2
    3e42:	d1c4      	bne.n	3dce <_mci_sync_read_word+0x7a>
	nbytes = (mci_dev->mci_sync_block_size * mci_dev->mci_sync_nb_block - mci_dev->mci_sync_trans_pos < 4)
    3e44:	2604      	movs	r6, #4
	return ((Sdhc *)hw)->EISTR.reg;
    3e46:	8e63      	ldrh	r3, [r4, #50]	; 0x32
			if (sr & (SDHC_EISTR_DATTEO | SDHC_EISTR_DATCRC | SDHC_EISTR_DATEND)) {
    3e48:	f003 0370 	and.w	r3, r3, #112	; 0x70
    3e4c:	2b00      	cmp	r3, #0
    3e4e:	d1b8      	bne.n	3dc2 <_mci_sync_read_word+0x6e>
	tmp = ((Sdhc *)hw)->NISTR.reg;
    3e50:	8e23      	ldrh	r3, [r4, #48]	; 0x30
		} while (!hri_sdhc_get_NISTR_BRDRDY_bit(hw));
    3e52:	f013 0f20 	tst.w	r3, #32
    3e56:	d0f6      	beq.n	3e46 <_mci_sync_read_word+0xf2>
	((Sdhc *)hw)->NISTR.reg |= SDHC_NISTR_BRDRDY;
    3e58:	8e23      	ldrh	r3, [r4, #48]	; 0x30
    3e5a:	b29b      	uxth	r3, r3
    3e5c:	f043 0320 	orr.w	r3, r3, #32
    3e60:	8623      	strh	r3, [r4, #48]	; 0x30
    3e62:	e7a2      	b.n	3daa <_mci_sync_read_word+0x56>
    3e64:	000098c8 	.word	0x000098c8
    3e68:	00003205 	.word	0x00003205
    3e6c:	000038b1 	.word	0x000038b1
    3e70:	0000933d 	.word	0x0000933d

00003e74 <_mci_sync_write_word>:

/**
 *  \brief Write a word on the line
 */
bool _mci_sync_write_word(struct _mci_sync_device *const mci_dev, uint32_t value)
{
    3e74:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3e76:	460e      	mov	r6, r1
	uint32_t sr;
	uint8_t  nbytes;
	void *   hw;

	ASSERT(mci_dev && mci_dev->hw);
    3e78:	4605      	mov	r5, r0
    3e7a:	2800      	cmp	r0, #0
    3e7c:	d03d      	beq.n	3efa <_mci_sync_write_word+0x86>
    3e7e:	6800      	ldr	r0, [r0, #0]
    3e80:	3000      	adds	r0, #0
    3e82:	bf18      	it	ne
    3e84:	2001      	movne	r0, #1
    3e86:	f240 2219 	movw	r2, #537	; 0x219
    3e8a:	4923      	ldr	r1, [pc, #140]	; (3f18 <_mci_sync_write_word+0xa4>)
    3e8c:	4b23      	ldr	r3, [pc, #140]	; (3f1c <_mci_sync_write_word+0xa8>)
    3e8e:	4798      	blx	r3
	hw = mci_dev->hw;
    3e90:	682c      	ldr	r4, [r5, #0]

	/* Wait data available */
	nbytes = 4; //( mci_dev->mci_sync_block_size & 0x3 ) ? 1 : 4;
	if (mci_dev->mci_sync_trans_pos % mci_dev->mci_sync_block_size == 0) {
    3e92:	8a2a      	ldrh	r2, [r5, #16]
    3e94:	2300      	movs	r3, #0
    3e96:	e9d5 0102 	ldrd	r0, r1, [r5, #8]
    3e9a:	4f21      	ldr	r7, [pc, #132]	; (3f20 <_mci_sync_write_word+0xac>)
    3e9c:	47b8      	blx	r7
    3e9e:	4313      	orrs	r3, r2
    3ea0:	d10c      	bne.n	3ebc <_mci_sync_write_word+0x48>
	return ((Sdhc *)hw)->EISTR.reg;
    3ea2:	8e63      	ldrh	r3, [r4, #50]	; 0x32
		do {
			sr = hri_sdhc_read_EISTR_reg(hw);

			if (sr & (SDHC_EISTR_DATTEO | SDHC_EISTR_DATCRC | SDHC_EISTR_DATEND)) {
    3ea4:	f003 0370 	and.w	r3, r3, #112	; 0x70
    3ea8:	bb4b      	cbnz	r3, 3efe <_mci_sync_write_word+0x8a>
	tmp = ((Sdhc *)hw)->NISTR.reg;
    3eaa:	8e23      	ldrh	r3, [r4, #48]	; 0x30
				_mci_reset(hw);
				return false;
			}
		} while (!hri_sdhc_get_NISTR_BWRRDY_bit(hw));
    3eac:	f013 0f10 	tst.w	r3, #16
    3eb0:	d0f7      	beq.n	3ea2 <_mci_sync_write_word+0x2e>
	((Sdhc *)hw)->NISTR.reg |= SDHC_NISTR_BWRRDY;
    3eb2:	8e23      	ldrh	r3, [r4, #48]	; 0x30
    3eb4:	b29b      	uxth	r3, r3
    3eb6:	f043 0310 	orr.w	r3, r3, #16
    3eba:	8623      	strh	r3, [r4, #48]	; 0x30
	((Sdhc *)hw)->BDPR.reg = data;
    3ebc:	6226      	str	r6, [r4, #32]
		hri_sdhc_set_NISTR_BWRRDY_bit(hw);
	}
	/* Write data */
	hri_sdhc_write_BDPR_reg(hw, value);
	mci_dev->mci_sync_trans_pos += nbytes;
    3ebe:	e9d5 2302 	ldrd	r2, r3, [r5, #8]
    3ec2:	3204      	adds	r2, #4
    3ec4:	f143 0300 	adc.w	r3, r3, #0
    3ec8:	e9c5 2302 	strd	r2, r3, [r5, #8]

	if (((uint64_t)mci_dev->mci_sync_block_size * mci_dev->mci_sync_nb_block) > mci_dev->mci_sync_trans_pos) {
    3ecc:	8a28      	ldrh	r0, [r5, #16]
    3ece:	8a6e      	ldrh	r6, [r5, #18]
    3ed0:	fba0 0106 	umull	r0, r1, r0, r6
    3ed4:	428b      	cmp	r3, r1
    3ed6:	bf08      	it	eq
    3ed8:	4282      	cmpeq	r2, r0
    3eda:	d31a      	bcc.n	3f12 <_mci_sync_write_word+0x9e>
	return ((Sdhc *)hw)->EISTR.reg;
    3edc:	8e63      	ldrh	r3, [r4, #50]	; 0x32

	/* Wait end of transfer */
	do {
		sr = hri_sdhc_read_EISTR_reg(hw);

		if (sr & (SDHC_EISTR_DATTEO | SDHC_EISTR_DATCRC | SDHC_EISTR_DATEND)) {
    3ede:	f003 0370 	and.w	r3, r3, #112	; 0x70
    3ee2:	b98b      	cbnz	r3, 3f08 <_mci_sync_write_word+0x94>
	tmp = ((Sdhc *)hw)->NISTR.reg;
    3ee4:	8e23      	ldrh	r3, [r4, #48]	; 0x30
			_mci_reset(hw);
			return false;
		}
	} while (!hri_sdhc_get_NISTR_TRFC_bit(hw));
    3ee6:	f013 0f02 	tst.w	r3, #2
    3eea:	d0f7      	beq.n	3edc <_mci_sync_write_word+0x68>
	((Sdhc *)hw)->NISTR.reg |= SDHC_NISTR_TRFC;
    3eec:	8e23      	ldrh	r3, [r4, #48]	; 0x30
    3eee:	b29b      	uxth	r3, r3
    3ef0:	f043 0302 	orr.w	r3, r3, #2
    3ef4:	8623      	strh	r3, [r4, #48]	; 0x30
	hri_sdhc_set_NISTR_TRFC_bit(hw);
	return true;
    3ef6:	2001      	movs	r0, #1
    3ef8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    3efa:	2000      	movs	r0, #0
    3efc:	e7c3      	b.n	3e86 <_mci_sync_write_word+0x12>
				_mci_reset(hw);
    3efe:	4620      	mov	r0, r4
    3f00:	4b08      	ldr	r3, [pc, #32]	; (3f24 <_mci_sync_write_word+0xb0>)
    3f02:	4798      	blx	r3
				return false;
    3f04:	2000      	movs	r0, #0
    3f06:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			_mci_reset(hw);
    3f08:	4620      	mov	r0, r4
    3f0a:	4b06      	ldr	r3, [pc, #24]	; (3f24 <_mci_sync_write_word+0xb0>)
    3f0c:	4798      	blx	r3
			return false;
    3f0e:	2000      	movs	r0, #0
    3f10:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return true;
    3f12:	2001      	movs	r0, #1
}
    3f14:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    3f16:	bf00      	nop
    3f18:	000098c8 	.word	0x000098c8
    3f1c:	00003205 	.word	0x00003205
    3f20:	0000933d 	.word	0x0000933d
    3f24:	000038b1 	.word	0x000038b1

00003f28 <_mci_sync_start_read_blocks>:
/**
 *  \brief Start a read blocks transfer on the line
 *  Note: The driver will use the DMA available to speed up the transfer.
 */
bool _mci_sync_start_read_blocks(struct _mci_sync_device *const mci_dev, void *dst, uint16_t nb_block)
{
    3f28:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    3f2c:	460e      	mov	r6, r1
    3f2e:	4690      	mov	r8, r2
	uint32_t nb_data;
	uint8_t *ptr    = (uint8_t *)dst;
	uint8_t  nbytes = 4;

	ASSERT(mci_dev && mci_dev->hw);
    3f30:	4607      	mov	r7, r0
    3f32:	b300      	cbz	r0, 3f76 <_mci_sync_start_read_blocks+0x4e>
    3f34:	6800      	ldr	r0, [r0, #0]
    3f36:	3000      	adds	r0, #0
    3f38:	bf18      	it	ne
    3f3a:	2001      	movne	r0, #1
    3f3c:	4d18      	ldr	r5, [pc, #96]	; (3fa0 <_mci_sync_start_read_blocks+0x78>)
    3f3e:	f44f 7212 	mov.w	r2, #584	; 0x248
    3f42:	4629      	mov	r1, r5
    3f44:	4c17      	ldr	r4, [pc, #92]	; (3fa4 <_mci_sync_start_read_blocks+0x7c>)
    3f46:	47a0      	blx	r4
	ASSERT(nb_block);
    3f48:	f240 2249 	movw	r2, #585	; 0x249
    3f4c:	4629      	mov	r1, r5
    3f4e:	f118 0000 	adds.w	r0, r8, #0
    3f52:	bf18      	it	ne
    3f54:	2001      	movne	r0, #1
    3f56:	47a0      	blx	r4
	ASSERT(dst);
    3f58:	f240 224a 	movw	r2, #586	; 0x24a
    3f5c:	4629      	mov	r1, r5
    3f5e:	1c30      	adds	r0, r6, #0
    3f60:	bf18      	it	ne
    3f62:	2001      	movne	r0, #1
    3f64:	47a0      	blx	r4

	nb_data = nb_block * mci_dev->mci_sync_block_size;
    3f66:	8a3d      	ldrh	r5, [r7, #16]
    3f68:	fb08 f505 	mul.w	r5, r8, r5

	while (nb_data) {
    3f6c:	b1a5      	cbz	r5, 3f98 <_mci_sync_start_read_blocks+0x70>
    3f6e:	2404      	movs	r4, #4
		_mci_sync_read_word(mci_dev, (uint32_t *)ptr);
    3f70:	f8df 8034 	ldr.w	r8, [pc, #52]	; 3fa8 <_mci_sync_start_read_blocks+0x80>
    3f74:	e004      	b.n	3f80 <_mci_sync_start_read_blocks+0x58>
    3f76:	2000      	movs	r0, #0
    3f78:	e7e0      	b.n	3f3c <_mci_sync_start_read_blocks+0x14>
		if (nb_data < nbytes) {
			nbytes = mci_dev->mci_sync_block_size % nbytes;
		}
		nb_data -= nbytes;
		ptr += nbytes;
    3f7a:	4426      	add	r6, r4
	while (nb_data) {
    3f7c:	1b2d      	subs	r5, r5, r4
    3f7e:	d00b      	beq.n	3f98 <_mci_sync_start_read_blocks+0x70>
		_mci_sync_read_word(mci_dev, (uint32_t *)ptr);
    3f80:	4631      	mov	r1, r6
    3f82:	4638      	mov	r0, r7
    3f84:	47c0      	blx	r8
		if (nb_data < nbytes) {
    3f86:	42ac      	cmp	r4, r5
    3f88:	d9f7      	bls.n	3f7a <_mci_sync_start_read_blocks+0x52>
			nbytes = mci_dev->mci_sync_block_size % nbytes;
    3f8a:	8a3b      	ldrh	r3, [r7, #16]
    3f8c:	fb93 f2f4 	sdiv	r2, r3, r4
    3f90:	fb04 3412 	mls	r4, r4, r2, r3
    3f94:	b2e4      	uxtb	r4, r4
    3f96:	e7f0      	b.n	3f7a <_mci_sync_start_read_blocks+0x52>
	}

	return true;
}
    3f98:	2001      	movs	r0, #1
    3f9a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    3f9e:	bf00      	nop
    3fa0:	000098c8 	.word	0x000098c8
    3fa4:	00003205 	.word	0x00003205
    3fa8:	00003d55 	.word	0x00003d55

00003fac <_mci_sync_start_write_blocks>:
/**
 *  \brief Start a write blocks transfer on the line
 *  Note: The driver will use the DMA available to speed up the transfer.
 */
bool _mci_sync_start_write_blocks(struct _mci_sync_device *const mci_dev, const void *src, uint16_t nb_block)
{
    3fac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    3fb0:	460e      	mov	r6, r1
    3fb2:	4690      	mov	r8, r2
	uint32_t nb_data;
	uint8_t *ptr    = (uint8_t *)src;
	uint8_t  nbytes = 4;

	ASSERT(mci_dev && mci_dev->hw);
    3fb4:	4607      	mov	r7, r0
    3fb6:	b300      	cbz	r0, 3ffa <_mci_sync_start_write_blocks+0x4e>
    3fb8:	6800      	ldr	r0, [r0, #0]
    3fba:	3000      	adds	r0, #0
    3fbc:	bf18      	it	ne
    3fbe:	2001      	movne	r0, #1
    3fc0:	4d18      	ldr	r5, [pc, #96]	; (4024 <_mci_sync_start_write_blocks+0x78>)
    3fc2:	f44f 7219 	mov.w	r2, #612	; 0x264
    3fc6:	4629      	mov	r1, r5
    3fc8:	4c17      	ldr	r4, [pc, #92]	; (4028 <_mci_sync_start_write_blocks+0x7c>)
    3fca:	47a0      	blx	r4
	ASSERT(nb_block);
    3fcc:	f240 2265 	movw	r2, #613	; 0x265
    3fd0:	4629      	mov	r1, r5
    3fd2:	f118 0000 	adds.w	r0, r8, #0
    3fd6:	bf18      	it	ne
    3fd8:	2001      	movne	r0, #1
    3fda:	47a0      	blx	r4
	ASSERT(src);
    3fdc:	f240 2266 	movw	r2, #614	; 0x266
    3fe0:	4629      	mov	r1, r5
    3fe2:	1c30      	adds	r0, r6, #0
    3fe4:	bf18      	it	ne
    3fe6:	2001      	movne	r0, #1
    3fe8:	47a0      	blx	r4

	nb_data = nb_block * mci_dev->mci_sync_block_size;
    3fea:	8a3d      	ldrh	r5, [r7, #16]
    3fec:	fb08 f505 	mul.w	r5, r8, r5

	while (nb_data) {
    3ff0:	b1a5      	cbz	r5, 401c <_mci_sync_start_write_blocks+0x70>
    3ff2:	2404      	movs	r4, #4
		_mci_sync_write_word(mci_dev, *(uint32_t *)ptr);
    3ff4:	f8df 8034 	ldr.w	r8, [pc, #52]	; 402c <_mci_sync_start_write_blocks+0x80>
    3ff8:	e004      	b.n	4004 <_mci_sync_start_write_blocks+0x58>
    3ffa:	2000      	movs	r0, #0
    3ffc:	e7e0      	b.n	3fc0 <_mci_sync_start_write_blocks+0x14>
		if (nb_data < nbytes) {
			nbytes = mci_dev->mci_sync_block_size % nbytes;
		}
		nb_data -= nbytes;
		ptr += nbytes;
    3ffe:	4426      	add	r6, r4
	while (nb_data) {
    4000:	1b2d      	subs	r5, r5, r4
    4002:	d00b      	beq.n	401c <_mci_sync_start_write_blocks+0x70>
		_mci_sync_write_word(mci_dev, *(uint32_t *)ptr);
    4004:	6831      	ldr	r1, [r6, #0]
    4006:	4638      	mov	r0, r7
    4008:	47c0      	blx	r8
		if (nb_data < nbytes) {
    400a:	42ac      	cmp	r4, r5
    400c:	d9f7      	bls.n	3ffe <_mci_sync_start_write_blocks+0x52>
			nbytes = mci_dev->mci_sync_block_size % nbytes;
    400e:	8a3b      	ldrh	r3, [r7, #16]
    4010:	fb93 f2f4 	sdiv	r2, r3, r4
    4014:	fb04 3412 	mls	r4, r4, r2, r3
    4018:	b2e4      	uxtb	r4, r4
    401a:	e7f0      	b.n	3ffe <_mci_sync_start_write_blocks+0x52>
	}

	return true;
}
    401c:	2001      	movs	r0, #1
    401e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    4022:	bf00      	nop
    4024:	000098c8 	.word	0x000098c8
    4028:	00003205 	.word	0x00003205
    402c:	00003e75 	.word	0x00003e75

00004030 <_mci_sync_wait_end_of_read_blocks>:

/**
 *  \brief Wait the end of transfer initiated by mci_start_read_blocks()
 */
bool _mci_sync_wait_end_of_read_blocks(struct _mci_sync_device *const mci_dev)
{
    4030:	b508      	push	{r3, lr}
	ASSERT(mci_dev && mci_dev->hw);
    4032:	b150      	cbz	r0, 404a <_mci_sync_wait_end_of_read_blocks+0x1a>
    4034:	6800      	ldr	r0, [r0, #0]
    4036:	3000      	adds	r0, #0
    4038:	bf18      	it	ne
    403a:	2001      	movne	r0, #1
    403c:	f240 227b 	movw	r2, #635	; 0x27b
    4040:	4903      	ldr	r1, [pc, #12]	; (4050 <_mci_sync_wait_end_of_read_blocks+0x20>)
    4042:	4b04      	ldr	r3, [pc, #16]	; (4054 <_mci_sync_wait_end_of_read_blocks+0x24>)
    4044:	4798      	blx	r3

	/* Always return true for sync read blocks */
	return true;
}
    4046:	2001      	movs	r0, #1
    4048:	bd08      	pop	{r3, pc}
    404a:	2000      	movs	r0, #0
    404c:	e7f6      	b.n	403c <_mci_sync_wait_end_of_read_blocks+0xc>
    404e:	bf00      	nop
    4050:	000098c8 	.word	0x000098c8
    4054:	00003205 	.word	0x00003205

00004058 <_mci_sync_wait_end_of_write_blocks>:

/**
 *  \brief Wait the end of transfer initiated by mci_start_write_blocks()
 */
bool _mci_sync_wait_end_of_write_blocks(struct _mci_sync_device *const mci_dev)
{
    4058:	b508      	push	{r3, lr}
	ASSERT(mci_dev && mci_dev->hw);
    405a:	b150      	cbz	r0, 4072 <_mci_sync_wait_end_of_write_blocks+0x1a>
    405c:	6800      	ldr	r0, [r0, #0]
    405e:	3000      	adds	r0, #0
    4060:	bf18      	it	ne
    4062:	2001      	movne	r0, #1
    4064:	f240 2286 	movw	r2, #646	; 0x286
    4068:	4903      	ldr	r1, [pc, #12]	; (4078 <_mci_sync_wait_end_of_write_blocks+0x20>)
    406a:	4b04      	ldr	r3, [pc, #16]	; (407c <_mci_sync_wait_end_of_write_blocks+0x24>)
    406c:	4798      	blx	r3

	/* Always return true for sync write blocks */
	return true;
}
    406e:	2001      	movs	r0, #1
    4070:	bd08      	pop	{r3, pc}
    4072:	2000      	movs	r0, #0
    4074:	e7f6      	b.n	4064 <_mci_sync_wait_end_of_write_blocks+0xc>
    4076:	bf00      	nop
    4078:	000098c8 	.word	0x000098c8
    407c:	00003205 	.word	0x00003205

00004080 <_sercom_get_hardware_index>:

/**
 * \brief Retrieve ordinal number of the given sercom hardware instance
 */
static uint8_t _sercom_get_hardware_index(const void *const hw)
{
    4080:	b470      	push	{r4, r5, r6}
    4082:	b089      	sub	sp, #36	; 0x24
    4084:	4606      	mov	r6, r0
	Sercom *const sercom_modules[] = SERCOM_INSTS;
    4086:	466c      	mov	r4, sp
    4088:	4d0d      	ldr	r5, [pc, #52]	; (40c0 <_sercom_get_hardware_index+0x40>)
    408a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    408c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    408e:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
    4092:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
	/* Find index for SERCOM instance. */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
		if ((uint32_t)hw == (uint32_t)sercom_modules[i]) {
    4096:	9b00      	ldr	r3, [sp, #0]
    4098:	42b3      	cmp	r3, r6
    409a:	d00d      	beq.n	40b8 <_sercom_get_hardware_index+0x38>
    409c:	4631      	mov	r1, r6
    409e:	ab01      	add	r3, sp, #4
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    40a0:	2001      	movs	r0, #1
		if ((uint32_t)hw == (uint32_t)sercom_modules[i]) {
    40a2:	f853 2b04 	ldr.w	r2, [r3], #4
    40a6:	428a      	cmp	r2, r1
    40a8:	d007      	beq.n	40ba <_sercom_get_hardware_index+0x3a>
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    40aa:	3001      	adds	r0, #1
    40ac:	2808      	cmp	r0, #8
    40ae:	d1f8      	bne.n	40a2 <_sercom_get_hardware_index+0x22>
			return i;
		}
	}
	return 0;
    40b0:	2000      	movs	r0, #0
}
    40b2:	b009      	add	sp, #36	; 0x24
    40b4:	bc70      	pop	{r4, r5, r6}
    40b6:	4770      	bx	lr
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    40b8:	2000      	movs	r0, #0
			return i;
    40ba:	b2c0      	uxtb	r0, r0
    40bc:	e7f9      	b.n	40b2 <_sercom_get_hardware_index+0x32>
    40be:	bf00      	nop
    40c0:	000098e0 	.word	0x000098e0

000040c4 <_sercom_get_irq_num>:

/**
 * \brief Retrieve IRQ number for the given hardware instance
 */
static uint8_t _sercom_get_irq_num(const void *const hw)
{
    40c4:	b508      	push	{r3, lr}
	return SERCOM0_0_IRQn + (_sercom_get_hardware_index(hw) << 2);
    40c6:	4b03      	ldr	r3, [pc, #12]	; (40d4 <_sercom_get_irq_num+0x10>)
    40c8:	4798      	blx	r3
    40ca:	0080      	lsls	r0, r0, #2
    40cc:	302e      	adds	r0, #46	; 0x2e
}
    40ce:	f000 00fe 	and.w	r0, r0, #254	; 0xfe
    40d2:	bd08      	pop	{r3, pc}
    40d4:	00004081 	.word	0x00004081

000040d8 <_spi_sync_enable>:
	};
}

static inline bool hri_sercomspi_is_syncing(const void *const hw, hri_sercomspi_syncbusy_reg_t reg)
{
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
    40d8:	69c3      	ldr	r3, [r0, #28]
 *
 * \return Enabling status
 */
static int32_t _spi_sync_enable(void *const hw)
{
	if (hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_SWRST)) {
    40da:	f013 0f01 	tst.w	r3, #1
    40de:	d109      	bne.n	40f4 <_spi_sync_enable+0x1c>
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    40e0:	69c3      	ldr	r3, [r0, #28]
    40e2:	f013 0f03 	tst.w	r3, #3
    40e6:	d1fb      	bne.n	40e0 <_spi_sync_enable+0x8>

static inline void hri_sercomspi_set_CTRLA_ENABLE_bit(const void *const hw)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
	((Sercom *)hw)->SPI.CTRLA.reg |= SERCOM_SPI_CTRLA_ENABLE;
    40e8:	6803      	ldr	r3, [r0, #0]
    40ea:	f043 0302 	orr.w	r3, r3, #2
    40ee:	6003      	str	r3, [r0, #0]
		return ERR_BUSY;
	}

	hri_sercomspi_set_CTRLA_ENABLE_bit(hw);

	return ERR_NONE;
    40f0:	2000      	movs	r0, #0
    40f2:	4770      	bx	lr
		return ERR_BUSY;
    40f4:	f06f 0003 	mvn.w	r0, #3
}
    40f8:	4770      	bx	lr
	...

000040fc <_spi_async_enable>:
 *  \param[in] hw Pointer to the hardware register base.
 *
 * \return Enabling status
 */
static int32_t _spi_async_enable(void *const hw)
{
    40fc:	b538      	push	{r3, r4, r5, lr}
    40fe:	4604      	mov	r4, r0
	_spi_sync_enable(hw);
    4100:	4b0b      	ldr	r3, [pc, #44]	; (4130 <_spi_async_enable+0x34>)
    4102:	4798      	blx	r3
	uint8_t irq = _sercom_get_irq_num(hw);
    4104:	4620      	mov	r0, r4
    4106:	4b0b      	ldr	r3, [pc, #44]	; (4134 <_spi_async_enable+0x38>)
    4108:	4798      	blx	r3
    410a:	1d01      	adds	r1, r0, #4
    410c:	b2c9      	uxtb	r1, r1
    410e:	2501      	movs	r5, #1
    4110:	4c09      	ldr	r4, [pc, #36]	; (4138 <_spi_async_enable+0x3c>)
	for (uint32_t i = 0; i < 4; i++) {
		NVIC_EnableIRQ((IRQn_Type)irq++);
    4112:	1c43      	adds	r3, r0, #1
    4114:	b2db      	uxtb	r3, r3
    4116:	0942      	lsrs	r2, r0, #5
    4118:	f000 001f 	and.w	r0, r0, #31
    411c:	fa05 f000 	lsl.w	r0, r5, r0
    4120:	f844 0022 	str.w	r0, [r4, r2, lsl #2]
    4124:	4618      	mov	r0, r3
	for (uint32_t i = 0; i < 4; i++) {
    4126:	4299      	cmp	r1, r3
    4128:	d1f3      	bne.n	4112 <_spi_async_enable+0x16>
	}

	return ERR_NONE;
}
    412a:	2000      	movs	r0, #0
    412c:	bd38      	pop	{r3, r4, r5, pc}
    412e:	bf00      	nop
    4130:	000040d9 	.word	0x000040d9
    4134:	000040c5 	.word	0x000040c5
    4138:	e000e100 	.word	0xe000e100

0000413c <_spi_handler>:
/**
 *  \brief IRQ handler used
 *  \param[in, out] p Pointer to SPI device instance.
 */
static void _spi_handler(struct _spi_async_dev *dev)
{
    413c:	b508      	push	{r3, lr}
	void *                      hw = dev->prvt;
    413e:	6802      	ldr	r2, [r0, #0]
	return ((Sercom *)hw)->SPI.INTFLAG.reg;
    4140:	7e11      	ldrb	r1, [r2, #24]
	return ((Sercom *)hw)->SPI.INTENSET.reg;
    4142:	7d93      	ldrb	r3, [r2, #22]
	hri_sercomspi_intflag_reg_t st;

	st = hri_sercomspi_read_INTFLAG_reg(hw);
	st &= hri_sercomspi_read_INTEN_reg(hw);
    4144:	400b      	ands	r3, r1

	if (st & SERCOM_SPI_INTFLAG_DRE) {
    4146:	f013 0f01 	tst.w	r3, #1
    414a:	d109      	bne.n	4160 <_spi_handler+0x24>
		dev->callbacks.tx(dev);
	} else if (st & SERCOM_SPI_INTFLAG_RXC) {
    414c:	f013 0f04 	tst.w	r3, #4
    4150:	d109      	bne.n	4166 <_spi_handler+0x2a>
		dev->callbacks.rx(dev);
	} else if (st & SERCOM_SPI_INTFLAG_TXC) {
    4152:	f013 0f02 	tst.w	r3, #2
    4156:	d109      	bne.n	416c <_spi_handler+0x30>
		hri_sercomspi_clear_INTFLAG_reg(hw, SERCOM_SPI_INTFLAG_TXC);
		dev->callbacks.complete(dev, 0);
	} else if (st & SERCOM_SPI_INTFLAG_ERROR) {
    4158:	f013 0f80 	tst.w	r3, #128	; 0x80
    415c:	d10c      	bne.n	4178 <_spi_handler+0x3c>
    415e:	bd08      	pop	{r3, pc}
		dev->callbacks.tx(dev);
    4160:	6883      	ldr	r3, [r0, #8]
    4162:	4798      	blx	r3
    4164:	bd08      	pop	{r3, pc}
		dev->callbacks.rx(dev);
    4166:	68c3      	ldr	r3, [r0, #12]
    4168:	4798      	blx	r3
    416a:	bd08      	pop	{r3, pc}
	((Sercom *)hw)->SPI.INTFLAG.reg = mask;
    416c:	2302      	movs	r3, #2
    416e:	7613      	strb	r3, [r2, #24]
		dev->callbacks.complete(dev, 0);
    4170:	6903      	ldr	r3, [r0, #16]
    4172:	2100      	movs	r1, #0
    4174:	4798      	blx	r3
    4176:	bd08      	pop	{r3, pc}
}

static inline void hri_sercomspi_clear_STATUS_reg(const void *const hw, hri_sercomspi_status_reg_t mask)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->SPI.STATUS.reg = mask;
    4178:	2304      	movs	r3, #4
    417a:	8353      	strh	r3, [r2, #26]
	((Sercom *)hw)->SPI.INTFLAG.reg = mask;
    417c:	2380      	movs	r3, #128	; 0x80
    417e:	7613      	strb	r3, [r2, #24]
		hri_sercomspi_clear_STATUS_reg(hw, SERCOM_SPI_STATUS_BUFOVF);
		hri_sercomspi_clear_INTFLAG_reg(hw, SERCOM_SPI_INTFLAG_ERROR);
		dev->callbacks.complete(dev, ERR_OVERFLOW);
    4180:	6903      	ldr	r3, [r0, #16]
    4182:	f06f 0112 	mvn.w	r1, #18
    4186:	4798      	blx	r3
	}
}
    4188:	e7e9      	b.n	415e <_spi_handler+0x22>
	...

0000418c <SERCOM0_0_Handler>:

/**
 * \internal Sercom interrupt handler
 */
void SERCOM0_0_Handler(void)
{
    418c:	b508      	push	{r3, lr}
	_spi_handler(_sercom0_dev);
    418e:	4b02      	ldr	r3, [pc, #8]	; (4198 <SERCOM0_0_Handler+0xc>)
    4190:	6818      	ldr	r0, [r3, #0]
    4192:	4b02      	ldr	r3, [pc, #8]	; (419c <SERCOM0_0_Handler+0x10>)
    4194:	4798      	blx	r3
    4196:	bd08      	pop	{r3, pc}
    4198:	200002c4 	.word	0x200002c4
    419c:	0000413d 	.word	0x0000413d

000041a0 <SERCOM0_1_Handler>:
}
/**
 * \internal Sercom interrupt handler
 */
void SERCOM0_1_Handler(void)
{
    41a0:	b508      	push	{r3, lr}
	_spi_handler(_sercom0_dev);
    41a2:	4b02      	ldr	r3, [pc, #8]	; (41ac <SERCOM0_1_Handler+0xc>)
    41a4:	6818      	ldr	r0, [r3, #0]
    41a6:	4b02      	ldr	r3, [pc, #8]	; (41b0 <SERCOM0_1_Handler+0x10>)
    41a8:	4798      	blx	r3
    41aa:	bd08      	pop	{r3, pc}
    41ac:	200002c4 	.word	0x200002c4
    41b0:	0000413d 	.word	0x0000413d

000041b4 <SERCOM0_2_Handler>:
}
/**
 * \internal Sercom interrupt handler
 */
void SERCOM0_2_Handler(void)
{
    41b4:	b508      	push	{r3, lr}
	_spi_handler(_sercom0_dev);
    41b6:	4b02      	ldr	r3, [pc, #8]	; (41c0 <SERCOM0_2_Handler+0xc>)
    41b8:	6818      	ldr	r0, [r3, #0]
    41ba:	4b02      	ldr	r3, [pc, #8]	; (41c4 <SERCOM0_2_Handler+0x10>)
    41bc:	4798      	blx	r3
    41be:	bd08      	pop	{r3, pc}
    41c0:	200002c4 	.word	0x200002c4
    41c4:	0000413d 	.word	0x0000413d

000041c8 <SERCOM0_3_Handler>:
}
/**
 * \internal Sercom interrupt handler
 */
void SERCOM0_3_Handler(void)
{
    41c8:	b508      	push	{r3, lr}
	_spi_handler(_sercom0_dev);
    41ca:	4b02      	ldr	r3, [pc, #8]	; (41d4 <SERCOM0_3_Handler+0xc>)
    41cc:	6818      	ldr	r0, [r3, #0]
    41ce:	4b02      	ldr	r3, [pc, #8]	; (41d8 <SERCOM0_3_Handler+0x10>)
    41d0:	4798      	blx	r3
    41d2:	bd08      	pop	{r3, pc}
    41d4:	200002c4 	.word	0x200002c4
    41d8:	0000413d 	.word	0x0000413d

000041dc <_spi_m_sync_init>:
}

int32_t _spi_m_sync_init(struct _spi_m_sync_dev *dev, void *const hw)
{
    41dc:	b570      	push	{r4, r5, r6, lr}
    41de:	4606      	mov	r6, r0
    41e0:	460c      	mov	r4, r1
	uint8_t n = _sercom_get_hardware_index((const void *)hw_addr);
    41e2:	4608      	mov	r0, r1
    41e4:	4b4d      	ldr	r3, [pc, #308]	; (431c <_spi_m_sync_init+0x140>)
    41e6:	4798      	blx	r3
		if (sercomspi_regs[i].n == n) {
    41e8:	b140      	cbz	r0, 41fc <_spi_m_sync_init+0x20>
	const struct sercomspi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);

	ASSERT(dev && hw);
    41ea:	2e00      	cmp	r6, #0
    41ec:	f000 8083 	beq.w	42f6 <_spi_m_sync_init+0x11a>
    41f0:	2c00      	cmp	r4, #0
    41f2:	f040 8089 	bne.w	4308 <_spi_m_sync_init+0x12c>
	return NULL;
    41f6:	2500      	movs	r5, #0
	ASSERT(dev && hw);
    41f8:	2000      	movs	r0, #0
    41fa:	e005      	b.n	4208 <_spi_m_sync_init+0x2c>
    41fc:	2e00      	cmp	r6, #0
    41fe:	d051      	beq.n	42a4 <_spi_m_sync_init+0xc8>
    4200:	2c00      	cmp	r4, #0
    4202:	d04d      	beq.n	42a0 <_spi_m_sync_init+0xc4>
			return &sercomspi_regs[i];
    4204:	4d46      	ldr	r5, [pc, #280]	; (4320 <_spi_m_sync_init+0x144>)
	ASSERT(dev && hw);
    4206:	2001      	movs	r0, #1
    4208:	f640 126d 	movw	r2, #2413	; 0x96d
    420c:	4945      	ldr	r1, [pc, #276]	; (4324 <_spi_m_sync_init+0x148>)
    420e:	4b46      	ldr	r3, [pc, #280]	; (4328 <_spi_m_sync_init+0x14c>)
    4210:	4798      	blx	r3

	if (regs == NULL) {
    4212:	2d00      	cmp	r5, #0
    4214:	d069      	beq.n	42ea <_spi_m_sync_init+0x10e>
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    4216:	69e3      	ldr	r3, [r4, #28]
    4218:	f013 0f01 	tst.w	r3, #1
    421c:	d1fb      	bne.n	4216 <_spi_m_sync_init+0x3a>
    421e:	69e3      	ldr	r3, [r4, #28]
    4220:	f013 0f03 	tst.w	r3, #3
    4224:	d1fb      	bne.n	421e <_spi_m_sync_init+0x42>
	tmp = ((Sercom *)hw)->SPI.CTRLA.reg;
    4226:	6823      	ldr	r3, [r4, #0]
		return ERR_INVALID_ARG;
	}

	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST);
	if (hri_sercomspi_get_CTRLA_ENABLE_bit(hw)) {
    4228:	f013 0f02 	tst.w	r3, #2
    422c:	d160      	bne.n	42f0 <_spi_m_sync_init+0x114>
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    422e:	69e3      	ldr	r3, [r4, #28]
    4230:	f013 0f01 	tst.w	r3, #1
    4234:	d1fb      	bne.n	422e <_spi_m_sync_init+0x52>
	((Sercom *)hw)->SPI.CTRLA.reg |= SERCOM_SPI_CTRLA_SWRST;
    4236:	6823      	ldr	r3, [r4, #0]
    4238:	f043 0301 	orr.w	r3, r3, #1
    423c:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    423e:	69e3      	ldr	r3, [r4, #28]
    4240:	f013 0f01 	tst.w	r3, #1
    4244:	d1fb      	bne.n	423e <_spi_m_sync_init+0x62>
		return ERR_DENIED;
	}
	hri_sercomspi_set_CTRLA_SWRST_bit(hw);
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST);
	dev->prvt = hw;
    4246:	6034      	str	r4, [r6, #0]

	if ((regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk) == SERCOM_USART_CTRLA_MODE_SPI_SLAVE) {
    4248:	682b      	ldr	r3, [r5, #0]
    424a:	f003 031c 	and.w	r3, r3, #28
    424e:	2b08      	cmp	r3, #8
    4250:	d02a      	beq.n	42a8 <_spi_m_sync_init+0xcc>
	ASSERT(hw && regs);
    4252:	f44f 6210 	mov.w	r2, #2304	; 0x900
    4256:	4933      	ldr	r1, [pc, #204]	; (4324 <_spi_m_sync_init+0x148>)
    4258:	1c20      	adds	r0, r4, #0
    425a:	bf18      	it	ne
    425c:	2001      	movne	r0, #1
    425e:	4b32      	ldr	r3, [pc, #200]	; (4328 <_spi_m_sync_init+0x14c>)
    4260:	4798      	blx	r3
	hri_sercomspi_write_CTRLA_reg(
    4262:	682b      	ldr	r3, [r5, #0]
    4264:	f423 7381 	bic.w	r3, r3, #258	; 0x102
    4268:	f023 0301 	bic.w	r3, r3, #1
	((Sercom *)hw)->SPI.CTRLA.reg = data;
    426c:	6023      	str	r3, [r4, #0]
	        | (SERCOM_SPI_CTRLB_RXEN));
    426e:	686b      	ldr	r3, [r5, #4]
    4270:	f423 3338 	bic.w	r3, r3, #188416	; 0x2e000
    4274:	f423 7310 	bic.w	r3, r3, #576	; 0x240
	hri_sercomspi_write_CTRLB_reg(
    4278:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
	((Sercom *)hw)->SPI.CTRLB.reg = data;
    427c:	6063      	str	r3, [r4, #4]
	hri_sercomspi_write_BAUD_reg(hw, regs->baud);
    427e:	7b2b      	ldrb	r3, [r5, #12]
	((Sercom *)hw)->SPI.BAUD.reg = data;
    4280:	7323      	strb	r3, [r4, #12]
	hri_sercomspi_write_DBGCTRL_reg(hw, regs->dbgctrl);
    4282:	7b6b      	ldrb	r3, [r5, #13]
	((Sercom *)hw)->SPI.DBGCTRL.reg = data;
    4284:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
	} else {
		_spi_load_regs_master(hw, regs);
	}

	/* Load character size from default hardware configuration */
	dev->char_size = ((regs->ctrlb & SERCOM_SPI_CTRLB_CHSIZE_Msk) == 0) ? 1 : 2;
    4288:	686b      	ldr	r3, [r5, #4]
    428a:	f003 0307 	and.w	r3, r3, #7
    428e:	2b00      	cmp	r3, #0
    4290:	bf0c      	ite	eq
    4292:	2301      	moveq	r3, #1
    4294:	2302      	movne	r3, #2
    4296:	7133      	strb	r3, [r6, #4]

	dev->dummy_byte = regs->dummy_byte;
    4298:	89eb      	ldrh	r3, [r5, #14]
    429a:	80f3      	strh	r3, [r6, #6]

	return ERR_NONE;
    429c:	2000      	movs	r0, #0
    429e:	bd70      	pop	{r4, r5, r6, pc}
			return &sercomspi_regs[i];
    42a0:	4d1f      	ldr	r5, [pc, #124]	; (4320 <_spi_m_sync_init+0x144>)
    42a2:	e7a9      	b.n	41f8 <_spi_m_sync_init+0x1c>
    42a4:	4d1e      	ldr	r5, [pc, #120]	; (4320 <_spi_m_sync_init+0x144>)
    42a6:	e7a7      	b.n	41f8 <_spi_m_sync_init+0x1c>
	ASSERT(hw && regs);
    42a8:	f640 1214 	movw	r2, #2324	; 0x914
    42ac:	491d      	ldr	r1, [pc, #116]	; (4324 <_spi_m_sync_init+0x148>)
    42ae:	1c20      	adds	r0, r4, #0
    42b0:	bf18      	it	ne
    42b2:	2001      	movne	r0, #1
    42b4:	4b1c      	ldr	r3, [pc, #112]	; (4328 <_spi_m_sync_init+0x14c>)
    42b6:	4798      	blx	r3
	hri_sercomspi_write_CTRLA_reg(
    42b8:	682b      	ldr	r3, [r5, #0]
    42ba:	f423 7381 	bic.w	r3, r3, #258	; 0x102
    42be:	f023 0301 	bic.w	r3, r3, #1
	((Sercom *)hw)->SPI.CTRLA.reg = data;
    42c2:	6023      	str	r3, [r4, #0]
	                                  | (SERCOM_SPI_CTRLB_RXEN | SERCOM_SPI_CTRLB_SSDE | SERCOM_SPI_CTRLB_PLOADEN));
    42c4:	686b      	ldr	r3, [r5, #4]
    42c6:	f423 3308 	bic.w	r3, r3, #139264	; 0x22000
    42ca:	f423 7310 	bic.w	r3, r3, #576	; 0x240
	hri_sercomspi_write_CTRLB_reg(hw,
    42ce:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    42d2:	f443 7310 	orr.w	r3, r3, #576	; 0x240
	((Sercom *)hw)->SPI.CTRLB.reg = data;
    42d6:	6063      	str	r3, [r4, #4]
	hri_sercomspi_write_ADDR_reg(hw, regs->addr);
    42d8:	68ab      	ldr	r3, [r5, #8]
	((Sercom *)hw)->SPI.ADDR.reg = data;
    42da:	6263      	str	r3, [r4, #36]	; 0x24
	hri_sercomspi_write_DBGCTRL_reg(hw, regs->dbgctrl);
    42dc:	7b6b      	ldrb	r3, [r5, #13]
	((Sercom *)hw)->SPI.DBGCTRL.reg = data;
    42de:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
    42e2:	69e3      	ldr	r3, [r4, #28]
	while (hri_sercomspi_is_syncing(hw, 0xFFFFFFFF))
    42e4:	2b00      	cmp	r3, #0
    42e6:	d1fc      	bne.n	42e2 <_spi_m_sync_init+0x106>
    42e8:	e7ce      	b.n	4288 <_spi_m_sync_init+0xac>
		return ERR_INVALID_ARG;
    42ea:	f06f 000c 	mvn.w	r0, #12
    42ee:	bd70      	pop	{r4, r5, r6, pc}
		return ERR_DENIED;
    42f0:	f06f 0010 	mvn.w	r0, #16
    42f4:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(dev && hw);
    42f6:	f640 126d 	movw	r2, #2413	; 0x96d
    42fa:	490a      	ldr	r1, [pc, #40]	; (4324 <_spi_m_sync_init+0x148>)
    42fc:	2000      	movs	r0, #0
    42fe:	4b0a      	ldr	r3, [pc, #40]	; (4328 <_spi_m_sync_init+0x14c>)
    4300:	4798      	blx	r3
		return ERR_INVALID_ARG;
    4302:	f06f 000c 	mvn.w	r0, #12
    4306:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(dev && hw);
    4308:	f640 126d 	movw	r2, #2413	; 0x96d
    430c:	4905      	ldr	r1, [pc, #20]	; (4324 <_spi_m_sync_init+0x148>)
    430e:	2001      	movs	r0, #1
    4310:	4b05      	ldr	r3, [pc, #20]	; (4328 <_spi_m_sync_init+0x14c>)
    4312:	4798      	blx	r3
		return ERR_INVALID_ARG;
    4314:	f06f 000c 	mvn.w	r0, #12
    4318:	bd70      	pop	{r4, r5, r6, pc}
    431a:	bf00      	nop
    431c:	00004081 	.word	0x00004081
    4320:	00009918 	.word	0x00009918
    4324:	0000992c 	.word	0x0000992c
    4328:	00003205 	.word	0x00003205

0000432c <_spi_m_async_init>:
{
	return _spi_m_sync_init(dev, hw);
}

int32_t _spi_m_async_init(struct _spi_async_dev *dev, void *const hw)
{
    432c:	b538      	push	{r3, r4, r5, lr}
    432e:	4604      	mov	r4, r0
    4330:	460d      	mov	r5, r1
	struct _spi_async_dev *spid = dev;
	/* Do hardware initialize. */
	int32_t rc = _spi_m_sync_init((struct _spi_m_sync_dev *)dev, hw);
    4332:	4b15      	ldr	r3, [pc, #84]	; (4388 <_spi_m_async_init+0x5c>)
    4334:	4798      	blx	r3

	if (rc < 0) {
    4336:	2800      	cmp	r0, #0
    4338:	db25      	blt.n	4386 <_spi_m_async_init+0x5a>
	if (hw == SERCOM0) {
    433a:	4b14      	ldr	r3, [pc, #80]	; (438c <_spi_m_async_init+0x60>)
    433c:	429d      	cmp	r5, r3
		_sercom0_dev = (struct _spi_async_dev *)dev;
    433e:	bf04      	itt	eq
    4340:	4b13      	ldreq	r3, [pc, #76]	; (4390 <_spi_m_async_init+0x64>)
    4342:	601c      	streq	r4, [r3, #0]
		return rc;
	}

	_sercom_init_irq_param(hw, (void *)dev);
	/* Initialize callbacks: must use them */
	spid->callbacks.complete = NULL;
    4344:	2300      	movs	r3, #0
    4346:	6123      	str	r3, [r4, #16]
	spid->callbacks.rx       = NULL;
    4348:	60e3      	str	r3, [r4, #12]
	spid->callbacks.tx       = NULL;
    434a:	60a3      	str	r3, [r4, #8]
	uint8_t irq              = _sercom_get_irq_num(hw);
    434c:	4628      	mov	r0, r5
    434e:	4b11      	ldr	r3, [pc, #68]	; (4394 <_spi_m_async_init+0x68>)
    4350:	4798      	blx	r3
    4352:	1d01      	adds	r1, r0, #4
    4354:	b2c9      	uxtb	r1, r1
    NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    4356:	2401      	movs	r4, #1
    4358:	f000 021f 	and.w	r2, r0, #31
    435c:	fa04 f202 	lsl.w	r2, r4, r2
    4360:	0943      	lsrs	r3, r0, #5
    4362:	009b      	lsls	r3, r3, #2
    4364:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
    4368:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
    436c:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  __ASM volatile ("dsb 0xF":::"memory");
    4370:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    4374:	f3bf 8f6f 	isb	sy
    NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    4378:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
	for (uint32_t i = 0; i < 4; i++) {
		NVIC_DisableIRQ((IRQn_Type)irq);
		NVIC_ClearPendingIRQ((IRQn_Type)irq);
		irq++;
    437c:	3001      	adds	r0, #1
    437e:	b2c0      	uxtb	r0, r0
	for (uint32_t i = 0; i < 4; i++) {
    4380:	4281      	cmp	r1, r0
    4382:	d1e9      	bne.n	4358 <_spi_m_async_init+0x2c>
	}

	return ERR_NONE;
    4384:	2000      	movs	r0, #0
}
    4386:	bd38      	pop	{r3, r4, r5, pc}
    4388:	000041dd 	.word	0x000041dd
    438c:	40003000 	.word	0x40003000
    4390:	200002c4 	.word	0x200002c4
    4394:	000040c5 	.word	0x000040c5

00004398 <_spi_s_async_init>:

int32_t _spi_s_async_init(struct _spi_s_async_dev *dev, void *const hw)
{
    4398:	b508      	push	{r3, lr}
	return _spi_m_async_init(dev, hw);
    439a:	4b01      	ldr	r3, [pc, #4]	; (43a0 <_spi_s_async_init+0x8>)
    439c:	4798      	blx	r3
}
    439e:	bd08      	pop	{r3, pc}
    43a0:	0000432d 	.word	0x0000432d

000043a4 <_spi_s_async_enable>:

	return _spi_async_enable(dev->prvt);
}

int32_t _spi_s_async_enable(struct _spi_s_async_dev *dev)
{
    43a4:	b510      	push	{r4, lr}
	ASSERT(dev && dev->prvt);
    43a6:	4604      	mov	r4, r0
    43a8:	b160      	cbz	r0, 43c4 <_spi_s_async_enable+0x20>
    43aa:	6800      	ldr	r0, [r0, #0]
    43ac:	3000      	adds	r0, #0
    43ae:	bf18      	it	ne
    43b0:	2001      	movne	r0, #1
    43b2:	f640 12dd 	movw	r2, #2525	; 0x9dd
    43b6:	4904      	ldr	r1, [pc, #16]	; (43c8 <_spi_s_async_enable+0x24>)
    43b8:	4b04      	ldr	r3, [pc, #16]	; (43cc <_spi_s_async_enable+0x28>)
    43ba:	4798      	blx	r3

	return _spi_async_enable(dev->prvt);
    43bc:	6820      	ldr	r0, [r4, #0]
    43be:	4b04      	ldr	r3, [pc, #16]	; (43d0 <_spi_s_async_enable+0x2c>)
    43c0:	4798      	blx	r3
}
    43c2:	bd10      	pop	{r4, pc}
    43c4:	2000      	movs	r0, #0
    43c6:	e7f4      	b.n	43b2 <_spi_s_async_enable+0xe>
    43c8:	0000992c 	.word	0x0000992c
    43cc:	00003205 	.word	0x00003205
    43d0:	000040fd 	.word	0x000040fd

000043d4 <_spi_m_async_enable_tx>:

	return rc;
}

int32_t _spi_m_async_enable_tx(struct _spi_async_dev *dev, bool state)
{
    43d4:	b538      	push	{r3, r4, r5, lr}
    43d6:	460d      	mov	r5, r1
	void *hw = dev->prvt;
    43d8:	6804      	ldr	r4, [r0, #0]

	ASSERT(dev && hw);
    43da:	b160      	cbz	r0, 43f6 <_spi_m_async_enable_tx+0x22>
    43dc:	1c20      	adds	r0, r4, #0
    43de:	bf18      	it	ne
    43e0:	2001      	movne	r0, #1
    43e2:	f640 22f9 	movw	r2, #2809	; 0xaf9
    43e6:	4906      	ldr	r1, [pc, #24]	; (4400 <_spi_m_async_enable_tx+0x2c>)
    43e8:	4b06      	ldr	r3, [pc, #24]	; (4404 <_spi_m_async_enable_tx+0x30>)
    43ea:	4798      	blx	r3

	if (state) {
    43ec:	b92d      	cbnz	r5, 43fa <_spi_m_async_enable_tx+0x26>
	((Sercom *)hw)->SPI.INTENCLR.reg = SERCOM_SPI_INTENSET_DRE;
    43ee:	2301      	movs	r3, #1
    43f0:	7523      	strb	r3, [r4, #20]
	} else {
		hri_sercomspi_clear_INTEN_DRE_bit(hw);
	}

	return ERR_NONE;
}
    43f2:	2000      	movs	r0, #0
    43f4:	bd38      	pop	{r3, r4, r5, pc}
    43f6:	2000      	movs	r0, #0
    43f8:	e7f3      	b.n	43e2 <_spi_m_async_enable_tx+0xe>
	((Sercom *)hw)->SPI.INTENSET.reg = SERCOM_SPI_INTENSET_DRE;
    43fa:	2301      	movs	r3, #1
    43fc:	75a3      	strb	r3, [r4, #22]
    43fe:	e7f8      	b.n	43f2 <_spi_m_async_enable_tx+0x1e>
    4400:	0000992c 	.word	0x0000992c
    4404:	00003205 	.word	0x00003205

00004408 <_spi_s_async_enable_tx>:

int32_t _spi_s_async_enable_tx(struct _spi_s_async_dev *dev, bool state)
{
    4408:	b508      	push	{r3, lr}
	return _spi_m_async_enable_tx(dev, state);
    440a:	4b01      	ldr	r3, [pc, #4]	; (4410 <_spi_s_async_enable_tx+0x8>)
    440c:	4798      	blx	r3
}
    440e:	bd08      	pop	{r3, pc}
    4410:	000043d5 	.word	0x000043d5

00004414 <_spi_m_async_enable_rx>:

int32_t _spi_m_async_enable_rx(struct _spi_async_dev *dev, bool state)
{
    4414:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    4416:	460f      	mov	r7, r1
	void *hw = dev->prvt;
    4418:	6804      	ldr	r4, [r0, #0]

	ASSERT(dev);
    441a:	4e0c      	ldr	r6, [pc, #48]	; (444c <_spi_m_async_enable_rx+0x38>)
    441c:	f640 320d 	movw	r2, #2829	; 0xb0d
    4420:	4631      	mov	r1, r6
    4422:	3000      	adds	r0, #0
    4424:	bf18      	it	ne
    4426:	2001      	movne	r0, #1
    4428:	4d09      	ldr	r5, [pc, #36]	; (4450 <_spi_m_async_enable_rx+0x3c>)
    442a:	47a8      	blx	r5
	ASSERT(hw);
    442c:	f640 320e 	movw	r2, #2830	; 0xb0e
    4430:	4631      	mov	r1, r6
    4432:	1c20      	adds	r0, r4, #0
    4434:	bf18      	it	ne
    4436:	2001      	movne	r0, #1
    4438:	47a8      	blx	r5

	if (state) {
    443a:	b91f      	cbnz	r7, 4444 <_spi_m_async_enable_rx+0x30>
	((Sercom *)hw)->SPI.INTENCLR.reg = SERCOM_SPI_INTENSET_RXC;
    443c:	2304      	movs	r3, #4
    443e:	7523      	strb	r3, [r4, #20]
	} else {
		hri_sercomspi_clear_INTEN_RXC_bit(hw);
	}

	return ERR_NONE;
}
    4440:	2000      	movs	r0, #0
    4442:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	((Sercom *)hw)->SPI.INTENSET.reg = SERCOM_SPI_INTENSET_RXC;
    4444:	2304      	movs	r3, #4
    4446:	75a3      	strb	r3, [r4, #22]
    4448:	e7fa      	b.n	4440 <_spi_m_async_enable_rx+0x2c>
    444a:	bf00      	nop
    444c:	0000992c 	.word	0x0000992c
    4450:	00003205 	.word	0x00003205

00004454 <_spi_s_async_enable_rx>:

int32_t _spi_s_async_enable_rx(struct _spi_s_async_dev *dev, bool state)
{
    4454:	b508      	push	{r3, lr}
	return _spi_m_async_enable_rx(dev, state);
    4456:	4b01      	ldr	r3, [pc, #4]	; (445c <_spi_s_async_enable_rx+0x8>)
    4458:	4798      	blx	r3
}
    445a:	bd08      	pop	{r3, pc}
    445c:	00004415 	.word	0x00004415

00004460 <_spi_m_async_enable_ss_detect>:

int32_t _spi_m_async_enable_ss_detect(struct _spi_async_dev *dev, bool state)
{
    4460:	b538      	push	{r3, r4, r5, lr}
    4462:	460d      	mov	r5, r1
	ASSERT(dev && dev->prvt);
    4464:	4604      	mov	r4, r0
    4466:	b170      	cbz	r0, 4486 <_spi_m_async_enable_ss_detect+0x26>
    4468:	6800      	ldr	r0, [r0, #0]
    446a:	3000      	adds	r0, #0
    446c:	bf18      	it	ne
    446e:	2001      	movne	r0, #1
    4470:	f44f 6232 	mov.w	r2, #2848	; 0xb20
    4474:	4907      	ldr	r1, [pc, #28]	; (4494 <_spi_m_async_enable_ss_detect+0x34>)
    4476:	4b08      	ldr	r3, [pc, #32]	; (4498 <_spi_m_async_enable_ss_detect+0x38>)
    4478:	4798      	blx	r3

	if (state) {
    447a:	b935      	cbnz	r5, 448a <_spi_m_async_enable_ss_detect+0x2a>
		hri_sercomspi_set_INTEN_TXC_bit(dev->prvt);
	} else {
		hri_sercomspi_clear_INTEN_TXC_bit(dev->prvt);
    447c:	6823      	ldr	r3, [r4, #0]
	((Sercom *)hw)->SPI.INTENCLR.reg = SERCOM_SPI_INTENSET_TXC;
    447e:	2202      	movs	r2, #2
    4480:	751a      	strb	r2, [r3, #20]
	}

	return ERR_NONE;
}
    4482:	2000      	movs	r0, #0
    4484:	bd38      	pop	{r3, r4, r5, pc}
    4486:	2000      	movs	r0, #0
    4488:	e7f2      	b.n	4470 <_spi_m_async_enable_ss_detect+0x10>
		hri_sercomspi_set_INTEN_TXC_bit(dev->prvt);
    448a:	6823      	ldr	r3, [r4, #0]
	((Sercom *)hw)->SPI.INTENSET.reg = SERCOM_SPI_INTENSET_TXC;
    448c:	2202      	movs	r2, #2
    448e:	759a      	strb	r2, [r3, #22]
    4490:	e7f7      	b.n	4482 <_spi_m_async_enable_ss_detect+0x22>
    4492:	bf00      	nop
    4494:	0000992c 	.word	0x0000992c
    4498:	00003205 	.word	0x00003205

0000449c <_spi_s_async_enable_ss_detect>:

int32_t _spi_s_async_enable_ss_detect(struct _spi_s_async_dev *dev, bool state)
{
    449c:	b508      	push	{r3, lr}
	return _spi_m_async_enable_ss_detect(dev, state);
    449e:	4b01      	ldr	r3, [pc, #4]	; (44a4 <_spi_s_async_enable_ss_detect+0x8>)
    44a0:	4798      	blx	r3
}
    44a2:	bd08      	pop	{r3, pc}
    44a4:	00004461 	.word	0x00004461

000044a8 <_spi_s_async_write_one>:

	return ERR_NONE;
}

int32_t _spi_s_async_write_one(struct _spi_s_async_dev *dev, uint16_t data)
{
    44a8:	b538      	push	{r3, r4, r5, lr}
    44aa:	460d      	mov	r5, r1
	ASSERT(dev && dev->prvt);
    44ac:	4604      	mov	r4, r0
    44ae:	b160      	cbz	r0, 44ca <_spi_s_async_write_one+0x22>
    44b0:	6800      	ldr	r0, [r0, #0]
    44b2:	3000      	adds	r0, #0
    44b4:	bf18      	it	ne
    44b6:	2001      	movne	r0, #1
    44b8:	f640 323b 	movw	r2, #2875	; 0xb3b
    44bc:	4904      	ldr	r1, [pc, #16]	; (44d0 <_spi_s_async_write_one+0x28>)
    44be:	4b05      	ldr	r3, [pc, #20]	; (44d4 <_spi_s_async_write_one+0x2c>)
    44c0:	4798      	blx	r3

	hri_sercomspi_write_DATA_reg(dev->prvt, data);
    44c2:	6823      	ldr	r3, [r4, #0]
	((Sercom *)hw)->SPI.DATA.reg = data;
    44c4:	629d      	str	r5, [r3, #40]	; 0x28

	return ERR_NONE;
}
    44c6:	2000      	movs	r0, #0
    44c8:	bd38      	pop	{r3, r4, r5, pc}
    44ca:	2000      	movs	r0, #0
    44cc:	e7f4      	b.n	44b8 <_spi_s_async_write_one+0x10>
    44ce:	bf00      	nop
    44d0:	0000992c 	.word	0x0000992c
    44d4:	00003205 	.word	0x00003205

000044d8 <_spi_s_async_read_one>:

	return hri_sercomspi_read_DATA_reg(dev->prvt);
}

uint16_t _spi_s_async_read_one(struct _spi_s_async_dev *dev)
{
    44d8:	b510      	push	{r4, lr}
	ASSERT(dev && dev->prvt);
    44da:	4604      	mov	r4, r0
    44dc:	b160      	cbz	r0, 44f8 <_spi_s_async_read_one+0x20>
    44de:	6800      	ldr	r0, [r0, #0]
    44e0:	3000      	adds	r0, #0
    44e2:	bf18      	it	ne
    44e4:	2001      	movne	r0, #1
    44e6:	f640 3254 	movw	r2, #2900	; 0xb54
    44ea:	4904      	ldr	r1, [pc, #16]	; (44fc <_spi_s_async_read_one+0x24>)
    44ec:	4b04      	ldr	r3, [pc, #16]	; (4500 <_spi_s_async_read_one+0x28>)
    44ee:	4798      	blx	r3

	return hri_sercomspi_read_DATA_reg(dev->prvt);
    44f0:	6823      	ldr	r3, [r4, #0]
	return ((Sercom *)hw)->SPI.DATA.reg;
    44f2:	6a98      	ldr	r0, [r3, #40]	; 0x28
}
    44f4:	b280      	uxth	r0, r0
    44f6:	bd10      	pop	{r4, pc}
    44f8:	2000      	movs	r0, #0
    44fa:	e7f4      	b.n	44e6 <_spi_s_async_read_one+0xe>
    44fc:	0000992c 	.word	0x0000992c
    4500:	00003205 	.word	0x00003205

00004504 <_spi_m_async_register_callback>:
	return hri_sercomspi_read_DATA_reg(dev->prvt);
}

int32_t _spi_m_async_register_callback(struct _spi_async_dev *dev, const enum _spi_async_dev_cb_type cb_type,
                                       const FUNC_PTR func)
{
    4504:	b570      	push	{r4, r5, r6, lr}
    4506:	460d      	mov	r5, r1
    4508:	4616      	mov	r6, r2
	typedef void (*func_t)(void);
	struct _spi_async_dev *spid = dev;

	ASSERT(dev && (cb_type < SPI_DEV_CB_N));
    450a:	4604      	mov	r4, r0
    450c:	b168      	cbz	r0, 452a <_spi_m_async_register_callback+0x26>
    450e:	2902      	cmp	r1, #2
    4510:	bf8c      	ite	hi
    4512:	2000      	movhi	r0, #0
    4514:	2001      	movls	r0, #1
    4516:	f640 3266 	movw	r2, #2918	; 0xb66
    451a:	4905      	ldr	r1, [pc, #20]	; (4530 <_spi_m_async_register_callback+0x2c>)
    451c:	4b05      	ldr	r3, [pc, #20]	; (4534 <_spi_m_async_register_callback+0x30>)
    451e:	4798      	blx	r3

	func_t *p_ls  = (func_t *)&spid->callbacks;
	p_ls[cb_type] = (func_t)func;
    4520:	eb04 0485 	add.w	r4, r4, r5, lsl #2
    4524:	60a6      	str	r6, [r4, #8]

	return ERR_NONE;
}
    4526:	2000      	movs	r0, #0
    4528:	bd70      	pop	{r4, r5, r6, pc}
    452a:	2000      	movs	r0, #0
    452c:	e7f3      	b.n	4516 <_spi_m_async_register_callback+0x12>
    452e:	bf00      	nop
    4530:	0000992c 	.word	0x0000992c
    4534:	00003205 	.word	0x00003205

00004538 <_spi_s_async_register_callback>:

int32_t _spi_s_async_register_callback(struct _spi_s_async_dev *dev, const enum _spi_s_async_dev_cb_type cb_type,
                                       const FUNC_PTR func)
{
    4538:	b508      	push	{r3, lr}
	return _spi_m_async_register_callback(dev, cb_type, func);
    453a:	4b01      	ldr	r3, [pc, #4]	; (4540 <_spi_s_async_register_callback+0x8>)
    453c:	4798      	blx	r3
}
    453e:	bd08      	pop	{r3, pc}
    4540:	00004505 	.word	0x00004505

00004544 <tc_pwm_interrupt_handler>:
 * \internal TC interrupt handler for PWM
 *
 * \param[in] instance TC instance number
 */
static void tc_pwm_interrupt_handler(struct _pwm_device *device)
{
    4544:	b538      	push	{r3, r4, r5, lr}
    4546:	4605      	mov	r5, r0
	void *const hw = device->hw;
    4548:	6904      	ldr	r4, [r0, #16]
	((Tc *)hw)->COUNT8.INTFLAG.reg = TC_INTFLAG_MC1;
}

static inline bool hri_tc_get_interrupt_OVF_bit(const void *const hw)
{
	return (((Tc *)hw)->COUNT8.INTFLAG.reg & TC_INTFLAG_OVF) >> TC_INTFLAG_OVF_Pos;
    454a:	7aa3      	ldrb	r3, [r4, #10]

	if (hri_tc_get_interrupt_OVF_bit(hw)) {
    454c:	f013 0f01 	tst.w	r3, #1
    4550:	d004      	beq.n	455c <tc_pwm_interrupt_handler+0x18>
}

static inline void hri_tc_clear_interrupt_OVF_bit(const void *const hw)
{
	((Tc *)hw)->COUNT8.INTFLAG.reg = TC_INTFLAG_OVF;
    4552:	2301      	movs	r3, #1
    4554:	72a3      	strb	r3, [r4, #10]
		hri_tc_clear_interrupt_OVF_bit(hw);
		if (NULL != device->callback.pwm_period_cb) {
    4556:	6803      	ldr	r3, [r0, #0]
    4558:	b103      	cbz	r3, 455c <tc_pwm_interrupt_handler+0x18>
			device->callback.pwm_period_cb(device);
    455a:	4798      	blx	r3
	return (((Tc *)hw)->COUNT8.INTENSET.reg & TC_INTENSET_ERR) >> TC_INTENSET_ERR_Pos;
    455c:	7a63      	ldrb	r3, [r4, #9]
		}
	}
	if (hri_tc_get_INTEN_ERR_bit(hw)) {
    455e:	f013 0f02 	tst.w	r3, #2
    4562:	d005      	beq.n	4570 <tc_pwm_interrupt_handler+0x2c>
	return (((Tc *)hw)->COUNT8.INTFLAG.reg & TC_INTFLAG_ERR) >> TC_INTFLAG_ERR_Pos;
}

static inline void hri_tc_clear_interrupt_ERR_bit(const void *const hw)
{
	((Tc *)hw)->COUNT8.INTFLAG.reg = TC_INTFLAG_ERR;
    4564:	2302      	movs	r3, #2
    4566:	72a3      	strb	r3, [r4, #10]
		hri_tc_clear_interrupt_ERR_bit(hw);
		if (NULL != device->callback.pwm_error_cb) {
    4568:	686b      	ldr	r3, [r5, #4]
    456a:	b10b      	cbz	r3, 4570 <tc_pwm_interrupt_handler+0x2c>
			device->callback.pwm_error_cb(device);
    456c:	4628      	mov	r0, r5
    456e:	4798      	blx	r3
    4570:	bd38      	pop	{r3, r4, r5, pc}
	...

00004574 <get_tc_index>:
 * \param[in] hw The pointer to hardware instance
 *
 * \return The index of TC configuration
 */
static int8_t get_tc_index(const void *const hw)
{
    4574:	b570      	push	{r4, r5, r6, lr}
    4576:	b088      	sub	sp, #32
    4578:	4606      	mov	r6, r0
 * \param[in] hw The pointer to hardware instance
 */
static inline uint8_t _get_hardware_offset(const void *const hw)
{
	/* List of available TC modules. */
	Tc *const tc_modules[TC_INST_NUM] = TC_INSTS;
    457a:	466c      	mov	r4, sp
    457c:	4d17      	ldr	r5, [pc, #92]	; (45dc <get_tc_index+0x68>)
    457e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    4580:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    4582:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
    4586:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}

	/* Find index for TC instance. */
	for (uint32_t i = 0; i < TC_INST_NUM; i++) {
		if ((uint32_t)hw == (uint32_t)tc_modules[i]) {
    458a:	9b00      	ldr	r3, [sp, #0]
    458c:	42b3      	cmp	r3, r6
    458e:	d01e      	beq.n	45ce <get_tc_index+0x5a>
    4590:	4630      	mov	r0, r6
    4592:	aa01      	add	r2, sp, #4
	for (uint32_t i = 0; i < TC_INST_NUM; i++) {
    4594:	2301      	movs	r3, #1
		if ((uint32_t)hw == (uint32_t)tc_modules[i]) {
    4596:	f852 1b04 	ldr.w	r1, [r2], #4
    459a:	4281      	cmp	r1, r0
    459c:	d018      	beq.n	45d0 <get_tc_index+0x5c>
	for (uint32_t i = 0; i < TC_INST_NUM; i++) {
    459e:	3301      	adds	r3, #1
    45a0:	2b08      	cmp	r3, #8
    45a2:	d1f8      	bne.n	4596 <get_tc_index+0x22>
			return i;
		}
	}
	return 0;
    45a4:	2300      	movs	r3, #0
		if (_tcs[i].number == index) {
    45a6:	4a0e      	ldr	r2, [pc, #56]	; (45e0 <get_tc_index+0x6c>)
    45a8:	7812      	ldrb	r2, [r2, #0]
    45aa:	429a      	cmp	r2, r3
    45ac:	d012      	beq.n	45d4 <get_tc_index+0x60>
    45ae:	4a0c      	ldr	r2, [pc, #48]	; (45e0 <get_tc_index+0x6c>)
    45b0:	7d12      	ldrb	r2, [r2, #20]
    45b2:	429a      	cmp	r2, r3
    45b4:	bf08      	it	eq
    45b6:	2001      	moveq	r0, #1
    45b8:	d00d      	beq.n	45d6 <get_tc_index+0x62>
	ASSERT(false);
    45ba:	f240 1265 	movw	r2, #357	; 0x165
    45be:	4909      	ldr	r1, [pc, #36]	; (45e4 <get_tc_index+0x70>)
    45c0:	2000      	movs	r0, #0
    45c2:	4b09      	ldr	r3, [pc, #36]	; (45e8 <get_tc_index+0x74>)
    45c4:	4798      	blx	r3
	return -1;
    45c6:	f04f 30ff 	mov.w	r0, #4294967295
}
    45ca:	b008      	add	sp, #32
    45cc:	bd70      	pop	{r4, r5, r6, pc}
	for (uint32_t i = 0; i < TC_INST_NUM; i++) {
    45ce:	2300      	movs	r3, #0
			return i;
    45d0:	b2db      	uxtb	r3, r3
    45d2:	e7e8      	b.n	45a6 <get_tc_index+0x32>
	for (i = 0; i < ARRAY_SIZE(_tcs); i++) {
    45d4:	2000      	movs	r0, #0
			return i;
    45d6:	b240      	sxtb	r0, r0
    45d8:	e7f7      	b.n	45ca <get_tc_index+0x56>
    45da:	bf00      	nop
    45dc:	00009948 	.word	0x00009948
    45e0:	20000000 	.word	0x20000000
    45e4:	00009968 	.word	0x00009968
    45e8:	00003205 	.word	0x00003205

000045ec <_pwm_init>:
{
    45ec:	b538      	push	{r3, r4, r5, lr}
    45ee:	4605      	mov	r5, r0
    45f0:	460c      	mov	r4, r1
	int8_t i   = get_tc_index(hw);
    45f2:	4608      	mov	r0, r1
    45f4:	4b42      	ldr	r3, [pc, #264]	; (4700 <_pwm_init+0x114>)
    45f6:	4798      	blx	r3
	device->hw = hw;
    45f8:	612c      	str	r4, [r5, #16]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    45fa:	6923      	ldr	r3, [r4, #16]
    45fc:	f013 0f01 	tst.w	r3, #1
    4600:	d1fb      	bne.n	45fa <_pwm_init+0xe>
    4602:	6923      	ldr	r3, [r4, #16]
    4604:	f013 0f03 	tst.w	r3, #3
    4608:	d1fb      	bne.n	4602 <_pwm_init+0x16>

static inline bool hri_tc_get_CTRLA_ENABLE_bit(const void *const hw)
{
	uint32_t tmp;
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
	tmp = ((Tc *)hw)->COUNT8.CTRLA.reg;
    460a:	6823      	ldr	r3, [r4, #0]
	if (hri_tc_get_CTRLA_ENABLE_bit(hw)) {
    460c:	f013 0f02 	tst.w	r3, #2
    4610:	d16b      	bne.n	46ea <_pwm_init+0xfe>
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    4612:	6923      	ldr	r3, [r4, #16]
    4614:	f013 0f01 	tst.w	r3, #1
    4618:	d1fb      	bne.n	4612 <_pwm_init+0x26>
	((Tc *)hw)->COUNT8.CTRLA.reg |= TC_CTRLA_SWRST;
    461a:	6823      	ldr	r3, [r4, #0]
    461c:	f043 0301 	orr.w	r3, r3, #1
    4620:	6023      	str	r3, [r4, #0]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    4622:	6923      	ldr	r3, [r4, #16]
    4624:	f013 0f01 	tst.w	r3, #1
    4628:	d1fb      	bne.n	4622 <_pwm_init+0x36>
	hri_tc_write_CTRLA_reg(hw, _tcs[i].ctrl_a);
    462a:	eb00 0380 	add.w	r3, r0, r0, lsl #2
    462e:	4a35      	ldr	r2, [pc, #212]	; (4704 <_pwm_init+0x118>)
    4630:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    4634:	685a      	ldr	r2, [r3, #4]
}

static inline void hri_tc_write_CTRLA_reg(const void *const hw, hri_tc_ctrla_reg_t data)
{
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->COUNT8.CTRLA.reg = data;
    4636:	6022      	str	r2, [r4, #0]
	hri_tc_write_DBGCTRL_reg(hw, _tcs[i].dbg_ctrl);
    4638:	7a99      	ldrb	r1, [r3, #10]
}

static inline void hri_tc_write_DBGCTRL_reg(const void *const hw, hri_tc_dbgctrl_reg_t data)
{
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->COUNT8.DBGCTRL.reg = data;
    463a:	73e1      	strb	r1, [r4, #15]
	hri_tc_write_EVCTRL_reg(hw, _tcs[i].event_ctrl);
    463c:	891b      	ldrh	r3, [r3, #8]
	((Tc *)hw)->COUNT8.EVCTRL.reg = data;
    463e:	80e3      	strh	r3, [r4, #6]
	((Tc *)hw)->COUNT8.WAVE.reg = data;
    4640:	2303      	movs	r3, #3
    4642:	7323      	strb	r3, [r4, #12]
	if ((_tcs[i].ctrl_a & TC_CTRLA_MODE_Msk) == TC_CTRLA_MODE_COUNT32) {
    4644:	f002 020c 	and.w	r2, r2, #12
    4648:	2a08      	cmp	r2, #8
    464a:	d041      	beq.n	46d0 <_pwm_init+0xe4>
	} else if ((_tcs[i].ctrl_a & TC_CTRLA_MODE_Msk) == TC_CTRLA_MODE_COUNT16) {
    464c:	2a00      	cmp	r2, #0
    464e:	d14f      	bne.n	46f0 <_pwm_init+0x104>
		hri_tccount16_write_CC_reg(hw, 0, (uint16_t)_tcs[i].cc0);
    4650:	eb00 0380 	add.w	r3, r0, r0, lsl #2
    4654:	4a2b      	ldr	r2, [pc, #172]	; (4704 <_pwm_init+0x118>)
    4656:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    465a:	899a      	ldrh	r2, [r3, #12]
	((Tc *)hw)->COUNT16.CC[index].reg = data;
    465c:	83a2      	strh	r2, [r4, #28]
		hri_tccount16_write_CC_reg(hw, 1, (uint16_t)_tcs[i].cc1);
    465e:	8a1b      	ldrh	r3, [r3, #16]
    4660:	83e3      	strh	r3, [r4, #30]
	if (hw == TC4) {
    4662:	4b29      	ldr	r3, [pc, #164]	; (4708 <_pwm_init+0x11c>)
    4664:	429c      	cmp	r4, r3
    4666:	d03d      	beq.n	46e4 <_pwm_init+0xf8>
	if (hw == TC5) {
    4668:	4b28      	ldr	r3, [pc, #160]	; (470c <_pwm_init+0x120>)
    466a:	429c      	cmp	r4, r3
		_tc5_dev = (struct _pwm_device *)dev;
    466c:	bf04      	itt	eq
    466e:	4b28      	ldreq	r3, [pc, #160]	; (4710 <_pwm_init+0x124>)
    4670:	605d      	streq	r5, [r3, #4]
	NVIC_DisableIRQ(_tcs[i].irq);
    4672:	eb00 0380 	add.w	r3, r0, r0, lsl #2
    4676:	4a23      	ldr	r2, [pc, #140]	; (4704 <_pwm_init+0x118>)
    4678:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    467c:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
  if ((int32_t)(IRQn) >= 0)
    4680:	2b00      	cmp	r3, #0
    4682:	db38      	blt.n	46f6 <_pwm_init+0x10a>
    NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    4684:	095a      	lsrs	r2, r3, #5
    4686:	f003 031f 	and.w	r3, r3, #31
    468a:	2101      	movs	r1, #1
    468c:	fa01 f303 	lsl.w	r3, r1, r3
    4690:	3220      	adds	r2, #32
    4692:	4920      	ldr	r1, [pc, #128]	; (4714 <_pwm_init+0x128>)
    4694:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
    4698:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    469c:	f3bf 8f6f 	isb	sy
	NVIC_ClearPendingIRQ(_tcs[i].irq);
    46a0:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    46a4:	4b17      	ldr	r3, [pc, #92]	; (4704 <_pwm_init+0x118>)
    46a6:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    46aa:	f9b0 3002 	ldrsh.w	r3, [r0, #2]
  if ((int32_t)(IRQn) >= 0)
    46ae:	2b00      	cmp	r3, #0
    46b0:	db23      	blt.n	46fa <_pwm_init+0x10e>
    NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    46b2:	0959      	lsrs	r1, r3, #5
    46b4:	f003 031f 	and.w	r3, r3, #31
    46b8:	2201      	movs	r2, #1
    46ba:	fa02 f303 	lsl.w	r3, r2, r3
    46be:	4a15      	ldr	r2, [pc, #84]	; (4714 <_pwm_init+0x128>)
    46c0:	f101 0060 	add.w	r0, r1, #96	; 0x60
    46c4:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    46c8:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
	return 0;
    46cc:	2000      	movs	r0, #0
    46ce:	bd38      	pop	{r3, r4, r5, pc}
		hri_tccount32_write_CC_reg(hw, 0, _tcs[i].cc0);
    46d0:	eb00 0380 	add.w	r3, r0, r0, lsl #2
    46d4:	4a0b      	ldr	r2, [pc, #44]	; (4704 <_pwm_init+0x118>)
    46d6:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    46da:	68da      	ldr	r2, [r3, #12]
	((Tc *)hw)->COUNT32.CC[index].reg = data;
    46dc:	61e2      	str	r2, [r4, #28]
		hri_tccount32_write_CC_reg(hw, 1, _tcs[i].cc1);
    46de:	691b      	ldr	r3, [r3, #16]
    46e0:	6223      	str	r3, [r4, #32]
    46e2:	e7be      	b.n	4662 <_pwm_init+0x76>
		_tc4_dev = (struct _pwm_device *)dev;
    46e4:	4b0a      	ldr	r3, [pc, #40]	; (4710 <_pwm_init+0x124>)
    46e6:	601d      	str	r5, [r3, #0]
    46e8:	e7c3      	b.n	4672 <_pwm_init+0x86>
		return ERR_DENIED;
    46ea:	f06f 0010 	mvn.w	r0, #16
    46ee:	bd38      	pop	{r3, r4, r5, pc}
		return -1;
    46f0:	f04f 30ff 	mov.w	r0, #4294967295
    46f4:	bd38      	pop	{r3, r4, r5, pc}
	return 0;
    46f6:	2000      	movs	r0, #0
    46f8:	bd38      	pop	{r3, r4, r5, pc}
    46fa:	2000      	movs	r0, #0
}
    46fc:	bd38      	pop	{r3, r4, r5, pc}
    46fe:	bf00      	nop
    4700:	00004575 	.word	0x00004575
    4704:	20000000 	.word	0x20000000
    4708:	42001400 	.word	0x42001400
    470c:	42001800 	.word	0x42001800
    4710:	200002c8 	.word	0x200002c8
    4714:	e000e100 	.word	0xe000e100

00004718 <_pwm_enable>:
	hri_tc_set_CTRLA_ENABLE_bit(device->hw);
    4718:	6902      	ldr	r2, [r0, #16]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    471a:	6913      	ldr	r3, [r2, #16]
    471c:	f013 0f03 	tst.w	r3, #3
    4720:	d1fb      	bne.n	471a <_pwm_enable+0x2>
	((Tc *)hw)->COUNT8.CTRLA.reg |= TC_CTRLA_ENABLE;
    4722:	6813      	ldr	r3, [r2, #0]
    4724:	f043 0302 	orr.w	r3, r3, #2
    4728:	6013      	str	r3, [r2, #0]
    472a:	4770      	bx	lr

0000472c <_pwm_disable>:
	hri_tc_clear_CTRLA_ENABLE_bit(device->hw);
    472c:	6902      	ldr	r2, [r0, #16]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    472e:	6913      	ldr	r3, [r2, #16]
    4730:	f013 0f03 	tst.w	r3, #3
    4734:	d1fb      	bne.n	472e <_pwm_disable+0x2>
	((Tc *)hw)->COUNT8.CTRLA.reg &= ~TC_CTRLA_ENABLE;
    4736:	6813      	ldr	r3, [r2, #0]
    4738:	f023 0302 	bic.w	r3, r3, #2
    473c:	6013      	str	r3, [r2, #0]
    473e:	4770      	bx	lr

00004740 <_pwm_set_param>:
{
    4740:	b570      	push	{r4, r5, r6, lr}
    4742:	460d      	mov	r5, r1
    4744:	4614      	mov	r4, r2
	void *const hw = device->hw;
    4746:	6906      	ldr	r6, [r0, #16]
	int8_t      i  = get_tc_index(hw);
    4748:	4630      	mov	r0, r6
    474a:	4b0b      	ldr	r3, [pc, #44]	; (4778 <_pwm_set_param+0x38>)
    474c:	4798      	blx	r3
	_tcs[i].cc0 = period;
    474e:	4b0b      	ldr	r3, [pc, #44]	; (477c <_pwm_set_param+0x3c>)
    4750:	0082      	lsls	r2, r0, #2
    4752:	1811      	adds	r1, r2, r0
    4754:	eb03 0181 	add.w	r1, r3, r1, lsl #2
    4758:	60cd      	str	r5, [r1, #12]
	_tcs[i].cc1 = duty_cycle;
    475a:	610c      	str	r4, [r1, #16]
	if ((_tcs[i].ctrl_a & TC_CTRLA_MODE_Msk) == TC_CTRLA_MODE_COUNT32) {
    475c:	684b      	ldr	r3, [r1, #4]
    475e:	f003 030c 	and.w	r3, r3, #12
    4762:	2b08      	cmp	r3, #8
    4764:	d004      	beq.n	4770 <_pwm_set_param+0x30>
		hri_tccount16_write_CC_reg(hw, 0, _tcs[i].cc0);
    4766:	b2ad      	uxth	r5, r5
	((Tc *)hw)->COUNT16.CC[index].reg = data;
    4768:	83b5      	strh	r5, [r6, #28]
		hri_tccount16_write_CC_reg(hw, 1, _tcs[i].cc1);
    476a:	b2a4      	uxth	r4, r4
    476c:	83f4      	strh	r4, [r6, #30]
    476e:	bd70      	pop	{r4, r5, r6, pc}
	((Tc *)hw)->COUNT32.CC[index].reg = data;
    4770:	61f5      	str	r5, [r6, #28]
    4772:	6234      	str	r4, [r6, #32]
    4774:	bd70      	pop	{r4, r5, r6, pc}
    4776:	bf00      	nop
    4778:	00004575 	.word	0x00004575
    477c:	20000000 	.word	0x20000000

00004780 <_pwm_is_enabled>:
	return hri_tc_get_CTRLA_ENABLE_bit(device->hw);
    4780:	6902      	ldr	r2, [r0, #16]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    4782:	6913      	ldr	r3, [r2, #16]
    4784:	f013 0f03 	tst.w	r3, #3
    4788:	d1fb      	bne.n	4782 <_pwm_is_enabled+0x2>
	tmp = ((Tc *)hw)->COUNT8.CTRLA.reg;
    478a:	6810      	ldr	r0, [r2, #0]
}
    478c:	f3c0 0040 	ubfx	r0, r0, #1, #1
    4790:	4770      	bx	lr

00004792 <_tc_get_pwm>:
}
    4792:	2000      	movs	r0, #0
    4794:	4770      	bx	lr
	...

00004798 <TC4_Handler>:
{
    4798:	b508      	push	{r3, lr}
	tc_pwm_interrupt_handler(_tc4_dev);
    479a:	4b02      	ldr	r3, [pc, #8]	; (47a4 <TC4_Handler+0xc>)
    479c:	6818      	ldr	r0, [r3, #0]
    479e:	4b02      	ldr	r3, [pc, #8]	; (47a8 <TC4_Handler+0x10>)
    47a0:	4798      	blx	r3
    47a2:	bd08      	pop	{r3, pc}
    47a4:	200002c8 	.word	0x200002c8
    47a8:	00004545 	.word	0x00004545

000047ac <TC5_Handler>:
{
    47ac:	b508      	push	{r3, lr}
	tc_pwm_interrupt_handler(_tc5_dev);
    47ae:	4b02      	ldr	r3, [pc, #8]	; (47b8 <TC5_Handler+0xc>)
    47b0:	6858      	ldr	r0, [r3, #4]
    47b2:	4b02      	ldr	r3, [pc, #8]	; (47bc <TC5_Handler+0x10>)
    47b4:	4798      	blx	r3
    47b6:	bd08      	pop	{r3, pc}
    47b8:	200002c8 	.word	0x200002c8
    47bc:	00004545 	.word	0x00004545

000047c0 <_dummy_func_no_return>:
static bool _dummy_func_no_return(uint32_t unused0, uint32_t unused1)
{
	(void)unused0;
	(void)unused1;
	return false;
}
    47c0:	2000      	movs	r0, #0
    47c2:	4770      	bx	lr

000047c4 <_usb_d_dev_handle_setup>:
/**
 * \brief Handles setup received interrupt
 * \param[in] ept Pointer to endpoint information.
 */
static void _usb_d_dev_handle_setup(struct _usb_d_dev_ep *ept)
{
    47c4:	b538      	push	{r3, r4, r5, lr}
	uint8_t epn     = USB_EP_GET_N(ept->ep);
    47c6:	7c83      	ldrb	r3, [r0, #18]
    47c8:	f003 030f 	and.w	r3, r3, #15
	bool    is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
    47cc:	7cc2      	ldrb	r2, [r0, #19]

	if (!is_ctrl) {
    47ce:	f002 0107 	and.w	r1, r2, #7
    47d2:	2901      	cmp	r1, #1
    47d4:	d00b      	beq.n	47ee <_usb_d_dev_handle_setup+0x2a>
}

static inline void hri_usbendpoint_clear_EPINTFLAG_reg(const void *const hw, uint8_t submodule_index,
                                                       hri_usbendpoint_epintflag_reg_t mask)
{
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    47d6:	015a      	lsls	r2, r3, #5
    47d8:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
    47dc:	2110      	movs	r1, #16
    47de:	f882 1107 	strb.w	r1, [r2, #263]	; 0x107
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = USB_DEVICE_EPINTENSET_RXSTP;
    47e2:	015b      	lsls	r3, r3, #5
    47e4:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    47e8:	f883 1108 	strb.w	r1, [r3, #264]	; 0x108
    47ec:	bd38      	pop	{r3, r4, r5, pc}
	}
	/* Control transfer:
	 * SETUP transaction will terminate IN/OUT transaction,
	 * and start new transaction with received SETUP packet.
	 */
	if (_usb_d_dev_ep_is_busy(ept)) {
    47ee:	f012 0f40 	tst.w	r2, #64	; 0x40
    47f2:	d00c      	beq.n	480e <_usb_d_dev_handle_setup+0x4a>
		ept->flags.bits.is_busy = 0;
    47f4:	7cc2      	ldrb	r2, [r0, #19]
    47f6:	f36f 1286 	bfc	r2, #6, #1
    47fa:	74c2      	strb	r2, [r0, #19]
    47fc:	015a      	lsls	r2, r3, #5
    47fe:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    4802:	2180      	movs	r1, #128	; 0x80
    4804:	f882 1104 	strb.w	r1, [r2, #260]	; 0x104
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    4808:	2140      	movs	r1, #64	; 0x40
    480a:	f882 1105 	strb.w	r1, [r2, #261]	; 0x105

		/* Stop transfer on either direction. */
		_usbd_ep_set_in_rdy(epn, 1, false);
		_usbd_ep_set_out_rdy(epn, 0, false);
	}
	ept->flags.bits.is_stalled = 0;
    480e:	7cc2      	ldrb	r2, [r0, #19]
    4810:	f36f 02c3 	bfc	r2, #3, #1
    4814:	74c2      	strb	r2, [r0, #19]
	bank->STATUS_BK.reg     = 0;
    4816:	4909      	ldr	r1, [pc, #36]	; (483c <_usb_d_dev_handle_setup+0x78>)
    4818:	015a      	lsls	r2, r3, #5
    481a:	188c      	adds	r4, r1, r2
    481c:	2500      	movs	r5, #0
    481e:	72a5      	strb	r5, [r4, #10]
    4820:	76a5      	strb	r5, [r4, #26]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    4822:	f102 4382 	add.w	r3, r2, #1090519040	; 0x41000000
    4826:	246f      	movs	r4, #111	; 0x6f
    4828:	f883 4107 	strb.w	r4, [r3, #263]	; 0x107
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    482c:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
    4830:	f882 4108 	strb.w	r4, [r2, #264]	; 0x108
	_usbd_ep_clear_bank_status(epn, 0);
	_usbd_ep_clear_bank_status(epn, 1);
	_usbd_ep_int_ack(epn, USB_D_BANK0_INT_FLAGS | USB_D_BANK1_INT_FLAGS);
	_usbd_ep_int_dis(epn, USB_D_BANK0_INT_FLAGS | USB_D_BANK1_INT_FLAGS);
	/* Invoke callback. */
	dev_inst.ep_callbacks.setup(ept->ep);
    4834:	6e8b      	ldr	r3, [r1, #104]	; 0x68
    4836:	7c80      	ldrb	r0, [r0, #18]
    4838:	4798      	blx	r3
    483a:	bd38      	pop	{r3, r4, r5, pc}
    483c:	200002d0 	.word	0x200002d0

00004840 <_usb_d_dev_handle_stall>:
 * \brief Handles stall sent interrupt
 * \param[in] ept Pointer to endpoint information.
 * \param[in] bank_n Bank number.
 */
static void _usb_d_dev_handle_stall(struct _usb_d_dev_ep *ept, const uint8_t bank_n)
{
    4840:	b508      	push	{r3, lr}
		_usbd_ep_int_dis(epn, USB_DEVICE_EPINTFLAG_STALL0 << bank_n);
    4842:	2320      	movs	r3, #32
    4844:	fa03 f101 	lsl.w	r1, r3, r1
	hri_usbendpoint_clear_EPINTEN_reg(USB, epn, flags);
    4848:	b2c9      	uxtb	r1, r1
	uint8_t epn = USB_EP_GET_N(ept->ep);
    484a:	7c83      	ldrb	r3, [r0, #18]
    484c:	f003 030f 	and.w	r3, r3, #15
    4850:	015b      	lsls	r3, r3, #5
    4852:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    4856:	f883 1108 	strb.w	r1, [r3, #264]	; 0x108
	/* Clear interrupt enable. Leave status there for status check. */
	_usbd_ep_int_stall_en(epn, bank_n, false);
	dev_inst.ep_callbacks.done(ept->ep, USB_TRANS_STALL, ept->trans_count);
    485a:	4b03      	ldr	r3, [pc, #12]	; (4868 <_usb_d_dev_handle_stall+0x28>)
    485c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    485e:	6882      	ldr	r2, [r0, #8]
    4860:	2101      	movs	r1, #1
    4862:	7c80      	ldrb	r0, [r0, #18]
    4864:	4798      	blx	r3
    4866:	bd08      	pop	{r3, pc}
    4868:	200002d0 	.word	0x200002d0

0000486c <_usb_d_dev_trans_done>:
 *  \brief Finish the transaction and invoke callback
 * \param[in, out] ept Pointer to endpoint information.
 * \param[in] code Information code passed.
 */
static void _usb_d_dev_trans_done(struct _usb_d_dev_ep *ept, const int32_t code)
{
    486c:	b538      	push	{r3, r4, r5, lr}
	if (!(_usb_d_dev_ep_is_used(ept) && _usb_d_dev_ep_is_busy(ept))) {
    486e:	7c84      	ldrb	r4, [r0, #18]
    4870:	2cff      	cmp	r4, #255	; 0xff
    4872:	d003      	beq.n	487c <_usb_d_dev_trans_done+0x10>
    4874:	7cc3      	ldrb	r3, [r0, #19]
    4876:	f013 0f40 	tst.w	r3, #64	; 0x40
    487a:	d100      	bne.n	487e <_usb_d_dev_trans_done+0x12>
    487c:	bd38      	pop	{r3, r4, r5, pc}
		return;
	}
	ept->flags.bits.is_busy = 0;
    487e:	7cc2      	ldrb	r2, [r0, #19]
    4880:	f36f 1286 	bfc	r2, #6, #1
    4884:	74c2      	strb	r2, [r0, #19]
	dev_inst.ep_callbacks.done(ept->ep, code, ept->trans_count);
    4886:	4a03      	ldr	r2, [pc, #12]	; (4894 <_usb_d_dev_trans_done+0x28>)
    4888:	6f15      	ldr	r5, [r2, #112]	; 0x70
    488a:	6882      	ldr	r2, [r0, #8]
    488c:	4620      	mov	r0, r4
    488e:	47a8      	blx	r5
    4890:	e7f4      	b.n	487c <_usb_d_dev_trans_done+0x10>
    4892:	bf00      	nop
    4894:	200002d0 	.word	0x200002d0

00004898 <_usb_d_dev_trans_stop>:
 * \param[in, out] ept Pointer to endpoint information.
 * \param[in] dir Endpoint direction.
 * \param[in] code Information code passed.
 */
static void _usb_d_dev_trans_stop(struct _usb_d_dev_ep *ept, bool dir, const int32_t code)
{
    4898:	b530      	push	{r4, r5, lr}
    489a:	b083      	sub	sp, #12
	uint8_t epn = USB_EP_GET_N(ept->ep);
    489c:	7c83      	ldrb	r3, [r0, #18]
	;
	const uint8_t intflags[2] = {USB_D_BANK0_INT_FLAGS, USB_D_BANK1_INT_FLAGS};
    489e:	2425      	movs	r4, #37	; 0x25
    48a0:	f88d 4004 	strb.w	r4, [sp, #4]
    48a4:	244a      	movs	r4, #74	; 0x4a
    48a6:	f88d 4005 	strb.w	r4, [sp, #5]
	if (!(_usb_d_dev_ep_is_used(ept) && _usb_d_dev_ep_is_busy(ept))) {
    48aa:	2bff      	cmp	r3, #255	; 0xff
    48ac:	d01e      	beq.n	48ec <_usb_d_dev_trans_stop+0x54>
    48ae:	7cc4      	ldrb	r4, [r0, #19]
    48b0:	f014 0f40 	tst.w	r4, #64	; 0x40
    48b4:	d01a      	beq.n	48ec <_usb_d_dev_trans_stop+0x54>
	uint8_t epn = USB_EP_GET_N(ept->ep);
    48b6:	f003 040f 	and.w	r4, r3, #15
		return;
	}
	/* Stop transfer */
	if (dir) {
    48ba:	b1c9      	cbz	r1, 48f0 <_usb_d_dev_trans_stop+0x58>
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    48bc:	0163      	lsls	r3, r4, #5
    48be:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    48c2:	2580      	movs	r5, #128	; 0x80
    48c4:	f883 5104 	strb.w	r5, [r3, #260]	; 0x104
    48c8:	460b      	mov	r3, r1
		_usbd_ep_set_in_rdy(epn, 1, false);
	} else {
		/* NAK OUT */
		_usbd_ep_set_out_rdy(epn, 0, false);
	}
	_usbd_ep_int_ack(epn, intflags[dir]);
    48ca:	a902      	add	r1, sp, #8
    48cc:	440b      	add	r3, r1
    48ce:	f813 1c04 	ldrb.w	r1, [r3, #-4]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    48d2:	0163      	lsls	r3, r4, #5
    48d4:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    48d8:	f883 1107 	strb.w	r1, [r3, #263]	; 0x107
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    48dc:	0163      	lsls	r3, r4, #5
    48de:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    48e2:	f883 1108 	strb.w	r1, [r3, #264]	; 0x108
	_usbd_ep_int_dis(epn, intflags[dir]);
	_usb_d_dev_trans_done(ept, code);
    48e6:	4611      	mov	r1, r2
    48e8:	4b05      	ldr	r3, [pc, #20]	; (4900 <_usb_d_dev_trans_stop+0x68>)
    48ea:	4798      	blx	r3
}
    48ec:	b003      	add	sp, #12
    48ee:	bd30      	pop	{r4, r5, pc}
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    48f0:	0163      	lsls	r3, r4, #5
    48f2:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    48f6:	2540      	movs	r5, #64	; 0x40
    48f8:	f883 5105 	strb.w	r5, [r3, #261]	; 0x105
    48fc:	e7e4      	b.n	48c8 <_usb_d_dev_trans_stop+0x30>
    48fe:	bf00      	nop
    4900:	0000486d 	.word	0x0000486d

00004904 <_usb_d_dev_handle_trfail>:
{
    4904:	b530      	push	{r4, r5, lr}
    4906:	b083      	sub	sp, #12
	uint8_t            epn     = USB_EP_GET_N(ept->ep);
    4908:	7c83      	ldrb	r3, [r0, #18]
    490a:	f003 030f 	and.w	r3, r3, #15
	const uint8_t      fail[2] = {USB_DEVICE_EPINTFLAG_TRFAIL0, USB_DEVICE_EPINTFLAG_TRFAIL1};
    490e:	2204      	movs	r2, #4
    4910:	f88d 2004 	strb.w	r2, [sp, #4]
    4914:	2208      	movs	r2, #8
    4916:	f88d 2005 	strb.w	r2, [sp, #5]
    491a:	015a      	lsls	r2, r3, #5
	uint8_t            eptype
    491c:	460c      	mov	r4, r1
    491e:	b391      	cbz	r1, 4986 <_usb_d_dev_handle_trfail+0x82>

static inline hri_usbendpoint_epcfg_reg_t hri_usbendpoint_read_EPCFG_EPTYPE1_bf(const void *const hw,
                                                                                uint8_t           submodule_index)
{
	uint8_t tmp;
	tmp = ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg;
    4920:	f102 4182 	add.w	r1, r2, #1090519040	; 0x41000000
    4924:	f891 5100 	ldrb.w	r5, [r1, #256]	; 0x100
	tmp = (tmp & USB_DEVICE_EPCFG_EPTYPE1_Msk) >> USB_DEVICE_EPCFG_EPTYPE1_Pos;
    4928:	f3c5 1502 	ubfx	r5, r5, #4, #3
	st.reg = bank[bank_n].STATUS_BK.reg;
    492c:	eb02 1104 	add.w	r1, r2, r4, lsl #4
    4930:	4a32      	ldr	r2, [pc, #200]	; (49fc <_usb_d_dev_handle_trfail+0xf8>)
    4932:	440a      	add	r2, r1
    4934:	7a91      	ldrb	r1, [r2, #10]
    4936:	b2c9      	uxtb	r1, r1
	if ((eptype == USB_D_EPTYPE_ISOCH) && st.bit.CRCERR) {
    4938:	2d02      	cmp	r5, #2
    493a:	d02c      	beq.n	4996 <_usb_d_dev_handle_trfail+0x92>
	} else if (st.bit.ERRORFLOW) {
    493c:	f011 0f02 	tst.w	r1, #2
    4940:	d045      	beq.n	49ce <_usb_d_dev_handle_trfail+0xca>
	bool                      is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
    4942:	7cc5      	ldrb	r5, [r0, #19]
		bank[bank_n].STATUS_BK.bit.ERRORFLOW = 0;
    4944:	7a91      	ldrb	r1, [r2, #10]
    4946:	f36f 0141 	bfc	r1, #1, #1
    494a:	7291      	strb	r1, [r2, #10]
		hri_usbendpoint_clear_EPINTFLAG_reg(hw, epn, fail[bank_n]);
    494c:	aa02      	add	r2, sp, #8
    494e:	4422      	add	r2, r4
    4950:	f812 1c04 	ldrb.w	r1, [r2, #-4]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    4954:	015a      	lsls	r2, r3, #5
    4956:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
    495a:	f882 1107 	strb.w	r1, [r2, #263]	; 0x107
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    495e:	015b      	lsls	r3, r3, #5
    4960:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    4964:	f883 1108 	strb.w	r1, [r3, #264]	; 0x108
		if (is_ctrl && _usb_d_dev_ep_is_busy(ept)) {
    4968:	f005 0307 	and.w	r3, r5, #7
    496c:	2b01      	cmp	r3, #1
    496e:	d143      	bne.n	49f8 <_usb_d_dev_handle_trfail+0xf4>
    4970:	7cc3      	ldrb	r3, [r0, #19]
    4972:	f013 0f40 	tst.w	r3, #64	; 0x40
    4976:	d03f      	beq.n	49f8 <_usb_d_dev_handle_trfail+0xf4>
			if (bank_n != _usb_d_dev_ep_is_in(ept)) {
    4978:	09d9      	lsrs	r1, r3, #7
    497a:	428c      	cmp	r4, r1
    497c:	d03c      	beq.n	49f8 <_usb_d_dev_handle_trfail+0xf4>
				_usb_d_dev_trans_stop(ept, _usb_d_dev_ep_is_in(ept), USB_TRANS_DONE);
    497e:	2200      	movs	r2, #0
    4980:	4b1f      	ldr	r3, [pc, #124]	; (4a00 <_usb_d_dev_handle_trfail+0xfc>)
    4982:	4798      	blx	r3
    4984:	e038      	b.n	49f8 <_usb_d_dev_handle_trfail+0xf4>
	tmp = ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg;
    4986:	0159      	lsls	r1, r3, #5
    4988:	f101 4182 	add.w	r1, r1, #1090519040	; 0x41000000
    498c:	f891 5100 	ldrb.w	r5, [r1, #256]	; 0x100
	tmp = (tmp & USB_DEVICE_EPCFG_EPTYPE0_Msk) >> USB_DEVICE_EPCFG_EPTYPE0_Pos;
    4990:	f005 0507 	and.w	r5, r5, #7
    4994:	e7ca      	b.n	492c <_usb_d_dev_handle_trfail+0x28>
	if ((eptype == USB_D_EPTYPE_ISOCH) && st.bit.CRCERR) {
    4996:	f011 0f01 	tst.w	r1, #1
    499a:	d0cf      	beq.n	493c <_usb_d_dev_handle_trfail+0x38>
		bank[bank_n].STATUS_BK.bit.CRCERR = 0;
    499c:	7a91      	ldrb	r1, [r2, #10]
    499e:	f36f 0100 	bfc	r1, #0, #1
    49a2:	7291      	strb	r1, [r2, #10]
		hri_usbendpoint_clear_EPINTFLAG_reg(hw, epn, fail[bank_n]);
    49a4:	aa02      	add	r2, sp, #8
    49a6:	4422      	add	r2, r4
    49a8:	f812 1c04 	ldrb.w	r1, [r2, #-4]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    49ac:	015a      	lsls	r2, r3, #5
    49ae:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
    49b2:	f882 1107 	strb.w	r1, [r2, #263]	; 0x107
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    49b6:	015b      	lsls	r3, r3, #5
    49b8:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    49bc:	f883 1108 	strb.w	r1, [r3, #264]	; 0x108
		_usb_d_dev_trans_stop(ept, bank_n, USB_TRANS_ERROR);
    49c0:	2204      	movs	r2, #4
    49c2:	1c21      	adds	r1, r4, #0
    49c4:	bf18      	it	ne
    49c6:	2101      	movne	r1, #1
    49c8:	4b0d      	ldr	r3, [pc, #52]	; (4a00 <_usb_d_dev_handle_trfail+0xfc>)
    49ca:	4798      	blx	r3
    49cc:	e014      	b.n	49f8 <_usb_d_dev_handle_trfail+0xf4>
	bank->STATUS_BK.reg     = 0;
    49ce:	eb04 0143 	add.w	r1, r4, r3, lsl #1
    49d2:	4a0a      	ldr	r2, [pc, #40]	; (49fc <_usb_d_dev_handle_trfail+0xf8>)
    49d4:	eb02 1201 	add.w	r2, r2, r1, lsl #4
    49d8:	2100      	movs	r1, #0
    49da:	7291      	strb	r1, [r2, #10]
		hri_usbendpoint_clear_EPINTFLAG_reg(hw, epn, fail[bank_n]);
    49dc:	aa02      	add	r2, sp, #8
    49de:	4414      	add	r4, r2
    49e0:	f814 1c04 	ldrb.w	r1, [r4, #-4]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    49e4:	015a      	lsls	r2, r3, #5
    49e6:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
    49ea:	f882 1107 	strb.w	r1, [r2, #263]	; 0x107
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    49ee:	015b      	lsls	r3, r3, #5
    49f0:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    49f4:	f883 1108 	strb.w	r1, [r3, #264]	; 0x108
}
    49f8:	b003      	add	sp, #12
    49fa:	bd30      	pop	{r4, r5, pc}
    49fc:	200002d0 	.word	0x200002d0
    4a00:	00004899 	.word	0x00004899

00004a04 <_usb_d_dev_reset_epts>:
{
    4a04:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    4a08:	4d0c      	ldr	r5, [pc, #48]	; (4a3c <_usb_d_dev_reset_epts+0x38>)
    4a0a:	f105 0474 	add.w	r4, r5, #116	; 0x74
    4a0e:	f505 7524 	add.w	r5, r5, #656	; 0x290
		_usb_d_dev_trans_done(&dev_inst.ep[i], USB_TRANS_RESET);
    4a12:	f04f 0803 	mov.w	r8, #3
    4a16:	4f0a      	ldr	r7, [pc, #40]	; (4a40 <_usb_d_dev_reset_epts+0x3c>)
		dev_inst.ep[i].ep       = 0xFF;
    4a18:	26ff      	movs	r6, #255	; 0xff
		_usb_d_dev_trans_done(&dev_inst.ep[i], USB_TRANS_RESET);
    4a1a:	4641      	mov	r1, r8
    4a1c:	4620      	mov	r0, r4
    4a1e:	47b8      	blx	r7
		dev_inst.ep[i].ep       = 0xFF;
    4a20:	74a6      	strb	r6, [r4, #18]
		dev_inst.ep[i].flags.u8 = 0;
    4a22:	2300      	movs	r3, #0
    4a24:	74e3      	strb	r3, [r4, #19]
    4a26:	3414      	adds	r4, #20
	for (i = 0; i < USB_D_N_EP; i++) {
    4a28:	42ac      	cmp	r4, r5
    4a2a:	d1f6      	bne.n	4a1a <_usb_d_dev_reset_epts+0x16>
	memset(prvt_inst.desc_table, 0, sizeof(UsbDeviceDescriptor) * (CONF_USB_D_MAX_EP_N + 1));
    4a2c:	2260      	movs	r2, #96	; 0x60
    4a2e:	4619      	mov	r1, r3
    4a30:	4802      	ldr	r0, [pc, #8]	; (4a3c <_usb_d_dev_reset_epts+0x38>)
    4a32:	4b04      	ldr	r3, [pc, #16]	; (4a44 <_usb_d_dev_reset_epts+0x40>)
    4a34:	4798      	blx	r3
    4a36:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    4a3a:	bf00      	nop
    4a3c:	200002d0 	.word	0x200002d0
    4a40:	0000486d 	.word	0x0000486d
    4a44:	000096ab 	.word	0x000096ab

00004a48 <_usb_d_dev_in_next>:
{
    4a48:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    4a4c:	4605      	mov	r5, r0
	uint8_t            epn         = USB_EP_GET_N(ept->ep);
    4a4e:	7c84      	ldrb	r4, [r0, #18]
    4a50:	f004 040f 	and.w	r4, r4, #15
	uint16_t           trans_count = isr ? bank[1].PCKSIZE.bit.BYTE_COUNT : 0;
    4a54:	4688      	mov	r8, r1
    4a56:	2900      	cmp	r1, #0
    4a58:	f000 809f 	beq.w	4b9a <_usb_d_dev_in_next+0x152>
	UsbDeviceDescBank *bank        = &prvt_inst.desc_table[epn].DeviceDescBank[0];
    4a5c:	4b58      	ldr	r3, [pc, #352]	; (4bc0 <_usb_d_dev_in_next+0x178>)
    4a5e:	eb03 1344 	add.w	r3, r3, r4, lsl #5
	uint16_t           trans_count = isr ? bank[1].PCKSIZE.bit.BYTE_COUNT : 0;
    4a62:	6958      	ldr	r0, [r3, #20]
    4a64:	f3c0 0e0d 	ubfx	lr, r0, #0, #14
	uint16_t           last_pkt = trans_count & ((ept->size == 1023) ? ept->size : (ept->size - 1));
    4a68:	8a2b      	ldrh	r3, [r5, #16]
    4a6a:	f240 32ff 	movw	r2, #1023	; 0x3ff
    4a6e:	4293      	cmp	r3, r2
    4a70:	f000 808d 	beq.w	4b8e <_usb_d_dev_in_next+0x146>
    4a74:	3b01      	subs	r3, #1
    4a76:	b298      	uxth	r0, r3
	bool               is_ctrl  = _usb_d_dev_ep_is_ctrl(ept);
    4a78:	7cef      	ldrb	r7, [r5, #19]
    4a7a:	f007 0707 	and.w	r7, r7, #7
	if (isr) {
    4a7e:	f1b8 0f00 	cmp.w	r8, #0
    4a82:	d005      	beq.n	4a90 <_usb_d_dev_in_next+0x48>
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    4a84:	0162      	lsls	r2, r4, #5
    4a86:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
    4a8a:	2302      	movs	r3, #2
    4a8c:	f882 3107 	strb.w	r3, [r2, #263]	; 0x107
	ept->trans_count += trans_count;
    4a90:	68a9      	ldr	r1, [r5, #8]
    4a92:	eb0e 0301 	add.w	r3, lr, r1
    4a96:	60ab      	str	r3, [r5, #8]
	if (ept->trans_count < ept->trans_size) {
    4a98:	686e      	ldr	r6, [r5, #4]
    4a9a:	42b3      	cmp	r3, r6
    4a9c:	d23f      	bcs.n	4b1e <_usb_d_dev_in_next+0xd6>
		trans_next = ept->trans_size - ept->trans_count;
    4a9e:	1af6      	subs	r6, r6, r3
    4aa0:	b2b6      	uxth	r6, r6
		if (ept->flags.bits.use_cache) {
    4aa2:	7cea      	ldrb	r2, [r5, #19]
    4aa4:	f012 0f20 	tst.w	r2, #32
    4aa8:	d02d      	beq.n	4b06 <_usb_d_dev_in_next+0xbe>
    4aaa:	8a2a      	ldrh	r2, [r5, #16]
    4aac:	4296      	cmp	r6, r2
    4aae:	bf28      	it	cs
    4ab0:	4616      	movcs	r6, r2
			memcpy(ept->cache, &ept->trans_buf[ept->trans_count], trans_next);
    4ab2:	6829      	ldr	r1, [r5, #0]
    4ab4:	4632      	mov	r2, r6
    4ab6:	4419      	add	r1, r3
    4ab8:	68e8      	ldr	r0, [r5, #12]
    4aba:	4b42      	ldr	r3, [pc, #264]	; (4bc4 <_usb_d_dev_in_next+0x17c>)
    4abc:	4798      	blx	r3
			_usbd_ep_set_buf(epn, 1, (uint32_t)ept->cache);
    4abe:	68ea      	ldr	r2, [r5, #12]
	bank->ADDR.reg          = addr;
    4ac0:	4b3f      	ldr	r3, [pc, #252]	; (4bc0 <_usb_d_dev_in_next+0x178>)
    4ac2:	eb03 1344 	add.w	r3, r3, r4, lsl #5
    4ac6:	611a      	str	r2, [r3, #16]
	bank->PCKSIZE.bit.BYTE_COUNT = size;
    4ac8:	4b3d      	ldr	r3, [pc, #244]	; (4bc0 <_usb_d_dev_in_next+0x178>)
    4aca:	eb03 1344 	add.w	r3, r3, r4, lsl #5
    4ace:	695a      	ldr	r2, [r3, #20]
    4ad0:	f366 020d 	bfi	r2, r6, #0, #14
    4ad4:	615a      	str	r2, [r3, #20]
	bank->PCKSIZE.bit.MULTI_PACKET_SIZE = count;
    4ad6:	695a      	ldr	r2, [r3, #20]
    4ad8:	f36f 329b 	bfc	r2, #14, #14
    4adc:	615a      	str	r2, [r3, #20]
	if (!isr) {
    4ade:	f1b8 0f00 	cmp.w	r8, #0
    4ae2:	d108      	bne.n	4af6 <_usb_d_dev_in_next+0xae>
			inten = USB_D_BANK1_INT_FLAGS;
    4ae4:	2f01      	cmp	r7, #1
    4ae6:	bf0c      	ite	eq
    4ae8:	224e      	moveq	r2, #78	; 0x4e
    4aea:	224a      	movne	r2, #74	; 0x4a
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENSET.reg = mask;
    4aec:	0163      	lsls	r3, r4, #5
    4aee:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    4af2:	f883 2109 	strb.w	r2, [r3, #265]	; 0x109
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    4af6:	0164      	lsls	r4, r4, #5
    4af8:	f104 4482 	add.w	r4, r4, #1090519040	; 0x41000000
    4afc:	2380      	movs	r3, #128	; 0x80
    4afe:	f884 3105 	strb.w	r3, [r4, #261]	; 0x105
    4b02:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    4b06:	f5b6 5f00 	cmp.w	r6, #8192	; 0x2000
    4b0a:	bf28      	it	cs
    4b0c:	f44f 5600 	movcs.w	r6, #8192	; 0x2000
			_usbd_ep_set_buf(epn, 1, (uint32_t)&ept->trans_buf[ept->trans_count]);
    4b10:	6829      	ldr	r1, [r5, #0]
    4b12:	440b      	add	r3, r1
	bank->ADDR.reg          = addr;
    4b14:	4a2a      	ldr	r2, [pc, #168]	; (4bc0 <_usb_d_dev_in_next+0x178>)
    4b16:	eb02 1244 	add.w	r2, r2, r4, lsl #5
    4b1a:	6113      	str	r3, [r2, #16]
    4b1c:	e7d4      	b.n	4ac8 <_usb_d_dev_in_next+0x80>
	} else if (ept->flags.bits.need_zlp) {
    4b1e:	7ceb      	ldrb	r3, [r5, #19]
    4b20:	f013 0f10 	tst.w	r3, #16
    4b24:	d00f      	beq.n	4b46 <_usb_d_dev_in_next+0xfe>
		ept->flags.bits.need_zlp = 0;
    4b26:	7ceb      	ldrb	r3, [r5, #19]
    4b28:	f36f 1304 	bfc	r3, #4, #1
    4b2c:	74eb      	strb	r3, [r5, #19]
	bank->PCKSIZE.bit.BYTE_COUNT = size;
    4b2e:	4b24      	ldr	r3, [pc, #144]	; (4bc0 <_usb_d_dev_in_next+0x178>)
    4b30:	eb03 1344 	add.w	r3, r3, r4, lsl #5
    4b34:	695a      	ldr	r2, [r3, #20]
    4b36:	f36f 020d 	bfc	r2, #0, #14
    4b3a:	615a      	str	r2, [r3, #20]
	bank->PCKSIZE.bit.MULTI_PACKET_SIZE = count;
    4b3c:	695a      	ldr	r2, [r3, #20]
    4b3e:	f36f 329b 	bfc	r2, #14, #14
    4b42:	615a      	str	r2, [r3, #20]
    4b44:	e7cb      	b.n	4ade <_usb_d_dev_in_next+0x96>
	if (is_ctrl) {
    4b46:	2f01      	cmp	r7, #1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    4b48:	ea4f 1444 	mov.w	r4, r4, lsl #5
    4b4c:	f104 4482 	add.w	r4, r4, #1090519040	; 0x41000000
    4b50:	bf0c      	ite	eq
    4b52:	234b      	moveq	r3, #75	; 0x4b
    4b54:	234a      	movne	r3, #74	; 0x4a
    4b56:	f884 3108 	strb.w	r3, [r4, #264]	; 0x108
	if (last_pkt == ept->size) {
    4b5a:	8a2a      	ldrh	r2, [r5, #16]
    4b5c:	ea00 030e 	and.w	r3, r0, lr
    4b60:	429a      	cmp	r2, r3
    4b62:	d005      	beq.n	4b70 <_usb_d_dev_in_next+0x128>
	_usb_d_dev_trans_done(ept, USB_TRANS_DONE);
    4b64:	2100      	movs	r1, #0
    4b66:	4628      	mov	r0, r5
    4b68:	4b17      	ldr	r3, [pc, #92]	; (4bc8 <_usb_d_dev_in_next+0x180>)
    4b6a:	4798      	blx	r3
	return;
    4b6c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		ept->flags.bits.is_busy = 0;
    4b70:	7ceb      	ldrb	r3, [r5, #19]
    4b72:	f36f 1386 	bfc	r3, #6, #1
    4b76:	74eb      	strb	r3, [r5, #19]
		if (dev_inst.ep_callbacks.more(ept->ep, ept->trans_count)) {
    4b78:	4b11      	ldr	r3, [pc, #68]	; (4bc0 <_usb_d_dev_in_next+0x178>)
    4b7a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    4b7c:	68a9      	ldr	r1, [r5, #8]
    4b7e:	7ca8      	ldrb	r0, [r5, #18]
    4b80:	4798      	blx	r3
    4b82:	b9d0      	cbnz	r0, 4bba <_usb_d_dev_in_next+0x172>
		ept->flags.bits.is_busy = 1;
    4b84:	7ceb      	ldrb	r3, [r5, #19]
    4b86:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    4b8a:	74eb      	strb	r3, [r5, #19]
    4b8c:	e7ea      	b.n	4b64 <_usb_d_dev_in_next+0x11c>
	bool               is_ctrl  = _usb_d_dev_ep_is_ctrl(ept);
    4b8e:	7cef      	ldrb	r7, [r5, #19]
    4b90:	f007 0707 	and.w	r7, r7, #7
    4b94:	f240 30ff 	movw	r0, #1023	; 0x3ff
    4b98:	e774      	b.n	4a84 <_usb_d_dev_in_next+0x3c>
	uint16_t           last_pkt = trans_count & ((ept->size == 1023) ? ept->size : (ept->size - 1));
    4b9a:	8a03      	ldrh	r3, [r0, #16]
    4b9c:	f240 32ff 	movw	r2, #1023	; 0x3ff
    4ba0:	4293      	cmp	r3, r2
    4ba2:	d107      	bne.n	4bb4 <_usb_d_dev_in_next+0x16c>
	bool               is_ctrl  = _usb_d_dev_ep_is_ctrl(ept);
    4ba4:	7cef      	ldrb	r7, [r5, #19]
    4ba6:	f007 0707 	and.w	r7, r7, #7
    4baa:	f04f 0e00 	mov.w	lr, #0
    4bae:	f240 30ff 	movw	r0, #1023	; 0x3ff
    4bb2:	e76d      	b.n	4a90 <_usb_d_dev_in_next+0x48>
	uint16_t           last_pkt = trans_count & ((ept->size == 1023) ? ept->size : (ept->size - 1));
    4bb4:	f04f 0e00 	mov.w	lr, #0
    4bb8:	e75c      	b.n	4a74 <_usb_d_dev_in_next+0x2c>
    4bba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    4bbe:	bf00      	nop
    4bc0:	200002d0 	.word	0x200002d0
    4bc4:	00009695 	.word	0x00009695
    4bc8:	0000486d 	.word	0x0000486d

00004bcc <_usb_d_dev_out_next>:
{
    4bcc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4bd0:	4604      	mov	r4, r0
	uint8_t            epn        = USB_EP_GET_N(ept->ep);
    4bd2:	7c85      	ldrb	r5, [r0, #18]
    4bd4:	f005 050f 	and.w	r5, r5, #15
	uint16_t           trans_size = isr ? bank->PCKSIZE.bit.MULTI_PACKET_SIZE : 0;
    4bd8:	4689      	mov	r9, r1
    4bda:	2900      	cmp	r1, #0
    4bdc:	d056      	beq.n	4c8c <_usb_d_dev_out_next+0xc0>
    4bde:	4b74      	ldr	r3, [pc, #464]	; (4db0 <_usb_d_dev_out_next+0x1e4>)
    4be0:	eb03 1345 	add.w	r3, r3, r5, lsl #5
    4be4:	685a      	ldr	r2, [r3, #4]
    4be6:	f3c2 3a8d 	ubfx	sl, r2, #14, #14
	uint16_t           last_trans = isr ? bank->PCKSIZE.bit.BYTE_COUNT : 0;
    4bea:	685f      	ldr	r7, [r3, #4]
    4bec:	f3c7 070d 	ubfx	r7, r7, #0, #14
    4bf0:	46bb      	mov	fp, r7
	uint16_t           size_mask  = (ept->size == 1023) ? 1023 : (ept->size - 1);
    4bf2:	8a06      	ldrh	r6, [r0, #16]
    4bf4:	f240 33ff 	movw	r3, #1023	; 0x3ff
    4bf8:	429e      	cmp	r6, r3
    4bfa:	f000 80ba 	beq.w	4d72 <_usb_d_dev_out_next+0x1a6>
    4bfe:	3e01      	subs	r6, #1
    4c00:	b2b6      	uxth	r6, r6
	uint16_t           last_pkt   = last_trans & size_mask;
    4c02:	ea06 070b 	and.w	r7, r6, fp
	bool               is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
    4c06:	f894 8013 	ldrb.w	r8, [r4, #19]
    4c0a:	f008 0807 	and.w	r8, r8, #7
	if (isr) {
    4c0e:	f1b9 0f00 	cmp.w	r9, #0
    4c12:	d005      	beq.n	4c20 <_usb_d_dev_out_next+0x54>
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    4c14:	016b      	lsls	r3, r5, #5
    4c16:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    4c1a:	2201      	movs	r2, #1
    4c1c:	f883 2107 	strb.w	r2, [r3, #263]	; 0x107
	if (ept->flags.bits.use_cache && ept->trans_size) {
    4c20:	7ce3      	ldrb	r3, [r4, #19]
    4c22:	f013 0f20 	tst.w	r3, #32
    4c26:	d00d      	beq.n	4c44 <_usb_d_dev_out_next+0x78>
    4c28:	6862      	ldr	r2, [r4, #4]
    4c2a:	2a00      	cmp	r2, #0
    4c2c:	d037      	beq.n	4c9e <_usb_d_dev_out_next+0xd2>
		uint16_t buf_remain = ept->trans_size - ept->trans_count;
    4c2e:	68a0      	ldr	r0, [r4, #8]
    4c30:	1a12      	subs	r2, r2, r0
    4c32:	b292      	uxth	r2, r2
		memcpy(&ept->trans_buf[ept->trans_count], ept->cache, (buf_remain > last_pkt) ? last_pkt : buf_remain);
    4c34:	6823      	ldr	r3, [r4, #0]
    4c36:	42ba      	cmp	r2, r7
    4c38:	bf28      	it	cs
    4c3a:	463a      	movcs	r2, r7
    4c3c:	68e1      	ldr	r1, [r4, #12]
    4c3e:	4418      	add	r0, r3
    4c40:	4b5c      	ldr	r3, [pc, #368]	; (4db4 <_usb_d_dev_out_next+0x1e8>)
    4c42:	4798      	blx	r3
	if (ept->trans_size == 0 && ept->flags.bits.need_zlp) {
    4c44:	6863      	ldr	r3, [r4, #4]
    4c46:	b353      	cbz	r3, 4c9e <_usb_d_dev_out_next+0xd2>
	} else if (isr && last_pkt < ept->size) {
    4c48:	f1b9 0f00 	cmp.w	r9, #0
    4c4c:	d040      	beq.n	4cd0 <_usb_d_dev_out_next+0x104>
    4c4e:	8a22      	ldrh	r2, [r4, #16]
    4c50:	42ba      	cmp	r2, r7
    4c52:	d93d      	bls.n	4cd0 <_usb_d_dev_out_next+0x104>
		ept->flags.bits.need_zlp = 0;
    4c54:	7ce3      	ldrb	r3, [r4, #19]
    4c56:	f36f 1304 	bfc	r3, #4, #1
    4c5a:	74e3      	strb	r3, [r4, #19]
		ept->trans_count += last_trans;
    4c5c:	68a3      	ldr	r3, [r4, #8]
    4c5e:	445b      	add	r3, fp
    4c60:	60a3      	str	r3, [r4, #8]
	if (is_ctrl) {
    4c62:	f1b8 0f01 	cmp.w	r8, #1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    4c66:	ea4f 1345 	mov.w	r3, r5, lsl #5
    4c6a:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    4c6e:	bf0c      	ite	eq
    4c70:	222d      	moveq	r2, #45	; 0x2d
    4c72:	2225      	movne	r2, #37	; 0x25
    4c74:	f883 2108 	strb.w	r2, [r3, #264]	; 0x108
	if (0 == epn) {
    4c78:	b915      	cbnz	r5, 4c80 <_usb_d_dev_out_next+0xb4>
		_usbd_ep_set_buf(epn, 0, (uint32_t)ept->cache);
    4c7a:	68e2      	ldr	r2, [r4, #12]
	bank->ADDR.reg          = addr;
    4c7c:	4b4c      	ldr	r3, [pc, #304]	; (4db0 <_usb_d_dev_out_next+0x1e4>)
    4c7e:	601a      	str	r2, [r3, #0]
	_usb_d_dev_trans_done(ept, USB_TRANS_DONE);
    4c80:	2100      	movs	r1, #0
    4c82:	4620      	mov	r0, r4
    4c84:	4b4c      	ldr	r3, [pc, #304]	; (4db8 <_usb_d_dev_out_next+0x1ec>)
    4c86:	4798      	blx	r3
	return;
    4c88:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	uint16_t           size_mask  = (ept->size == 1023) ? 1023 : (ept->size - 1);
    4c8c:	8a06      	ldrh	r6, [r0, #16]
    4c8e:	f240 33ff 	movw	r3, #1023	; 0x3ff
    4c92:	429e      	cmp	r6, r3
    4c94:	d07b      	beq.n	4d8e <_usb_d_dev_out_next+0x1c2>
    4c96:	f04f 0b00 	mov.w	fp, #0
    4c9a:	46da      	mov	sl, fp
    4c9c:	e7af      	b.n	4bfe <_usb_d_dev_out_next+0x32>
	if (ept->trans_size == 0 && ept->flags.bits.need_zlp) {
    4c9e:	7ce3      	ldrb	r3, [r4, #19]
    4ca0:	f013 0f10 	tst.w	r3, #16
    4ca4:	d06c      	beq.n	4d80 <_usb_d_dev_out_next+0x1b4>
		ept->flags.bits.need_zlp  = 0;
    4ca6:	7ce3      	ldrb	r3, [r4, #19]
		ept->flags.bits.use_cache = 1;
    4ca8:	f003 03ef 	and.w	r3, r3, #239	; 0xef
    4cac:	f043 0320 	orr.w	r3, r3, #32
    4cb0:	74e3      	strb	r3, [r4, #19]
		_usbd_ep_set_buf(epn, 0, (uint32_t)ept->cache);
    4cb2:	68e0      	ldr	r0, [r4, #12]
	bank->ADDR.reg          = addr;
    4cb4:	493e      	ldr	r1, [pc, #248]	; (4db0 <_usb_d_dev_out_next+0x1e4>)
    4cb6:	016a      	lsls	r2, r5, #5
    4cb8:	188b      	adds	r3, r1, r2
    4cba:	5088      	str	r0, [r1, r2]
	bank->PCKSIZE.bit.MULTI_PACKET_SIZE = size;
    4cbc:	8a21      	ldrh	r1, [r4, #16]
    4cbe:	685a      	ldr	r2, [r3, #4]
    4cc0:	f361 329b 	bfi	r2, r1, #14, #14
    4cc4:	605a      	str	r2, [r3, #4]
	bank->PCKSIZE.bit.BYTE_COUNT = count;
    4cc6:	685a      	ldr	r2, [r3, #4]
    4cc8:	f36f 020d 	bfc	r2, #0, #14
    4ccc:	605a      	str	r2, [r3, #4]
    4cce:	e01d      	b.n	4d0c <_usb_d_dev_out_next+0x140>
		ept->trans_count += trans_size;
    4cd0:	68a2      	ldr	r2, [r4, #8]
    4cd2:	4452      	add	r2, sl
    4cd4:	60a2      	str	r2, [r4, #8]
		if (ept->trans_count < ept->trans_size) {
    4cd6:	4293      	cmp	r3, r2
    4cd8:	d9c3      	bls.n	4c62 <_usb_d_dev_out_next+0x96>
			trans_next = ept->trans_size - ept->trans_count;
    4cda:	1a9b      	subs	r3, r3, r2
    4cdc:	b29b      	uxth	r3, r3
			if (ept->flags.bits.use_cache) {
    4cde:	7ce1      	ldrb	r1, [r4, #19]
    4ce0:	f011 0f20 	tst.w	r1, #32
    4ce4:	d026      	beq.n	4d34 <_usb_d_dev_out_next+0x168>
    4ce6:	8a22      	ldrh	r2, [r4, #16]
    4ce8:	4293      	cmp	r3, r2
    4cea:	bf28      	it	cs
    4cec:	4613      	movcs	r3, r2
				_usbd_ep_set_buf(epn, 0, (uint32_t)ept->cache);
    4cee:	68e0      	ldr	r0, [r4, #12]
	bank->ADDR.reg          = addr;
    4cf0:	016a      	lsls	r2, r5, #5
    4cf2:	492f      	ldr	r1, [pc, #188]	; (4db0 <_usb_d_dev_out_next+0x1e4>)
    4cf4:	5088      	str	r0, [r1, r2]
	bank->PCKSIZE.bit.MULTI_PACKET_SIZE = size;
    4cf6:	4a2e      	ldr	r2, [pc, #184]	; (4db0 <_usb_d_dev_out_next+0x1e4>)
    4cf8:	eb02 1245 	add.w	r2, r2, r5, lsl #5
    4cfc:	6851      	ldr	r1, [r2, #4]
    4cfe:	f363 319b 	bfi	r1, r3, #14, #14
    4d02:	6051      	str	r1, [r2, #4]
	bank->PCKSIZE.bit.BYTE_COUNT = count;
    4d04:	6853      	ldr	r3, [r2, #4]
    4d06:	f36f 030d 	bfc	r3, #0, #14
    4d0a:	6053      	str	r3, [r2, #4]
	if (!isr) {
    4d0c:	f1b9 0f00 	cmp.w	r9, #0
    4d10:	d108      	bne.n	4d24 <_usb_d_dev_out_next+0x158>
		if (is_ctrl) {
    4d12:	f1b8 0f01 	cmp.w	r8, #1
    4d16:	d025      	beq.n	4d64 <_usb_d_dev_out_next+0x198>
			inten = USB_D_BANK0_INT_FLAGS;
    4d18:	2225      	movs	r2, #37	; 0x25
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENSET.reg = mask;
    4d1a:	016b      	lsls	r3, r5, #5
    4d1c:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    4d20:	f883 2109 	strb.w	r2, [r3, #265]	; 0x109
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    4d24:	016d      	lsls	r5, r5, #5
    4d26:	f105 4582 	add.w	r5, r5, #1090519040	; 0x41000000
    4d2a:	2340      	movs	r3, #64	; 0x40
    4d2c:	f885 3104 	strb.w	r3, [r5, #260]	; 0x104
    4d30:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if (trans_next > ept->size) {
    4d34:	8a21      	ldrh	r1, [r4, #16]
    4d36:	428b      	cmp	r3, r1
    4d38:	d90a      	bls.n	4d50 <_usb_d_dev_out_next+0x184>
					if (trans_next > USB_D_DEV_TRANS_MAX) {
    4d3a:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
    4d3e:	d80e      	bhi.n	4d5e <_usb_d_dev_out_next+0x192>
    4d40:	ea23 0306 	bic.w	r3, r3, r6
				_usbd_ep_set_buf(epn, 0, (uint32_t)&ept->trans_buf[ept->trans_count]);
    4d44:	6821      	ldr	r1, [r4, #0]
    4d46:	440a      	add	r2, r1
	bank->ADDR.reg          = addr;
    4d48:	0169      	lsls	r1, r5, #5
    4d4a:	4819      	ldr	r0, [pc, #100]	; (4db0 <_usb_d_dev_out_next+0x1e4>)
    4d4c:	5042      	str	r2, [r0, r1]
    4d4e:	e7d2      	b.n	4cf6 <_usb_d_dev_out_next+0x12a>
				} else if (trans_next < ept->size) {
    4d50:	428b      	cmp	r3, r1
    4d52:	d2f7      	bcs.n	4d44 <_usb_d_dev_out_next+0x178>
					ept->flags.bits.use_cache = 1;
    4d54:	7ce1      	ldrb	r1, [r4, #19]
    4d56:	f041 0120 	orr.w	r1, r1, #32
    4d5a:	74e1      	strb	r1, [r4, #19]
    4d5c:	e7f2      	b.n	4d44 <_usb_d_dev_out_next+0x178>
						trans_next = USB_D_DEV_TRANS_MAX;
    4d5e:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    4d62:	e7ef      	b.n	4d44 <_usb_d_dev_out_next+0x178>
	bank->STATUS_BK.reg     = 0;
    4d64:	4b12      	ldr	r3, [pc, #72]	; (4db0 <_usb_d_dev_out_next+0x1e4>)
    4d66:	eb03 1345 	add.w	r3, r3, r5, lsl #5
    4d6a:	2200      	movs	r2, #0
    4d6c:	769a      	strb	r2, [r3, #26]
			inten = USB_D_BANK0_INT_FLAGS | USB_DEVICE_EPINTFLAG_TRFAIL1;
    4d6e:	222d      	movs	r2, #45	; 0x2d
    4d70:	e7d3      	b.n	4d1a <_usb_d_dev_out_next+0x14e>
	uint16_t           last_pkt   = last_trans & size_mask;
    4d72:	f3c7 0709 	ubfx	r7, r7, #0, #10
	bool               is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
    4d76:	f890 8013 	ldrb.w	r8, [r0, #19]
    4d7a:	f008 0807 	and.w	r8, r8, #7
    4d7e:	e749      	b.n	4c14 <_usb_d_dev_out_next+0x48>
	} else if (isr && last_pkt < ept->size) {
    4d80:	f1b9 0f00 	cmp.w	r9, #0
    4d84:	d10b      	bne.n	4d9e <_usb_d_dev_out_next+0x1d2>
		ept->trans_count += trans_size;
    4d86:	68a3      	ldr	r3, [r4, #8]
    4d88:	4453      	add	r3, sl
    4d8a:	60a3      	str	r3, [r4, #8]
    4d8c:	e769      	b.n	4c62 <_usb_d_dev_out_next+0x96>
	bool               is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
    4d8e:	f890 8013 	ldrb.w	r8, [r0, #19]
    4d92:	f008 0807 	and.w	r8, r8, #7
	uint16_t           last_pkt   = last_trans & size_mask;
    4d96:	2700      	movs	r7, #0
	bool               is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
    4d98:	46bb      	mov	fp, r7
    4d9a:	46ba      	mov	sl, r7
    4d9c:	e740      	b.n	4c20 <_usb_d_dev_out_next+0x54>
	} else if (isr && last_pkt < ept->size) {
    4d9e:	8a23      	ldrh	r3, [r4, #16]
    4da0:	42bb      	cmp	r3, r7
    4da2:	f63f af57 	bhi.w	4c54 <_usb_d_dev_out_next+0x88>
		ept->trans_count += trans_size;
    4da6:	68a3      	ldr	r3, [r4, #8]
    4da8:	4453      	add	r3, sl
    4daa:	60a3      	str	r3, [r4, #8]
    4dac:	e759      	b.n	4c62 <_usb_d_dev_out_next+0x96>
    4dae:	bf00      	nop
    4db0:	200002d0 	.word	0x200002d0
    4db4:	00009695 	.word	0x00009695
    4db8:	0000486d 	.word	0x0000486d

00004dbc <_usb_d_dev_handler>:
{
    4dbc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	uint16_t epint = hw->DEVICE.EPINTSMRY.reg;
    4dc0:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    4dc4:	8c1e      	ldrh	r6, [r3, #32]
    4dc6:	b2b6      	uxth	r6, r6
	if (0 == epint) {
    4dc8:	b146      	cbz	r6, 4ddc <_usb_d_dev_handler+0x20>
    4dca:	4d91      	ldr	r5, [pc, #580]	; (5010 <_usb_d_dev_handler+0x254>)
	uint32_t lpm_variable = 0;
    4dcc:	2400      	movs	r4, #0
		if ((ept->flags.bits.eptype == 0x1) && !_usb_d_dev_ep_is_busy(ept)) {
    4dce:	f1a5 0774 	sub.w	r7, r5, #116	; 0x74
			_usb_d_dev_handle_setup(ept);
    4dd2:	f8df 9258 	ldr.w	r9, [pc, #600]	; 502c <_usb_d_dev_handler+0x270>
			_usb_d_dev_handle_trfail(ept, 1);
    4dd6:	f8df 8258 	ldr.w	r8, [pc, #600]	; 5030 <_usb_d_dev_handler+0x274>
    4dda:	e0d3      	b.n	4f84 <_usb_d_dev_handler+0x1c8>
	return ((Usb *)hw)->DEVICE.INTFLAG.reg;
    4ddc:	8b9a      	ldrh	r2, [r3, #28]
	return ((Usb *)hw)->DEVICE.INTENSET.reg;
    4dde:	8b1b      	ldrh	r3, [r3, #24]
    4de0:	b29b      	uxth	r3, r3
	flags &= hri_usbdevice_read_INTEN_reg(USB);
    4de2:	4013      	ands	r3, r2
	if (flags & USB_DEVICE_INTFLAG_SOF) {
    4de4:	f013 0f04 	tst.w	r3, #4
    4de8:	d11d      	bne.n	4e26 <_usb_d_dev_handler+0x6a>
	if (flags & USB_DEVICE_INTFLAG_LPMSUSP) {
    4dea:	f413 7f00 	tst.w	r3, #512	; 0x200
    4dee:	d123      	bne.n	4e38 <_usb_d_dev_handler+0x7c>
	} else if (flags & USB_DEVICE_INTFLAG_RAMACER) {
    4df0:	f013 0f80 	tst.w	r3, #128	; 0x80
    4df4:	d147      	bne.n	4e86 <_usb_d_dev_handler+0xca>
	} else if (flags & USB_D_WAKEUP_INT_FLAGS) {
    4df6:	f013 0f70 	tst.w	r3, #112	; 0x70
    4dfa:	d14f      	bne.n	4e9c <_usb_d_dev_handler+0xe0>
	} else if (flags & USB_DEVICE_INTFLAG_EORST) {
    4dfc:	f013 0f08 	tst.w	r3, #8
    4e00:	d16e      	bne.n	4ee0 <_usb_d_dev_handler+0x124>
	} else if (flags & USB_DEVICE_INTFLAG_SUSPEND) {
    4e02:	f013 0f01 	tst.w	r3, #1
    4e06:	d0e0      	beq.n	4dca <_usb_d_dev_handler+0xe>
	((Usb *)hw)->DEVICE.INTFLAG.reg = mask;
    4e08:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    4e0c:	f240 2201 	movw	r2, #513	; 0x201
    4e10:	839a      	strh	r2, [r3, #28]
	((Usb *)hw)->DEVICE.INTENCLR.reg = mask;
    4e12:	829a      	strh	r2, [r3, #20]
	((Usb *)hw)->DEVICE.INTENSET.reg = mask;
    4e14:	2270      	movs	r2, #112	; 0x70
    4e16:	831a      	strh	r2, [r3, #24]
	dev_inst.callbacks.event(USB_EV_SUSPEND, 0);
    4e18:	4b7e      	ldr	r3, [pc, #504]	; (5014 <_usb_d_dev_handler+0x258>)
    4e1a:	6e5b      	ldr	r3, [r3, #100]	; 0x64
    4e1c:	2100      	movs	r1, #0
    4e1e:	2004      	movs	r0, #4
    4e20:	4798      	blx	r3
    4e22:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	((Usb *)hw)->DEVICE.INTFLAG.reg = mask;
    4e26:	2204      	movs	r2, #4
    4e28:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    4e2c:	839a      	strh	r2, [r3, #28]
	dev_inst.callbacks.sof();
    4e2e:	4b79      	ldr	r3, [pc, #484]	; (5014 <_usb_d_dev_handler+0x258>)
    4e30:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    4e32:	4798      	blx	r3
    4e34:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    4e38:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    4e3c:	f240 2201 	movw	r2, #513	; 0x201
    4e40:	839a      	strh	r2, [r3, #28]
	((Usb *)hw)->DEVICE.INTENCLR.reg = mask;
    4e42:	829a      	strh	r2, [r3, #20]
	((Usb *)hw)->DEVICE.INTENSET.reg = mask;
    4e44:	2270      	movs	r2, #112	; 0x70
    4e46:	831a      	strh	r2, [r3, #24]
		if (bank->EXTREG.bit.SUBPID == 0x3) {
    4e48:	4b72      	ldr	r3, [pc, #456]	; (5014 <_usb_d_dev_handler+0x258>)
    4e4a:	891b      	ldrh	r3, [r3, #8]
    4e4c:	f003 030f 	and.w	r3, r3, #15
    4e50:	2b03      	cmp	r3, #3
    4e52:	d00e      	beq.n	4e72 <_usb_d_dev_handler+0xb6>
    4e54:	4b6f      	ldr	r3, [pc, #444]	; (5014 <_usb_d_dev_handler+0x258>)
    4e56:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    4e58:	f003 030f 	and.w	r3, r3, #15
    4e5c:	2b03      	cmp	r3, #3
		UsbDeviceDescBank *bank = &prvt_inst.desc_table[i].DeviceDescBank[0];
    4e5e:	bf08      	it	eq
    4e60:	2201      	moveq	r2, #1
		if (bank->EXTREG.bit.SUBPID == 0x3) {
    4e62:	d007      	beq.n	4e74 <_usb_d_dev_handler+0xb8>
	uint32_t lpm_variable = 0;
    4e64:	2100      	movs	r1, #0
	dev_inst.callbacks.event(USB_EV_LPM_SUSPEND, lpm_variable);
    4e66:	4b6b      	ldr	r3, [pc, #428]	; (5014 <_usb_d_dev_handler+0x258>)
    4e68:	6e5b      	ldr	r3, [r3, #100]	; 0x64
    4e6a:	2003      	movs	r0, #3
    4e6c:	4798      	blx	r3
    4e6e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		UsbDeviceDescBank *bank = &prvt_inst.desc_table[i].DeviceDescBank[0];
    4e72:	2200      	movs	r2, #0
			lpm_variable = bank->EXTREG.bit.VARIABLE;
    4e74:	4b67      	ldr	r3, [pc, #412]	; (5014 <_usb_d_dev_handler+0x258>)
    4e76:	eb03 1342 	add.w	r3, r3, r2, lsl #5
    4e7a:	8919      	ldrh	r1, [r3, #8]
    4e7c:	f3c1 110a 	ubfx	r1, r1, #4, #11
			bank->EXTREG.reg = 0;
    4e80:	2200      	movs	r2, #0
    4e82:	811a      	strh	r2, [r3, #8]
    4e84:	e7ef      	b.n	4e66 <_usb_d_dev_handler+0xaa>
	((Usb *)hw)->DEVICE.INTFLAG.reg = mask;
    4e86:	2280      	movs	r2, #128	; 0x80
    4e88:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    4e8c:	839a      	strh	r2, [r3, #28]
	dev_inst.callbacks.event(USB_EV_ERROR, 0);
    4e8e:	4b61      	ldr	r3, [pc, #388]	; (5014 <_usb_d_dev_handler+0x258>)
    4e90:	6e5b      	ldr	r3, [r3, #100]	; 0x64
    4e92:	2100      	movs	r1, #0
    4e94:	2005      	movs	r0, #5
    4e96:	4798      	blx	r3
    4e98:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    4e9c:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    4ea0:	2270      	movs	r2, #112	; 0x70
    4ea2:	839a      	strh	r2, [r3, #28]
	((Usb *)hw)->DEVICE.INTENCLR.reg = mask;
    4ea4:	829a      	strh	r2, [r3, #20]
	((Usb *)hw)->DEVICE.INTENSET.reg = mask;
    4ea6:	f240 2201 	movw	r2, #513	; 0x201
    4eaa:	831a      	strh	r2, [r3, #24]
	tmp = ((Oscctrl *)hw)->DFLLCTRLB.reg;
    4eac:	4b5a      	ldr	r3, [pc, #360]	; (5018 <_usb_d_dev_handler+0x25c>)
    4eae:	f893 3020 	ldrb.w	r3, [r3, #32]
	if (hri_oscctrl_get_DFLLCTRLB_MODE_bit(OSCCTRL)) {
    4eb2:	f013 0f01 	tst.w	r3, #1
    4eb6:	d00d      	beq.n	4ed4 <_usb_d_dev_handler+0x118>
	tmp = ((Oscctrl *)hw)->STATUS.reg;
    4eb8:	4a57      	ldr	r2, [pc, #348]	; (5018 <_usb_d_dev_handler+0x25c>)
    4eba:	6913      	ldr	r3, [r2, #16]
	tmp &= mask;
    4ebc:	f403 6310 	and.w	r3, r3, #2304	; 0x900
		while (hri_oscctrl_get_STATUS_reg(OSCCTRL, (OSCCTRL_STATUS_DFLLRDY | OSCCTRL_STATUS_DFLLLCKC))
    4ec0:	f5b3 6f10 	cmp.w	r3, #2304	; 0x900
    4ec4:	d1f9      	bne.n	4eba <_usb_d_dev_handler+0xfe>
	dev_inst.callbacks.event(USB_EV_WAKEUP, 0);
    4ec6:	4b53      	ldr	r3, [pc, #332]	; (5014 <_usb_d_dev_handler+0x258>)
    4ec8:	6e5b      	ldr	r3, [r3, #100]	; 0x64
    4eca:	2100      	movs	r1, #0
    4ecc:	2002      	movs	r0, #2
    4ece:	4798      	blx	r3
    4ed0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	tmp = ((Oscctrl *)hw)->STATUS.reg;
    4ed4:	4a50      	ldr	r2, [pc, #320]	; (5018 <_usb_d_dev_handler+0x25c>)
    4ed6:	6913      	ldr	r3, [r2, #16]
		while (hri_oscctrl_get_STATUS_reg(OSCCTRL, OSCCTRL_STATUS_DFLLRDY) != OSCCTRL_STATUS_DFLLRDY)
    4ed8:	f413 7f80 	tst.w	r3, #256	; 0x100
    4edc:	d0fb      	beq.n	4ed6 <_usb_d_dev_handler+0x11a>
    4ede:	e7f2      	b.n	4ec6 <_usb_d_dev_handler+0x10a>

static inline void hri_usbendpoint_write_EPCFG_reg(const void *const hw, uint8_t submodule_index,
                                                   hri_usbendpoint_epcfg_reg_t data)
{
	USB_CRITICAL_SECTION_ENTER();
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg = data;
    4ee0:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    4ee4:	2400      	movs	r4, #0
    4ee6:	f883 4100 	strb.w	r4, [r3, #256]	; 0x100
	((Usb *)hw)->DEVICE.INTFLAG.reg = mask;
    4eea:	2208      	movs	r2, #8
    4eec:	839a      	strh	r2, [r3, #28]
	((Usb *)hw)->DEVICE.INTENCLR.reg = mask;
    4eee:	2270      	movs	r2, #112	; 0x70
    4ef0:	829a      	strh	r2, [r3, #20]
	((Usb *)hw)->DEVICE.INTENSET.reg = mask;
    4ef2:	f240 2201 	movw	r2, #513	; 0x201
    4ef6:	831a      	strh	r2, [r3, #24]
	_usb_d_dev_reset_epts();
    4ef8:	4b48      	ldr	r3, [pc, #288]	; (501c <_usb_d_dev_handler+0x260>)
    4efa:	4798      	blx	r3
	dev_inst.callbacks.event(USB_EV_RESET, 0);
    4efc:	4b45      	ldr	r3, [pc, #276]	; (5014 <_usb_d_dev_handler+0x258>)
    4efe:	6e5b      	ldr	r3, [r3, #100]	; 0x64
    4f00:	4621      	mov	r1, r4
    4f02:	2001      	movs	r0, #1
    4f04:	4798      	blx	r3
    4f06:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if (flags & USB_DEVICE_EPINTFLAG_RXSTP) {
    4f0a:	f011 0f10 	tst.w	r1, #16
    4f0e:	d109      	bne.n	4f24 <_usb_d_dev_handler+0x168>
	} else if (flags & USB_DEVICE_EPINTFLAG_STALL1) {
    4f10:	f011 0f40 	tst.w	r1, #64	; 0x40
    4f14:	d108      	bne.n	4f28 <_usb_d_dev_handler+0x16c>
	} else if (flags & USB_DEVICE_EPINTFLAG_STALL0) {
    4f16:	f011 0f20 	tst.w	r1, #32
    4f1a:	d02f      	beq.n	4f7c <_usb_d_dev_handler+0x1c0>
		_usb_d_dev_handle_stall(ept, 0);
    4f1c:	2100      	movs	r1, #0
    4f1e:	4b40      	ldr	r3, [pc, #256]	; (5020 <_usb_d_dev_handler+0x264>)
    4f20:	4798      	blx	r3
    4f22:	e02b      	b.n	4f7c <_usb_d_dev_handler+0x1c0>
		_usb_d_dev_handle_setup(ept);
    4f24:	47c8      	blx	r9
    4f26:	e029      	b.n	4f7c <_usb_d_dev_handler+0x1c0>
		_usb_d_dev_handle_stall(ept, 1);
    4f28:	2101      	movs	r1, #1
    4f2a:	4b3d      	ldr	r3, [pc, #244]	; (5020 <_usb_d_dev_handler+0x264>)
    4f2c:	4798      	blx	r3
    4f2e:	e025      	b.n	4f7c <_usb_d_dev_handler+0x1c0>
	if (flags & USB_DEVICE_EPINTFLAG_STALL1) {
    4f30:	f011 0f40 	tst.w	r1, #64	; 0x40
    4f34:	d111      	bne.n	4f5a <_usb_d_dev_handler+0x19e>
	} else if (flags & USB_DEVICE_EPINTFLAG_TRFAIL1) {
    4f36:	f011 0f08 	tst.w	r1, #8
    4f3a:	d112      	bne.n	4f62 <_usb_d_dev_handler+0x1a6>
	} else if (flags & USB_DEVICE_EPINTFLAG_TRCPT1) {
    4f3c:	f011 0f02 	tst.w	r1, #2
    4f40:	d112      	bne.n	4f68 <_usb_d_dev_handler+0x1ac>
	} else if (_usb_d_dev_ep_is_ctrl(ept)) {
    4f42:	f003 0307 	and.w	r3, r3, #7
    4f46:	2b01      	cmp	r3, #1
    4f48:	d118      	bne.n	4f7c <_usb_d_dev_handler+0x1c0>
		if (flags & USB_DEVICE_EPINTFLAG_TRFAIL0) {
    4f4a:	f011 0f04 	tst.w	r1, #4
    4f4e:	d10f      	bne.n	4f70 <_usb_d_dev_handler+0x1b4>
		} else if (flags & USB_DEVICE_EPINTFLAG_RXSTP) {
    4f50:	f011 0f10 	tst.w	r1, #16
    4f54:	d012      	beq.n	4f7c <_usb_d_dev_handler+0x1c0>
			_usb_d_dev_handle_setup(ept);
    4f56:	47c8      	blx	r9
    4f58:	e010      	b.n	4f7c <_usb_d_dev_handler+0x1c0>
		_usb_d_dev_handle_stall(ept, 1);
    4f5a:	2101      	movs	r1, #1
    4f5c:	4b30      	ldr	r3, [pc, #192]	; (5020 <_usb_d_dev_handler+0x264>)
    4f5e:	4798      	blx	r3
    4f60:	e00c      	b.n	4f7c <_usb_d_dev_handler+0x1c0>
		_usb_d_dev_handle_trfail(ept, 1);
    4f62:	2101      	movs	r1, #1
    4f64:	47c0      	blx	r8
    4f66:	e009      	b.n	4f7c <_usb_d_dev_handler+0x1c0>
		_usb_d_dev_in_next(ept, true);
    4f68:	2101      	movs	r1, #1
    4f6a:	4b2e      	ldr	r3, [pc, #184]	; (5024 <_usb_d_dev_handler+0x268>)
    4f6c:	4798      	blx	r3
    4f6e:	e005      	b.n	4f7c <_usb_d_dev_handler+0x1c0>
			_usb_d_dev_handle_trfail(ept, 0);
    4f70:	2100      	movs	r1, #0
    4f72:	47c0      	blx	r8
    4f74:	e002      	b.n	4f7c <_usb_d_dev_handler+0x1c0>
		_usb_d_dev_handle_stall(ept, 0);
    4f76:	2100      	movs	r1, #0
    4f78:	4b29      	ldr	r3, [pc, #164]	; (5020 <_usb_d_dev_handler+0x264>)
    4f7a:	4798      	blx	r3
    4f7c:	3401      	adds	r4, #1
    4f7e:	3514      	adds	r5, #20
	for (i = 0; i < USB_D_N_EP; i++) {
    4f80:	2c1b      	cmp	r4, #27
    4f82:	d042      	beq.n	500a <_usb_d_dev_handler+0x24e>
    4f84:	4628      	mov	r0, r5
		if (ept->ep == 0xFF) {
    4f86:	7cab      	ldrb	r3, [r5, #18]
    4f88:	2bff      	cmp	r3, #255	; 0xff
    4f8a:	d0f7      	beq.n	4f7c <_usb_d_dev_handler+0x1c0>
	if (!(epint & (1u << epn))) {
    4f8c:	f003 030f 	and.w	r3, r3, #15
    4f90:	2101      	movs	r1, #1
    4f92:	4099      	lsls	r1, r3
    4f94:	4231      	tst	r1, r6
    4f96:	d0f1      	beq.n	4f7c <_usb_d_dev_handler+0x1c0>
	flags = hw->DEVICE.DeviceEndpoint[epn].EPINTFLAG.reg;
    4f98:	0159      	lsls	r1, r3, #5
    4f9a:	f101 4182 	add.w	r1, r1, #1090519040	; 0x41000000
    4f9e:	f501 7180 	add.w	r1, r1, #256	; 0x100
    4fa2:	79c9      	ldrb	r1, [r1, #7]
	mask  = hw->DEVICE.DeviceEndpoint[epn].EPINTENSET.reg;
    4fa4:	015b      	lsls	r3, r3, #5
    4fa6:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    4faa:	f893 3109 	ldrb.w	r3, [r3, #265]	; 0x109
	if (flags) {
    4fae:	4019      	ands	r1, r3
    4fb0:	d0e4      	beq.n	4f7c <_usb_d_dev_handler+0x1c0>
		if ((ept->flags.bits.eptype == 0x1) && !_usb_d_dev_ep_is_busy(ept)) {
    4fb2:	eb04 0284 	add.w	r2, r4, r4, lsl #2
    4fb6:	eb07 0282 	add.w	r2, r7, r2, lsl #2
    4fba:	f892 3087 	ldrb.w	r3, [r2, #135]	; 0x87
    4fbe:	f003 0247 	and.w	r2, r3, #71	; 0x47
    4fc2:	2a01      	cmp	r2, #1
    4fc4:	d0a1      	beq.n	4f0a <_usb_d_dev_handler+0x14e>
		} else if (_usb_d_dev_ep_is_in(ept)) {
    4fc6:	f013 0f80 	tst.w	r3, #128	; 0x80
    4fca:	d1b1      	bne.n	4f30 <_usb_d_dev_handler+0x174>
	if (flags & USB_DEVICE_EPINTFLAG_STALL0) {
    4fcc:	f011 0f20 	tst.w	r1, #32
    4fd0:	d1d1      	bne.n	4f76 <_usb_d_dev_handler+0x1ba>
	} else if (flags & USB_DEVICE_EPINTFLAG_TRFAIL0) {
    4fd2:	f011 0f04 	tst.w	r1, #4
    4fd6:	d10e      	bne.n	4ff6 <_usb_d_dev_handler+0x23a>
	} else if (flags & USB_DEVICE_EPINTFLAG_TRCPT0) {
    4fd8:	f011 0f01 	tst.w	r1, #1
    4fdc:	d10e      	bne.n	4ffc <_usb_d_dev_handler+0x240>
	} else if (_usb_d_dev_ep_is_ctrl(ept)) {
    4fde:	f003 0307 	and.w	r3, r3, #7
    4fe2:	2b01      	cmp	r3, #1
    4fe4:	d1ca      	bne.n	4f7c <_usb_d_dev_handler+0x1c0>
		if (flags & USB_DEVICE_EPINTFLAG_TRFAIL1) {
    4fe6:	f011 0f08 	tst.w	r1, #8
    4fea:	d10b      	bne.n	5004 <_usb_d_dev_handler+0x248>
		} else if (flags & USB_DEVICE_EPINTFLAG_RXSTP) {
    4fec:	f011 0f10 	tst.w	r1, #16
    4ff0:	d0c4      	beq.n	4f7c <_usb_d_dev_handler+0x1c0>
			_usb_d_dev_handle_setup(ept);
    4ff2:	47c8      	blx	r9
    4ff4:	e7c2      	b.n	4f7c <_usb_d_dev_handler+0x1c0>
		_usb_d_dev_handle_trfail(ept, 0);
    4ff6:	2100      	movs	r1, #0
    4ff8:	47c0      	blx	r8
    4ffa:	e7bf      	b.n	4f7c <_usb_d_dev_handler+0x1c0>
		_usb_d_dev_out_next(ept, true);
    4ffc:	2101      	movs	r1, #1
    4ffe:	4b0a      	ldr	r3, [pc, #40]	; (5028 <_usb_d_dev_handler+0x26c>)
    5000:	4798      	blx	r3
    5002:	e7bb      	b.n	4f7c <_usb_d_dev_handler+0x1c0>
			_usb_d_dev_handle_trfail(ept, 1);
    5004:	2101      	movs	r1, #1
    5006:	47c0      	blx	r8
    5008:	e7b8      	b.n	4f7c <_usb_d_dev_handler+0x1c0>
    500a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    500e:	bf00      	nop
    5010:	20000344 	.word	0x20000344
    5014:	200002d0 	.word	0x200002d0
    5018:	40001000 	.word	0x40001000
    501c:	00004a05 	.word	0x00004a05
    5020:	00004841 	.word	0x00004841
    5024:	00004a49 	.word	0x00004a49
    5028:	00004bcd 	.word	0x00004bcd
    502c:	000047c5 	.word	0x000047c5
    5030:	00004905 	.word	0x00004905

00005034 <_usb_d_dev_init>:
{
    5034:	b508      	push	{r3, lr}
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    5036:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
    503a:	7893      	ldrb	r3, [r2, #2]
    503c:	f013 0f01 	tst.w	r3, #1
    5040:	d1fb      	bne.n	503a <_usb_d_dev_init+0x6>
    5042:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
    5046:	7893      	ldrb	r3, [r2, #2]
    5048:	f013 0f03 	tst.w	r3, #3
    504c:	d1fb      	bne.n	5046 <_usb_d_dev_init+0x12>
	tmp = ((Usb *)hw)->DEVICE.CTRLA.reg;
    504e:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    5052:	781b      	ldrb	r3, [r3, #0]
	if (hri_usbdevice_get_CTRLA_ENABLE_bit(hw)) {
    5054:	f013 0f02 	tst.w	r3, #2
    5058:	d14d      	bne.n	50f6 <_usb_d_dev_init+0xc2>
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    505a:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
    505e:	7893      	ldrb	r3, [r2, #2]
    5060:	f013 0f01 	tst.w	r3, #1
    5064:	d1fb      	bne.n	505e <_usb_d_dev_init+0x2a>
	((Usb *)hw)->DEVICE.CTRLA.reg |= USB_CTRLA_SWRST;
    5066:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
    506a:	7813      	ldrb	r3, [r2, #0]
    506c:	f043 0301 	orr.w	r3, r3, #1
    5070:	7013      	strb	r3, [r2, #0]
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    5072:	7893      	ldrb	r3, [r2, #2]
    5074:	f013 0f01 	tst.w	r3, #1
    5078:	d1fb      	bne.n	5072 <_usb_d_dev_init+0x3e>
	dev_inst.callbacks.sof   = (_usb_d_dev_sof_cb_t)_dummy_func_no_return;
    507a:	4b20      	ldr	r3, [pc, #128]	; (50fc <_usb_d_dev_init+0xc8>)
    507c:	4a20      	ldr	r2, [pc, #128]	; (5100 <_usb_d_dev_init+0xcc>)
    507e:	661a      	str	r2, [r3, #96]	; 0x60
	dev_inst.callbacks.event = (_usb_d_dev_event_cb_t)_dummy_func_no_return;
    5080:	665a      	str	r2, [r3, #100]	; 0x64
	dev_inst.ep_callbacks.setup = (_usb_d_dev_ep_cb_setup_t)_dummy_func_no_return;
    5082:	669a      	str	r2, [r3, #104]	; 0x68
	dev_inst.ep_callbacks.more  = (_usb_d_dev_ep_cb_more_t)_dummy_func_no_return;
    5084:	66da      	str	r2, [r3, #108]	; 0x6c
	dev_inst.ep_callbacks.done  = (_usb_d_dev_ep_cb_done_t)_dummy_func_no_return;
    5086:	671a      	str	r2, [r3, #112]	; 0x70
	_usb_d_dev_reset_epts();
    5088:	4b1e      	ldr	r3, [pc, #120]	; (5104 <_usb_d_dev_init+0xd0>)
    508a:	4798      	blx	r3
	    = (*((uint32_t *)(NVMCTRL_SW0) + (NVM_USB_PAD_TRANSN_POS / 32)) >> (NVM_USB_PAD_TRANSN_POS % 32))
    508c:	4b1e      	ldr	r3, [pc, #120]	; (5108 <_usb_d_dev_init+0xd4>)
    508e:	6819      	ldr	r1, [r3, #0]
	uint32_t pad_transp
    5090:	f3c1 1344 	ubfx	r3, r1, #5, #5
	uint32_t pad_trim = (*((uint32_t *)(NVMCTRL_SW0) + (NVM_USB_PAD_TRIM_POS / 32)) >> (NVM_USB_PAD_TRIM_POS % 32))
    5094:	f3c1 2282 	ubfx	r2, r1, #10, #3
	if (pad_transn == 0 || pad_transn == 0x1F) {
    5098:	f011 011f 	ands.w	r1, r1, #31
    509c:	d025      	beq.n	50ea <_usb_d_dev_init+0xb6>
		pad_transn = 9;
    509e:	291f      	cmp	r1, #31
    50a0:	bf08      	it	eq
    50a2:	2109      	moveq	r1, #9
	if (pad_transp == 0 || pad_transp == 0x1F) {
    50a4:	b31b      	cbz	r3, 50ee <_usb_d_dev_init+0xba>
		pad_transp = 25;
    50a6:	2b1f      	cmp	r3, #31
    50a8:	bf08      	it	eq
    50aa:	2319      	moveq	r3, #25
	if (pad_trim == 0 || pad_trim == 0x7) {
    50ac:	b30a      	cbz	r2, 50f2 <_usb_d_dev_init+0xbe>
		pad_trim = 6;
    50ae:	2a07      	cmp	r2, #7
    50b0:	bf08      	it	eq
    50b2:	2206      	moveq	r2, #6
	hw->DEVICE.PADCAL.reg = USB_PADCAL_TRANSN(pad_transn) | USB_PADCAL_TRANSP(pad_transp) | USB_PADCAL_TRIM(pad_trim);
    50b4:	f003 031f 	and.w	r3, r3, #31
    50b8:	ea43 1381 	orr.w	r3, r3, r1, lsl #6
    50bc:	0312      	lsls	r2, r2, #12
    50be:	f402 42e0 	and.w	r2, r2, #28672	; 0x7000
    50c2:	4313      	orrs	r3, r2
    50c4:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
    50c8:	8513      	strh	r3, [r2, #40]	; 0x28
	hw->DEVICE.QOSCTRL.bit.CQOS = 3;
    50ca:	78d3      	ldrb	r3, [r2, #3]
    50cc:	f043 0303 	orr.w	r3, r3, #3
    50d0:	70d3      	strb	r3, [r2, #3]
	hw->DEVICE.QOSCTRL.bit.DQOS = 3;
    50d2:	78d3      	ldrb	r3, [r2, #3]
    50d4:	f043 030c 	orr.w	r3, r3, #12
    50d8:	70d3      	strb	r3, [r2, #3]
	((Usb *)hw)->DEVICE.CTRLA.reg = data;
    50da:	2304      	movs	r3, #4
    50dc:	7013      	strb	r3, [r2, #0]
	hri_usbdevice_write_DESCADD_reg(hw, (uint32_t)prvt_inst.desc_table);
    50de:	4b07      	ldr	r3, [pc, #28]	; (50fc <_usb_d_dev_init+0xc8>)
	((Usb *)hw)->DEVICE.DESCADD.reg = data;
    50e0:	6253      	str	r3, [r2, #36]	; 0x24
	((Usb *)hw)->DEVICE.CTRLB.reg = data;
    50e2:	2301      	movs	r3, #1
    50e4:	8113      	strh	r3, [r2, #8]
	return ERR_NONE;
    50e6:	2000      	movs	r0, #0
    50e8:	bd08      	pop	{r3, pc}
		pad_transn = 9;
    50ea:	2109      	movs	r1, #9
    50ec:	e7da      	b.n	50a4 <_usb_d_dev_init+0x70>
		pad_transp = 25;
    50ee:	2319      	movs	r3, #25
    50f0:	e7dc      	b.n	50ac <_usb_d_dev_init+0x78>
		pad_trim = 6;
    50f2:	2206      	movs	r2, #6
    50f4:	e7de      	b.n	50b4 <_usb_d_dev_init+0x80>
		return ERR_DENIED;
    50f6:	f06f 0010 	mvn.w	r0, #16
}
    50fa:	bd08      	pop	{r3, pc}
    50fc:	200002d0 	.word	0x200002d0
    5100:	000047c1 	.word	0x000047c1
    5104:	00004a05 	.word	0x00004a05
    5108:	00800084 	.word	0x00800084

0000510c <_usb_d_dev_enable>:
	tmp = ((Usb *)hw)->DEVICE.SYNCBUSY.reg;
    510c:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    5110:	789b      	ldrb	r3, [r3, #2]
	if (hri_usbdevice_get_SYNCBUSY_reg(hw, (USB_SYNCBUSY_ENABLE | USB_SYNCBUSY_SWRST))) {
    5112:	f013 0f03 	tst.w	r3, #3
    5116:	d11f      	bne.n	5158 <_usb_d_dev_enable+0x4c>
	return ((Usb *)hw)->DEVICE.CTRLA.reg;
    5118:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    511c:	781b      	ldrb	r3, [r3, #0]
    511e:	b2db      	uxtb	r3, r3
	if ((ctrla & USB_CTRLA_ENABLE) == 0) {
    5120:	f013 0f02 	tst.w	r3, #2
    5124:	d104      	bne.n	5130 <_usb_d_dev_enable+0x24>
		hri_usbdevice_write_CTRLA_reg(hw, ctrla | USB_CTRLA_ENABLE);
    5126:	f043 0302 	orr.w	r3, r3, #2
	((Usb *)hw)->DEVICE.CTRLA.reg = data;
    512a:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
    512e:	7013      	strb	r3, [r2, #0]
    5130:	4b0b      	ldr	r3, [pc, #44]	; (5160 <_usb_d_dev_enable+0x54>)
    5132:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    5136:	609a      	str	r2, [r3, #8]
    5138:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    513c:	609a      	str	r2, [r3, #8]
    513e:	f44f 2280 	mov.w	r2, #262144	; 0x40000
    5142:	609a      	str	r2, [r3, #8]
    5144:	f44f 2200 	mov.w	r2, #524288	; 0x80000
    5148:	609a      	str	r2, [r3, #8]
	((Usb *)hw)->DEVICE.INTENSET.reg = mask;
    514a:	f240 228d 	movw	r2, #653	; 0x28d
    514e:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    5152:	831a      	strh	r2, [r3, #24]
	return ERR_NONE;
    5154:	2000      	movs	r0, #0
    5156:	4770      	bx	lr
		return -USB_ERR_DENIED;
    5158:	f06f 0010 	mvn.w	r0, #16
}
    515c:	4770      	bx	lr
    515e:	bf00      	nop
    5160:	e000e100 	.word	0xe000e100

00005164 <_usb_d_dev_attach>:
	((Usb *)hw)->DEVICE.CTRLB.reg &= ~USB_DEVICE_CTRLB_DETACH;
    5164:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
    5168:	8913      	ldrh	r3, [r2, #8]
    516a:	f023 0301 	bic.w	r3, r3, #1
    516e:	041b      	lsls	r3, r3, #16
    5170:	0c1b      	lsrs	r3, r3, #16
    5172:	8113      	strh	r3, [r2, #8]
    5174:	4770      	bx	lr

00005176 <_usb_d_dev_set_address>:
	hri_usbdevice_write_DADD_reg(USB, USB_DEVICE_DADD_ADDEN | USB_DEVICE_DADD_DADD(addr));
    5176:	f040 0080 	orr.w	r0, r0, #128	; 0x80
	((Usb *)hw)->DEVICE.DADD.reg = data;
    517a:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    517e:	7298      	strb	r0, [r3, #10]
    5180:	4770      	bx	lr
	...

00005184 <_usb_d_dev_ep_init>:
{
    5184:	b5f0      	push	{r4, r5, r6, r7, lr}
    5186:	fa4f fe80 	sxtb.w	lr, r0
	uint8_t ep_index = (epn == 0) ? 0 : (dir ? (epn + CONF_USB_D_MAX_EP_N) : epn);
    518a:	f010 050f 	ands.w	r5, r0, #15
    518e:	d04d      	beq.n	522c <_usb_d_dev_ep_init+0xa8>
    5190:	f1be 0f00 	cmp.w	lr, #0
    5194:	bfb4      	ite	lt
    5196:	1cac      	addlt	r4, r5, #2
    5198:	462c      	movge	r4, r5
	uint8_t                        ep_type = attr & USB_EP_XTYPE_MASK;
    519a:	f001 0103 	and.w	r1, r1, #3
	const struct _usb_ep_cfg_item *pcfg    = &_usb_ep_cfgs[epn];
    519e:	462b      	mov	r3, r5
	if (epn > CONF_USB_D_MAX_EP_N) {
    51a0:	2d02      	cmp	r5, #2
    51a2:	d947      	bls.n	5234 <_usb_d_dev_ep_init+0xb0>
		return -USB_ERR_PARAM;
    51a4:	f06f 0011 	mvn.w	r0, #17
    51a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if ((dir ? pcfg->i_cache : pcfg->cache) && ((dir ? pcfg->i_size : pcfg->size) < max_pkt_siz)) {
    51aa:	f1be 0f00 	cmp.w	lr, #0
    51ae:	db1b      	blt.n	51e8 <_usb_d_dev_ep_init+0x64>
    51b0:	eb03 0543 	add.w	r5, r3, r3, lsl #1
    51b4:	4e37      	ldr	r6, [pc, #220]	; (5294 <_usb_d_dev_ep_init+0x110>)
    51b6:	f856 5025 	ldr.w	r5, [r6, r5, lsl #2]
    51ba:	2d00      	cmp	r5, #0
    51bc:	d15e      	bne.n	527c <_usb_d_dev_ep_init+0xf8>
	ept->cache    = (uint8_t *)(dir ? pcfg->i_cache : pcfg->cache);
    51be:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    51c2:	4d34      	ldr	r5, [pc, #208]	; (5294 <_usb_d_dev_ep_init+0x110>)
    51c4:	f855 7023 	ldr.w	r7, [r5, r3, lsl #2]
    51c8:	4d33      	ldr	r5, [pc, #204]	; (5298 <_usb_d_dev_ep_init+0x114>)
    51ca:	00a6      	lsls	r6, r4, #2
    51cc:	1933      	adds	r3, r6, r4
    51ce:	eb05 0383 	add.w	r3, r5, r3, lsl #2
    51d2:	f8c3 7080 	str.w	r7, [r3, #128]	; 0x80
	ept->size     = max_pkt_siz;
    51d6:	f8a3 2084 	strh.w	r2, [r3, #132]	; 0x84
	ept->flags.u8 = (ep_type + 1);
    51da:	3101      	adds	r1, #1
    51dc:	f883 1087 	strb.w	r1, [r3, #135]	; 0x87
	ept->ep       = ep;
    51e0:	f883 0086 	strb.w	r0, [r3, #134]	; 0x86
	return USB_OK;
    51e4:	2000      	movs	r0, #0
    51e6:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if ((dir ? pcfg->i_cache : pcfg->cache) && ((dir ? pcfg->i_size : pcfg->size) < max_pkt_siz)) {
    51e8:	eb03 0543 	add.w	r5, r3, r3, lsl #1
    51ec:	4e29      	ldr	r6, [pc, #164]	; (5294 <_usb_d_dev_ep_init+0x110>)
    51ee:	eb06 0585 	add.w	r5, r6, r5, lsl #2
    51f2:	686d      	ldr	r5, [r5, #4]
    51f4:	b935      	cbnz	r5, 5204 <_usb_d_dev_ep_init+0x80>
	ept->cache    = (uint8_t *)(dir ? pcfg->i_cache : pcfg->cache);
    51f6:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    51fa:	4d26      	ldr	r5, [pc, #152]	; (5294 <_usb_d_dev_ep_init+0x110>)
    51fc:	eb05 0383 	add.w	r3, r5, r3, lsl #2
    5200:	685f      	ldr	r7, [r3, #4]
    5202:	e7e1      	b.n	51c8 <_usb_d_dev_ep_init+0x44>
	if ((dir ? pcfg->i_cache : pcfg->cache) && ((dir ? pcfg->i_size : pcfg->size) < max_pkt_siz)) {
    5204:	eb03 0543 	add.w	r5, r3, r3, lsl #1
    5208:	4e22      	ldr	r6, [pc, #136]	; (5294 <_usb_d_dev_ep_init+0x110>)
    520a:	eb06 0585 	add.w	r5, r6, r5, lsl #2
    520e:	896d      	ldrh	r5, [r5, #10]
    5210:	4295      	cmp	r5, r2
    5212:	daf0      	bge.n	51f6 <_usb_d_dev_ep_init+0x72>
		return -USB_ERR_FUNC;
    5214:	f06f 0012 	mvn.w	r0, #18
    5218:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return -USB_ERR_REDO;
    521a:	f06f 0013 	mvn.w	r0, #19
    521e:	bdf0      	pop	{r4, r5, r6, r7, pc}
			return -USB_ERR_REDO;
    5220:	f06f 0013 	mvn.w	r0, #19
    5224:	bdf0      	pop	{r4, r5, r6, r7, pc}
			return -USB_ERR_FUNC;
    5226:	f06f 0012 	mvn.w	r0, #18
    522a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	uint8_t                        ep_type = attr & USB_EP_XTYPE_MASK;
    522c:	f001 0103 	and.w	r1, r1, #3
	return &dev_inst.ep[ep_index];
    5230:	2400      	movs	r4, #0
	const struct _usb_ep_cfg_item *pcfg    = &_usb_ep_cfgs[epn];
    5232:	4623      	mov	r3, r4
	if (ept->ep != 0xFF) {
    5234:	eb04 0684 	add.w	r6, r4, r4, lsl #2
    5238:	4f17      	ldr	r7, [pc, #92]	; (5298 <_usb_d_dev_ep_init+0x114>)
    523a:	eb07 0686 	add.w	r6, r7, r6, lsl #2
    523e:	f896 6086 	ldrb.w	r6, [r6, #134]	; 0x86
    5242:	2eff      	cmp	r6, #255	; 0xff
    5244:	d1e9      	bne.n	521a <_usb_d_dev_ep_init+0x96>
	if (ep_type == USB_EP_XTYPE_CTRL) {
    5246:	2900      	cmp	r1, #0
    5248:	d1af      	bne.n	51aa <_usb_d_dev_ep_init+0x26>
	uint8_t ep_index = (epn == 0) ? 0 : (dir ? (epn + CONF_USB_D_MAX_EP_N) : epn);
    524a:	b125      	cbz	r5, 5256 <_usb_d_dev_ep_init+0xd2>
    524c:	f1be 0f00 	cmp.w	lr, #0
    5250:	bfa4      	itt	ge
    5252:	3502      	addge	r5, #2
    5254:	b2ed      	uxtbge	r5, r5
		if (ept_in->ep != 0xFF) {
    5256:	eb05 0585 	add.w	r5, r5, r5, lsl #2
    525a:	4e0f      	ldr	r6, [pc, #60]	; (5298 <_usb_d_dev_ep_init+0x114>)
    525c:	eb06 0585 	add.w	r5, r6, r5, lsl #2
    5260:	f895 5086 	ldrb.w	r5, [r5, #134]	; 0x86
    5264:	2dff      	cmp	r5, #255	; 0xff
    5266:	d1db      	bne.n	5220 <_usb_d_dev_ep_init+0x9c>
		if (pcfg->cache == NULL) {
    5268:	eb03 0543 	add.w	r5, r3, r3, lsl #1
    526c:	4e09      	ldr	r6, [pc, #36]	; (5294 <_usb_d_dev_ep_init+0x110>)
    526e:	f856 5025 	ldr.w	r5, [r6, r5, lsl #2]
    5272:	2d00      	cmp	r5, #0
    5274:	d0d7      	beq.n	5226 <_usb_d_dev_ep_init+0xa2>
	if ((dir ? pcfg->i_cache : pcfg->cache) && ((dir ? pcfg->i_size : pcfg->size) < max_pkt_siz)) {
    5276:	f1be 0f00 	cmp.w	lr, #0
    527a:	dbb5      	blt.n	51e8 <_usb_d_dev_ep_init+0x64>
    527c:	eb03 0543 	add.w	r5, r3, r3, lsl #1
    5280:	4e04      	ldr	r6, [pc, #16]	; (5294 <_usb_d_dev_ep_init+0x110>)
    5282:	eb06 0585 	add.w	r5, r6, r5, lsl #2
    5286:	892d      	ldrh	r5, [r5, #8]
    5288:	4295      	cmp	r5, r2
    528a:	da98      	bge.n	51be <_usb_d_dev_ep_init+0x3a>
		return -USB_ERR_FUNC;
    528c:	f06f 0012 	mvn.w	r0, #18
    5290:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5292:	bf00      	nop
    5294:	0000997c 	.word	0x0000997c
    5298:	200002d0 	.word	0x200002d0

0000529c <_usb_d_dev_ep_deinit>:
{
    529c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    529e:	b247      	sxtb	r7, r0
	uint8_t ep_index = (epn == 0) ? 0 : (dir ? (epn + CONF_USB_D_MAX_EP_N) : epn);
    52a0:	f010 060f 	ands.w	r6, r0, #15
    52a4:	d00e      	beq.n	52c4 <_usb_d_dev_ep_deinit+0x28>
    52a6:	2f00      	cmp	r7, #0
    52a8:	bfb4      	ite	lt
    52aa:	1cb3      	addlt	r3, r6, #2
    52ac:	4633      	movge	r3, r6
	if (epn > CONF_USB_D_MAX_EP_N || !_usb_d_dev_ep_is_used(ept)) {
    52ae:	2e02      	cmp	r6, #2
    52b0:	d900      	bls.n	52b4 <_usb_d_dev_ep_deinit+0x18>
    52b2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return &dev_inst.ep[ep_index];
    52b4:	461d      	mov	r5, r3
    52b6:	3301      	adds	r3, #1
    52b8:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    52bc:	4a24      	ldr	r2, [pc, #144]	; (5350 <_usb_d_dev_ep_deinit+0xb4>)
    52be:	eb02 0e83 	add.w	lr, r2, r3, lsl #2
    52c2:	e002      	b.n	52ca <_usb_d_dev_ep_deinit+0x2e>
    52c4:	f8df e094 	ldr.w	lr, [pc, #148]	; 535c <_usb_d_dev_ep_deinit+0xc0>
    52c8:	2500      	movs	r5, #0
	if (epn > CONF_USB_D_MAX_EP_N || !_usb_d_dev_ep_is_used(ept)) {
    52ca:	eb05 0385 	add.w	r3, r5, r5, lsl #2
    52ce:	4a21      	ldr	r2, [pc, #132]	; (5354 <_usb_d_dev_ep_deinit+0xb8>)
    52d0:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    52d4:	f893 2086 	ldrb.w	r2, [r3, #134]	; 0x86
    52d8:	2aff      	cmp	r2, #255	; 0xff
    52da:	d0ea      	beq.n	52b2 <_usb_d_dev_ep_deinit+0x16>
    52dc:	4604      	mov	r4, r0
	_usb_d_dev_trans_stop(ept, dir, USB_TRANS_RESET);
    52de:	2203      	movs	r2, #3
    52e0:	0ff9      	lsrs	r1, r7, #31
    52e2:	4670      	mov	r0, lr
    52e4:	4b1c      	ldr	r3, [pc, #112]	; (5358 <_usb_d_dev_ep_deinit+0xbc>)
    52e6:	4798      	blx	r3
	if (_usb_d_dev_ep_is_ctrl(ept)) {
    52e8:	eb05 0385 	add.w	r3, r5, r5, lsl #2
    52ec:	4a19      	ldr	r2, [pc, #100]	; (5354 <_usb_d_dev_ep_deinit+0xb8>)
    52ee:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    52f2:	f893 3087 	ldrb.w	r3, [r3, #135]	; 0x87
    52f6:	f003 0307 	and.w	r3, r3, #7
    52fa:	2b01      	cmp	r3, #1
    52fc:	d016      	beq.n	532c <_usb_d_dev_ep_deinit+0x90>
	} else if (USB_EP_GET_DIR(ep)) {
    52fe:	2f00      	cmp	r7, #0
    5300:	db1b      	blt.n	533a <_usb_d_dev_ep_deinit+0x9e>
    5302:	0160      	lsls	r0, r4, #5
    5304:	f100 4082 	add.w	r0, r0, #1090519040	; 0x41000000
		hw->DEVICE.DeviceEndpoint[ep].EPCFG.reg &= ~USB_DEVICE_EPCFG_EPTYPE0_Msk;
    5308:	f890 3100 	ldrb.w	r3, [r0, #256]	; 0x100
    530c:	f003 03f8 	and.w	r3, r3, #248	; 0xf8
    5310:	f880 3100 	strb.w	r3, [r0, #256]	; 0x100
	ept->flags.u8 = 0;
    5314:	4b0f      	ldr	r3, [pc, #60]	; (5354 <_usb_d_dev_ep_deinit+0xb8>)
    5316:	00aa      	lsls	r2, r5, #2
    5318:	1951      	adds	r1, r2, r5
    531a:	eb03 0181 	add.w	r1, r3, r1, lsl #2
    531e:	2000      	movs	r0, #0
    5320:	f881 0087 	strb.w	r0, [r1, #135]	; 0x87
	ept->ep       = 0xFF;
    5324:	22ff      	movs	r2, #255	; 0xff
    5326:	f881 2086 	strb.w	r2, [r1, #134]	; 0x86
    532a:	e7c2      	b.n	52b2 <_usb_d_dev_ep_deinit+0x16>
		hw->DEVICE.DeviceEndpoint[ep].EPCFG.reg = 0;
    532c:	0160      	lsls	r0, r4, #5
    532e:	f100 4082 	add.w	r0, r0, #1090519040	; 0x41000000
    5332:	2300      	movs	r3, #0
    5334:	f880 3100 	strb.w	r3, [r0, #256]	; 0x100
    5338:	e7ec      	b.n	5314 <_usb_d_dev_ep_deinit+0x78>
    533a:	0176      	lsls	r6, r6, #5
    533c:	f106 4682 	add.w	r6, r6, #1090519040	; 0x41000000
		hw->DEVICE.DeviceEndpoint[USB_EP_GET_N(ep)].EPCFG.reg &= ~USB_DEVICE_EPCFG_EPTYPE1_Msk;
    5340:	f896 3100 	ldrb.w	r3, [r6, #256]	; 0x100
    5344:	f003 038f 	and.w	r3, r3, #143	; 0x8f
    5348:	f886 3100 	strb.w	r3, [r6, #256]	; 0x100
    534c:	e7e2      	b.n	5314 <_usb_d_dev_ep_deinit+0x78>
    534e:	bf00      	nop
    5350:	20000330 	.word	0x20000330
    5354:	200002d0 	.word	0x200002d0
    5358:	00004899 	.word	0x00004899
    535c:	20000344 	.word	0x20000344

00005360 <_usb_d_dev_ep_enable>:
{
    5360:	b4f0      	push	{r4, r5, r6, r7}
    5362:	b246      	sxtb	r6, r0
	uint8_t ep_index = (epn == 0) ? 0 : (dir ? (epn + CONF_USB_D_MAX_EP_N) : epn);
    5364:	f010 000f 	ands.w	r0, r0, #15
    5368:	f000 80a7 	beq.w	54ba <_usb_d_dev_ep_enable+0x15a>
    536c:	2e00      	cmp	r6, #0
    536e:	bfb4      	ite	lt
    5370:	1c83      	addlt	r3, r0, #2
    5372:	4603      	movge	r3, r0
	USB_CRITICAL_SECTION_LEAVE();
}

static inline hri_usbendpoint_epcfg_reg_t hri_usbendpoint_read_EPCFG_reg(const void *const hw, uint8_t submodule_index)
{
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg;
    5374:	4605      	mov	r5, r0
    5376:	0142      	lsls	r2, r0, #5
    5378:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
    537c:	f892 4100 	ldrb.w	r4, [r2, #256]	; 0x100
    5380:	b2e4      	uxtb	r4, r4
	if (epn > CONF_USB_D_MAX_EP_N || !_usb_d_dev_ep_is_used(ept)) {
    5382:	2802      	cmp	r0, #2
    5384:	f240 80a0 	bls.w	54c8 <_usb_d_dev_ep_enable+0x168>
		return -USB_ERR_PARAM;
    5388:	f06f 0011 	mvn.w	r0, #17
    538c:	e07d      	b.n	548a <_usb_d_dev_ep_enable+0x12a>
		if (epcfg & (USB_DEVICE_EPCFG_EPTYPE1_Msk | USB_DEVICE_EPCFG_EPTYPE0_Msk)) {
    538e:	f014 0f77 	tst.w	r4, #119	; 0x77
    5392:	f040 8089 	bne.w	54a8 <_usb_d_dev_ep_enable+0x148>
    5396:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg = data;
    539a:	2111      	movs	r1, #17
    539c:	f882 1100 	strb.w	r1, [r2, #256]	; 0x100
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    53a0:	4c9b      	ldr	r4, [pc, #620]	; (5610 <_usb_d_dev_ep_enable+0x2b0>)
    53a2:	eb04 0187 	add.w	r1, r4, r7, lsl #2
    53a6:	f8b1 1084 	ldrh.w	r1, [r1, #132]	; 0x84
    53aa:	4c9a      	ldr	r4, [pc, #616]	; (5614 <_usb_d_dev_ep_enable+0x2b4>)
    53ac:	ea04 3481 	and.w	r4, r4, r1, lsl #14
	        : ((n > 256) ? 6 : ((n > 128) ? 5 : ((n > 64) ? 4 : ((n > 32) ? 3 : ((n > 16) ? 2 : ((n > 8) ? 1 : 0)))))));
    53b0:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
    53b4:	f200 80cd 	bhi.w	5552 <_usb_d_dev_ep_enable+0x1f2>
    53b8:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
    53bc:	f200 8112 	bhi.w	55e4 <_usb_d_dev_ep_enable+0x284>
    53c0:	2980      	cmp	r1, #128	; 0x80
    53c2:	f200 8101 	bhi.w	55c8 <_usb_d_dev_ep_enable+0x268>
    53c6:	2940      	cmp	r1, #64	; 0x40
    53c8:	f200 8113 	bhi.w	55f2 <_usb_d_dev_ep_enable+0x292>
    53cc:	2920      	cmp	r1, #32
    53ce:	f200 8102 	bhi.w	55d6 <_usb_d_dev_ep_enable+0x276>
    53d2:	2910      	cmp	r1, #16
    53d4:	f200 8114 	bhi.w	5600 <_usb_d_dev_ep_enable+0x2a0>
    53d8:	2908      	cmp	r1, #8
    53da:	bf94      	ite	ls
    53dc:	2600      	movls	r6, #0
    53de:	2601      	movhi	r6, #1
		                      | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    53e0:	ea44 7406 	orr.w	r4, r4, r6, lsl #28
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    53e4:	6044      	str	r4, [r0, #4]
		    = USB_DEVICE_PCKSIZE_BYTE_COUNT(ept->size) | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    53e6:	f3c1 010d 	ubfx	r1, r1, #0, #14
    53ea:	e0b8      	b.n	555e <_usb_d_dev_ep_enable+0x1fe>
		if (epcfg & USB_DEVICE_EPCFG_EPTYPE1_Msk) {
    53ec:	f014 0f70 	tst.w	r4, #112	; 0x70
    53f0:	d15d      	bne.n	54ae <_usb_d_dev_ep_enable+0x14e>
		epcfg |= USB_DEVICE_EPCFG_EPTYPE1(ept->flags.bits.eptype);
    53f2:	4e87      	ldr	r6, [pc, #540]	; (5610 <_usb_d_dev_ep_enable+0x2b0>)
    53f4:	009f      	lsls	r7, r3, #2
    53f6:	18f9      	adds	r1, r7, r3
    53f8:	eb06 0181 	add.w	r1, r6, r1, lsl #2
    53fc:	f891 1087 	ldrb.w	r1, [r1, #135]	; 0x87
    5400:	0109      	lsls	r1, r1, #4
    5402:	f001 0170 	and.w	r1, r1, #112	; 0x70
    5406:	430c      	orrs	r4, r1
    5408:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
    540c:	f882 4100 	strb.w	r4, [r2, #256]	; 0x100
		    = USB_DEVICE_PCKSIZE_BYTE_COUNT(ept->size) | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    5410:	443b      	add	r3, r7
    5412:	eb06 0683 	add.w	r6, r6, r3, lsl #2
    5416:	f8b6 3084 	ldrh.w	r3, [r6, #132]	; 0x84
    541a:	f3c3 010d 	ubfx	r1, r3, #0, #14
	        : ((n > 256) ? 6 : ((n > 128) ? 5 : ((n > 64) ? 4 : ((n > 32) ? 3 : ((n > 16) ? 2 : ((n > 8) ? 1 : 0)))))));
    541e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    5422:	d80f      	bhi.n	5444 <_usb_d_dev_ep_enable+0xe4>
    5424:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
    5428:	d819      	bhi.n	545e <_usb_d_dev_ep_enable+0xfe>
    542a:	2b80      	cmp	r3, #128	; 0x80
    542c:	d819      	bhi.n	5462 <_usb_d_dev_ep_enable+0x102>
    542e:	2b40      	cmp	r3, #64	; 0x40
    5430:	d819      	bhi.n	5466 <_usb_d_dev_ep_enable+0x106>
    5432:	2b20      	cmp	r3, #32
    5434:	d819      	bhi.n	546a <_usb_d_dev_ep_enable+0x10a>
    5436:	2b10      	cmp	r3, #16
    5438:	d819      	bhi.n	546e <_usb_d_dev_ep_enable+0x10e>
    543a:	2b08      	cmp	r3, #8
    543c:	bf94      	ite	ls
    543e:	2300      	movls	r3, #0
    5440:	2301      	movhi	r3, #1
    5442:	e000      	b.n	5446 <_usb_d_dev_ep_enable+0xe6>
    5444:	2307      	movs	r3, #7
		    = USB_DEVICE_PCKSIZE_BYTE_COUNT(ept->size) | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    5446:	ea41 7303 	orr.w	r3, r1, r3, lsl #28
    544a:	6143      	str	r3, [r0, #20]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    544c:	2380      	movs	r3, #128	; 0x80
    544e:	f882 3104 	strb.w	r3, [r2, #260]	; 0x104
	bank->STATUS_BK.reg     = 0;
    5452:	4b6f      	ldr	r3, [pc, #444]	; (5610 <_usb_d_dev_ep_enable+0x2b0>)
    5454:	eb03 1545 	add.w	r5, r3, r5, lsl #5
    5458:	2000      	movs	r0, #0
    545a:	76a8      	strb	r0, [r5, #26]
    545c:	e015      	b.n	548a <_usb_d_dev_ep_enable+0x12a>
	        : ((n > 256) ? 6 : ((n > 128) ? 5 : ((n > 64) ? 4 : ((n > 32) ? 3 : ((n > 16) ? 2 : ((n > 8) ? 1 : 0)))))));
    545e:	2306      	movs	r3, #6
    5460:	e7f1      	b.n	5446 <_usb_d_dev_ep_enable+0xe6>
    5462:	2305      	movs	r3, #5
    5464:	e7ef      	b.n	5446 <_usb_d_dev_ep_enable+0xe6>
    5466:	2304      	movs	r3, #4
    5468:	e7ed      	b.n	5446 <_usb_d_dev_ep_enable+0xe6>
    546a:	2303      	movs	r3, #3
    546c:	e7eb      	b.n	5446 <_usb_d_dev_ep_enable+0xe6>
    546e:	2302      	movs	r3, #2
    5470:	e7e9      	b.n	5446 <_usb_d_dev_ep_enable+0xe6>
    5472:	2107      	movs	r1, #7
		                      | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    5474:	ea43 7301 	orr.w	r3, r3, r1, lsl #28
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    5478:	6043      	str	r3, [r0, #4]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    547a:	2340      	movs	r3, #64	; 0x40
    547c:	f882 3105 	strb.w	r3, [r2, #261]	; 0x105
	bank->STATUS_BK.reg     = 0;
    5480:	4b63      	ldr	r3, [pc, #396]	; (5610 <_usb_d_dev_ep_enable+0x2b0>)
    5482:	eb03 1545 	add.w	r5, r3, r5, lsl #5
    5486:	2000      	movs	r0, #0
    5488:	72a8      	strb	r0, [r5, #10]
}
    548a:	bcf0      	pop	{r4, r5, r6, r7}
    548c:	4770      	bx	lr
	        : ((n > 256) ? 6 : ((n > 128) ? 5 : ((n > 64) ? 4 : ((n > 32) ? 3 : ((n > 16) ? 2 : ((n > 8) ? 1 : 0)))))));
    548e:	2106      	movs	r1, #6
    5490:	e7f0      	b.n	5474 <_usb_d_dev_ep_enable+0x114>
    5492:	2105      	movs	r1, #5
    5494:	e7ee      	b.n	5474 <_usb_d_dev_ep_enable+0x114>
    5496:	2104      	movs	r1, #4
    5498:	e7ec      	b.n	5474 <_usb_d_dev_ep_enable+0x114>
    549a:	2103      	movs	r1, #3
    549c:	e7ea      	b.n	5474 <_usb_d_dev_ep_enable+0x114>
    549e:	2102      	movs	r1, #2
    54a0:	e7e8      	b.n	5474 <_usb_d_dev_ep_enable+0x114>
		return -USB_ERR_PARAM;
    54a2:	f06f 0011 	mvn.w	r0, #17
    54a6:	e7f0      	b.n	548a <_usb_d_dev_ep_enable+0x12a>
			return -USB_ERR_REDO;
    54a8:	f06f 0013 	mvn.w	r0, #19
    54ac:	e7ed      	b.n	548a <_usb_d_dev_ep_enable+0x12a>
			return -USB_ERR_REDO;
    54ae:	f06f 0013 	mvn.w	r0, #19
    54b2:	e7ea      	b.n	548a <_usb_d_dev_ep_enable+0x12a>
			return -USB_ERR_REDO;
    54b4:	f06f 0013 	mvn.w	r0, #19
    54b8:	e7e7      	b.n	548a <_usb_d_dev_ep_enable+0x12a>
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg;
    54ba:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    54be:	f893 4100 	ldrb.w	r4, [r3, #256]	; 0x100
    54c2:	b2e4      	uxtb	r4, r4
    54c4:	2500      	movs	r5, #0
	return &dev_inst.ep[ep_index];
    54c6:	462b      	mov	r3, r5
	if (epn > CONF_USB_D_MAX_EP_N || !_usb_d_dev_ep_is_used(ept)) {
    54c8:	eb03 0283 	add.w	r2, r3, r3, lsl #2
    54cc:	4950      	ldr	r1, [pc, #320]	; (5610 <_usb_d_dev_ep_enable+0x2b0>)
    54ce:	eb01 0282 	add.w	r2, r1, r2, lsl #2
    54d2:	f892 2086 	ldrb.w	r2, [r2, #134]	; 0x86
    54d6:	2aff      	cmp	r2, #255	; 0xff
    54d8:	d0e3      	beq.n	54a2 <_usb_d_dev_ep_enable+0x142>
    54da:	016a      	lsls	r2, r5, #5
	bank = prvt_inst.desc_table[epn].DeviceDescBank;
    54dc:	1888      	adds	r0, r1, r2
	if (ept->flags.bits.eptype == USB_D_EPTYPE_CTRL) {
    54de:	eb03 0783 	add.w	r7, r3, r3, lsl #2
    54e2:	eb01 0187 	add.w	r1, r1, r7, lsl #2
    54e6:	f891 1087 	ldrb.w	r1, [r1, #135]	; 0x87
    54ea:	f001 0107 	and.w	r1, r1, #7
    54ee:	2901      	cmp	r1, #1
    54f0:	f43f af4d 	beq.w	538e <_usb_d_dev_ep_enable+0x2e>
	} else if (dir) {
    54f4:	2e00      	cmp	r6, #0
    54f6:	f6ff af79 	blt.w	53ec <_usb_d_dev_ep_enable+0x8c>
		if (epcfg & USB_DEVICE_EPCFG_EPTYPE0_Msk) {
    54fa:	f014 0f07 	tst.w	r4, #7
    54fe:	d1d9      	bne.n	54b4 <_usb_d_dev_ep_enable+0x154>
		epcfg |= USB_DEVICE_EPCFG_EPTYPE0(ept->flags.bits.eptype);
    5500:	4e43      	ldr	r6, [pc, #268]	; (5610 <_usb_d_dev_ep_enable+0x2b0>)
    5502:	009f      	lsls	r7, r3, #2
    5504:	18f9      	adds	r1, r7, r3
    5506:	eb06 0181 	add.w	r1, r6, r1, lsl #2
    550a:	f891 1087 	ldrb.w	r1, [r1, #135]	; 0x87
    550e:	f001 0107 	and.w	r1, r1, #7
    5512:	430c      	orrs	r4, r1
    5514:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg = data;
    5518:	f882 4100 	strb.w	r4, [r2, #256]	; 0x100
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    551c:	443b      	add	r3, r7
    551e:	eb06 0683 	add.w	r6, r6, r3, lsl #2
    5522:	f8b6 1084 	ldrh.w	r1, [r6, #132]	; 0x84
    5526:	4b3b      	ldr	r3, [pc, #236]	; (5614 <_usb_d_dev_ep_enable+0x2b4>)
    5528:	ea03 3381 	and.w	r3, r3, r1, lsl #14
	        : ((n > 256) ? 6 : ((n > 128) ? 5 : ((n > 64) ? 4 : ((n > 32) ? 3 : ((n > 16) ? 2 : ((n > 8) ? 1 : 0)))))));
    552c:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
    5530:	d89f      	bhi.n	5472 <_usb_d_dev_ep_enable+0x112>
    5532:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
    5536:	d8aa      	bhi.n	548e <_usb_d_dev_ep_enable+0x12e>
    5538:	2980      	cmp	r1, #128	; 0x80
    553a:	d8aa      	bhi.n	5492 <_usb_d_dev_ep_enable+0x132>
    553c:	2940      	cmp	r1, #64	; 0x40
    553e:	d8aa      	bhi.n	5496 <_usb_d_dev_ep_enable+0x136>
    5540:	2920      	cmp	r1, #32
    5542:	d8aa      	bhi.n	549a <_usb_d_dev_ep_enable+0x13a>
    5544:	2910      	cmp	r1, #16
    5546:	d8aa      	bhi.n	549e <_usb_d_dev_ep_enable+0x13e>
    5548:	2908      	cmp	r1, #8
    554a:	bf94      	ite	ls
    554c:	2100      	movls	r1, #0
    554e:	2101      	movhi	r1, #1
    5550:	e790      	b.n	5474 <_usb_d_dev_ep_enable+0x114>
		                      | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    5552:	f044 44e0 	orr.w	r4, r4, #1879048192	; 0x70000000
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    5556:	6044      	str	r4, [r0, #4]
		    = USB_DEVICE_PCKSIZE_BYTE_COUNT(ept->size) | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    5558:	f3c1 010d 	ubfx	r1, r1, #0, #14
	        : ((n > 256) ? 6 : ((n > 128) ? 5 : ((n > 64) ? 4 : ((n > 32) ? 3 : ((n > 16) ? 2 : ((n > 8) ? 1 : 0)))))));
    555c:	2607      	movs	r6, #7
		    = USB_DEVICE_PCKSIZE_BYTE_COUNT(ept->size) | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    555e:	ea41 7106 	orr.w	r1, r1, r6, lsl #28
    5562:	6141      	str	r1, [r0, #20]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    5564:	2640      	movs	r6, #64	; 0x40
    5566:	f882 6105 	strb.w	r6, [r2, #261]	; 0x105
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    556a:	2180      	movs	r1, #128	; 0x80
    556c:	f882 1104 	strb.w	r1, [r2, #260]	; 0x104
	bank->STATUS_BK.reg     = 0;
    5570:	4f27      	ldr	r7, [pc, #156]	; (5610 <_usb_d_dev_ep_enable+0x2b0>)
    5572:	eb07 1545 	add.w	r5, r7, r5, lsl #5
    5576:	2000      	movs	r0, #0
    5578:	72a8      	strb	r0, [r5, #10]
    557a:	76a8      	strb	r0, [r5, #26]
	uint8_t epn = USB_EP_GET_N(ept->ep);
    557c:	009c      	lsls	r4, r3, #2
    557e:	18e1      	adds	r1, r4, r3
    5580:	eb07 0181 	add.w	r1, r7, r1, lsl #2
    5584:	f891 2086 	ldrb.w	r2, [r1, #134]	; 0x86
    5588:	f002 020f 	and.w	r2, r2, #15
	_usbd_ep_set_buf(epn, 0, (uint32_t)ept->cache);
    558c:	f8d1 5080 	ldr.w	r5, [r1, #128]	; 0x80
	bank->ADDR.reg          = addr;
    5590:	0152      	lsls	r2, r2, #5
    5592:	18b9      	adds	r1, r7, r2
    5594:	50bd      	str	r5, [r7, r2]
	_usbd_ep_set_out_trans(epn, 0, ept->size, 0);
    5596:	4423      	add	r3, r4
    5598:	eb07 0383 	add.w	r3, r7, r3, lsl #2
	bank->PCKSIZE.bit.MULTI_PACKET_SIZE = size;
    559c:	f8b3 4084 	ldrh.w	r4, [r3, #132]	; 0x84
    55a0:	684b      	ldr	r3, [r1, #4]
    55a2:	f364 339b 	bfi	r3, r4, #14, #14
    55a6:	604b      	str	r3, [r1, #4]
	bank->PCKSIZE.bit.BYTE_COUNT = count;
    55a8:	684b      	ldr	r3, [r1, #4]
    55aa:	f360 030d 	bfi	r3, r0, #0, #14
    55ae:	604b      	str	r3, [r1, #4]
    55b0:	f102 4382 	add.w	r3, r2, #1090519040	; 0x41000000
    55b4:	21b0      	movs	r1, #176	; 0xb0
    55b6:	f883 1104 	strb.w	r1, [r3, #260]	; 0x104
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    55ba:	f883 6105 	strb.w	r6, [r3, #261]	; 0x105
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENSET.reg = mask;
    55be:	461a      	mov	r2, r3
    55c0:	2310      	movs	r3, #16
    55c2:	f882 3109 	strb.w	r3, [r2, #265]	; 0x109
    55c6:	e760      	b.n	548a <_usb_d_dev_ep_enable+0x12a>
		                      | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    55c8:	f044 44a0 	orr.w	r4, r4, #1342177280	; 0x50000000
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    55cc:	6044      	str	r4, [r0, #4]
		    = USB_DEVICE_PCKSIZE_BYTE_COUNT(ept->size) | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    55ce:	f3c1 010d 	ubfx	r1, r1, #0, #14
	        : ((n > 256) ? 6 : ((n > 128) ? 5 : ((n > 64) ? 4 : ((n > 32) ? 3 : ((n > 16) ? 2 : ((n > 8) ? 1 : 0)))))));
    55d2:	2605      	movs	r6, #5
    55d4:	e7c3      	b.n	555e <_usb_d_dev_ep_enable+0x1fe>
		                      | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    55d6:	f044 5440 	orr.w	r4, r4, #805306368	; 0x30000000
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    55da:	6044      	str	r4, [r0, #4]
		    = USB_DEVICE_PCKSIZE_BYTE_COUNT(ept->size) | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    55dc:	f3c1 010d 	ubfx	r1, r1, #0, #14
	        : ((n > 256) ? 6 : ((n > 128) ? 5 : ((n > 64) ? 4 : ((n > 32) ? 3 : ((n > 16) ? 2 : ((n > 8) ? 1 : 0)))))));
    55e0:	2603      	movs	r6, #3
    55e2:	e7bc      	b.n	555e <_usb_d_dev_ep_enable+0x1fe>
		                      | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    55e4:	f044 44c0 	orr.w	r4, r4, #1610612736	; 0x60000000
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    55e8:	6044      	str	r4, [r0, #4]
		    = USB_DEVICE_PCKSIZE_BYTE_COUNT(ept->size) | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    55ea:	f3c1 010d 	ubfx	r1, r1, #0, #14
	        : ((n > 256) ? 6 : ((n > 128) ? 5 : ((n > 64) ? 4 : ((n > 32) ? 3 : ((n > 16) ? 2 : ((n > 8) ? 1 : 0)))))));
    55ee:	2606      	movs	r6, #6
    55f0:	e7b5      	b.n	555e <_usb_d_dev_ep_enable+0x1fe>
		                      | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    55f2:	f044 4480 	orr.w	r4, r4, #1073741824	; 0x40000000
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    55f6:	6044      	str	r4, [r0, #4]
		    = USB_DEVICE_PCKSIZE_BYTE_COUNT(ept->size) | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    55f8:	f3c1 010d 	ubfx	r1, r1, #0, #14
	        : ((n > 256) ? 6 : ((n > 128) ? 5 : ((n > 64) ? 4 : ((n > 32) ? 3 : ((n > 16) ? 2 : ((n > 8) ? 1 : 0)))))));
    55fc:	2604      	movs	r6, #4
    55fe:	e7ae      	b.n	555e <_usb_d_dev_ep_enable+0x1fe>
		                      | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    5600:	f044 5400 	orr.w	r4, r4, #536870912	; 0x20000000
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    5604:	6044      	str	r4, [r0, #4]
		    = USB_DEVICE_PCKSIZE_BYTE_COUNT(ept->size) | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    5606:	f3c1 010d 	ubfx	r1, r1, #0, #14
	        : ((n > 256) ? 6 : ((n > 128) ? 5 : ((n > 64) ? 4 : ((n > 32) ? 3 : ((n > 16) ? 2 : ((n > 8) ? 1 : 0)))))));
    560a:	2602      	movs	r6, #2
    560c:	e7a7      	b.n	555e <_usb_d_dev_ep_enable+0x1fe>
    560e:	bf00      	nop
    5610:	200002d0 	.word	0x200002d0
    5614:	0fffc000 	.word	0x0fffc000

00005618 <_usb_d_dev_ep_stall>:
{
    5618:	b470      	push	{r4, r5, r6}
    561a:	b243      	sxtb	r3, r0
	bool                  dir = USB_EP_GET_DIR(ep);
    561c:	0fdc      	lsrs	r4, r3, #31
	uint8_t ep_index = (epn == 0) ? 0 : (dir ? (epn + CONF_USB_D_MAX_EP_N) : epn);
    561e:	f010 000f 	ands.w	r0, r0, #15
    5622:	d008      	beq.n	5636 <_usb_d_dev_ep_stall+0x1e>
    5624:	2b00      	cmp	r3, #0
    5626:	bfb4      	ite	lt
    5628:	1c83      	addlt	r3, r0, #2
    562a:	4603      	movge	r3, r0
	if (epn > CONF_USB_D_MAX_EP_N) {
    562c:	2802      	cmp	r0, #2
    562e:	d903      	bls.n	5638 <_usb_d_dev_ep_stall+0x20>
		return -USB_ERR_PARAM;
    5630:	f06f 0011 	mvn.w	r0, #17
    5634:	e018      	b.n	5668 <_usb_d_dev_ep_stall+0x50>
	return &dev_inst.ep[ep_index];
    5636:	2300      	movs	r3, #0
	if (USB_EP_STALL_SET == ctrl) {
    5638:	2901      	cmp	r1, #1
    563a:	d017      	beq.n	566c <_usb_d_dev_ep_stall+0x54>
	} else if (USB_EP_STALL_CLR == ctrl) {
    563c:	2900      	cmp	r1, #0
    563e:	d03a      	beq.n	56b6 <_usb_d_dev_ep_stall+0x9e>
	uint8_t epn = USB_EP_GET_N(ept->ep);
    5640:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    5644:	4a45      	ldr	r2, [pc, #276]	; (575c <_usb_d_dev_ep_stall+0x144>)
    5646:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    564a:	f893 3086 	ldrb.w	r3, [r3, #134]	; 0x86
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUS.reg;
    564e:	f003 030f 	and.w	r3, r3, #15
    5652:	015b      	lsls	r3, r3, #5
    5654:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    5658:	f893 2106 	ldrb.w	r2, [r3, #262]	; 0x106
	return (hri_usbendpoint_read_EPSTATUS_reg(hw, epn) & (USB_DEVICE_EPSTATUS_STALLRQ0 << bank_n));
    565c:	2310      	movs	r3, #16
    565e:	40a3      	lsls	r3, r4
    5660:	421a      	tst	r2, r3
    5662:	bf14      	ite	ne
    5664:	2001      	movne	r0, #1
    5666:	2000      	moveq	r0, #0
}
    5668:	bc70      	pop	{r4, r5, r6}
    566a:	4770      	bx	lr
		hri_usbendpoint_set_EPSTATUS_reg(USB, epn, (USB_DEVICE_EPSTATUS_STALLRQ0 << bank_n));
    566c:	2510      	movs	r5, #16
    566e:	40a5      	lsls	r5, r4
    5670:	b2ed      	uxtb	r5, r5
	uint8_t epn = USB_EP_GET_N(ept->ep);
    5672:	493a      	ldr	r1, [pc, #232]	; (575c <_usb_d_dev_ep_stall+0x144>)
    5674:	009e      	lsls	r6, r3, #2
    5676:	18f2      	adds	r2, r6, r3
    5678:	eb01 0282 	add.w	r2, r1, r2, lsl #2
    567c:	f892 2086 	ldrb.w	r2, [r2, #134]	; 0x86
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    5680:	f002 020f 	and.w	r2, r2, #15
    5684:	0150      	lsls	r0, r2, #5
    5686:	f100 4082 	add.w	r0, r0, #1090519040	; 0x41000000
    568a:	f880 5105 	strb.w	r5, [r0, #261]	; 0x105
	_usbd_ep_int_en(epn, USB_DEVICE_EPINTFLAG_STALL0 << dir);
    568e:	2020      	movs	r0, #32
    5690:	fa00 f404 	lsl.w	r4, r0, r4
	hri_usbendpoint_set_EPINTEN_reg(USB, epn, flags);
    5694:	b2e4      	uxtb	r4, r4
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENSET.reg = mask;
    5696:	0152      	lsls	r2, r2, #5
    5698:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
    569c:	f882 4109 	strb.w	r4, [r2, #265]	; 0x109
	ept->flags.bits.is_stalled = 1;
    56a0:	4433      	add	r3, r6
    56a2:	eb01 0383 	add.w	r3, r1, r3, lsl #2
    56a6:	f893 2087 	ldrb.w	r2, [r3, #135]	; 0x87
    56aa:	f042 0208 	orr.w	r2, r2, #8
    56ae:	f883 2087 	strb.w	r2, [r3, #135]	; 0x87
		rc = _usb_d_dev_ep_stall_set(ept, dir);
    56b2:	2000      	movs	r0, #0
    56b4:	e7d8      	b.n	5668 <_usb_d_dev_ep_stall+0x50>
	uint8_t epn        = USB_EP_GET_N(ept->ep);
    56b6:	eb03 0283 	add.w	r2, r3, r3, lsl #2
    56ba:	4928      	ldr	r1, [pc, #160]	; (575c <_usb_d_dev_ep_stall+0x144>)
    56bc:	eb01 0282 	add.w	r2, r1, r2, lsl #2
    56c0:	f892 2086 	ldrb.w	r2, [r2, #134]	; 0x86
    56c4:	f002 020f 	and.w	r2, r2, #15
    56c8:	0151      	lsls	r1, r2, #5
    56ca:	f101 4182 	add.w	r1, r1, #1090519040	; 0x41000000
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUS.reg;
    56ce:	f891 5106 	ldrb.w	r5, [r1, #262]	; 0x106
	return (hri_usbendpoint_read_EPSTATUS_reg(hw, epn) & (USB_DEVICE_EPSTATUS_STALLRQ0 << bank_n));
    56d2:	2010      	movs	r0, #16
    56d4:	40a0      	lsls	r0, r4
	if (!is_stalled) {
    56d6:	4205      	tst	r5, r0
    56d8:	d03c      	beq.n	5754 <_usb_d_dev_ep_stall+0x13c>
		hri_usbendpoint_clear_EPSTATUS_reg(USB, epn, (USB_DEVICE_EPSTATUS_STALLRQ0 << bank_n));
    56da:	b2c0      	uxtb	r0, r0
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    56dc:	f881 0104 	strb.w	r0, [r1, #260]	; 0x104
	_usbd_ep_int_dis(epn, USB_DEVICE_EPINTFLAG_STALL0 << dir);
    56e0:	2020      	movs	r0, #32
    56e2:	40a0      	lsls	r0, r4
	hri_usbendpoint_clear_EPINTEN_reg(USB, epn, flags);
    56e4:	b2c5      	uxtb	r5, r0
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    56e6:	f881 5108 	strb.w	r5, [r1, #264]	; 0x108
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg;
    56ea:	f891 2107 	ldrb.w	r2, [r1, #263]	; 0x107
	if (_usbd_ep_is_stall_sent(epn, dir)) {
    56ee:	4202      	tst	r2, r0
    56f0:	d007      	beq.n	5702 <_usb_d_dev_ep_stall+0xea>
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    56f2:	f881 5107 	strb.w	r5, [r1, #263]	; 0x107
		hri_usbendpoint_clear_EPSTATUS_reg(USB, epn, (USB_DEVICE_EPSTATUS_DTGLOUT << bank_n));
    56f6:	2201      	movs	r2, #1
    56f8:	fa02 f404 	lsl.w	r4, r2, r4
    56fc:	b2e4      	uxtb	r4, r4
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    56fe:	f881 4104 	strb.w	r4, [r1, #260]	; 0x104
	if (_usb_d_dev_ep_is_ctrl(ept)) {
    5702:	eb03 0283 	add.w	r2, r3, r3, lsl #2
    5706:	4815      	ldr	r0, [pc, #84]	; (575c <_usb_d_dev_ep_stall+0x144>)
    5708:	eb00 0282 	add.w	r2, r0, r2, lsl #2
    570c:	f892 2087 	ldrb.w	r2, [r2, #135]	; 0x87
    5710:	f002 0207 	and.w	r2, r2, #7
    5714:	2a01      	cmp	r2, #1
    5716:	d00c      	beq.n	5732 <_usb_d_dev_ep_stall+0x11a>
		ept->flags.bits.is_stalled = 0;
    5718:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    571c:	4a0f      	ldr	r2, [pc, #60]	; (575c <_usb_d_dev_ep_stall+0x144>)
    571e:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    5722:	f893 2087 	ldrb.w	r2, [r3, #135]	; 0x87
    5726:	f36f 02c3 	bfc	r2, #3, #1
    572a:	f883 2087 	strb.w	r2, [r3, #135]	; 0x87
		rc = _usb_d_dev_ep_stall_clr(ept, dir);
    572e:	2000      	movs	r0, #0
    5730:	e79a      	b.n	5668 <_usb_d_dev_ep_stall+0x50>
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUS.reg;
    5732:	f891 2106 	ldrb.w	r2, [r1, #262]	; 0x106
		if ((hri_usbendpoint_read_EPSTATUS_reg(USB, epn) & USB_DEVICE_EPSTATUS_STALLRQ_Msk) == 0) {
    5736:	f012 0f30 	tst.w	r2, #48	; 0x30
    573a:	d10d      	bne.n	5758 <_usb_d_dev_ep_stall+0x140>
			ept->flags.bits.is_stalled = 0;
    573c:	eb03 0283 	add.w	r2, r3, r3, lsl #2
    5740:	eb00 0382 	add.w	r3, r0, r2, lsl #2
    5744:	f893 2087 	ldrb.w	r2, [r3, #135]	; 0x87
    5748:	f36f 02c3 	bfc	r2, #3, #1
    574c:	f883 2087 	strb.w	r2, [r3, #135]	; 0x87
		rc = _usb_d_dev_ep_stall_clr(ept, dir);
    5750:	2000      	movs	r0, #0
    5752:	e789      	b.n	5668 <_usb_d_dev_ep_stall+0x50>
    5754:	2000      	movs	r0, #0
    5756:	e787      	b.n	5668 <_usb_d_dev_ep_stall+0x50>
    5758:	2000      	movs	r0, #0
    575a:	e785      	b.n	5668 <_usb_d_dev_ep_stall+0x50>
    575c:	200002d0 	.word	0x200002d0

00005760 <_usb_d_dev_ep_read_req>:

int32_t _usb_d_dev_ep_read_req(const uint8_t ep, uint8_t *req_buf)
{
    5760:	b430      	push	{r4, r5}
	uint8_t            epn   = USB_EP_GET_N(ep);
    5762:	f000 040f 	and.w	r4, r0, #15
    5766:	0163      	lsls	r3, r4, #5
	UsbDeviceDescBank *bank  = prvt_inst.desc_table[epn].DeviceDescBank;
    5768:	4a14      	ldr	r2, [pc, #80]	; (57bc <_usb_d_dev_ep_read_req+0x5c>)
    576a:	18d0      	adds	r0, r2, r3
	uint32_t           addr  = bank[0].ADDR.reg;
    576c:	58d5      	ldr	r5, [r2, r3]
	uint16_t           bytes = bank[0].PCKSIZE.bit.BYTE_COUNT;
    576e:	6840      	ldr	r0, [r0, #4]
    5770:	f3c0 000d 	ubfx	r0, r0, #0, #14

	if (epn > CONF_USB_D_MAX_EP_N || !req_buf) {
    5774:	2c02      	cmp	r4, #2
    5776:	d817      	bhi.n	57a8 <_usb_d_dev_ep_read_req+0x48>
    5778:	b1c9      	cbz	r1, 57ae <_usb_d_dev_ep_read_req+0x4e>
    577a:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg;
    577e:	f893 2100 	ldrb.w	r2, [r3, #256]	; 0x100
    5782:	b2d2      	uxtb	r2, r2
		return -USB_ERR_PARAM;
	}
	if (!_usbd_ep_is_ctrl(epn)) {
    5784:	2a11      	cmp	r2, #17
    5786:	d115      	bne.n	57b4 <_usb_d_dev_ep_read_req+0x54>
	tmp = ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg;
    5788:	f893 2107 	ldrb.w	r2, [r3, #263]	; 0x107
		return -USB_ERR_FUNC;
	}
	if (!_usbd_ep_is_setup(epn)) {
    578c:	f012 0f10 	tst.w	r2, #16
    5790:	d102      	bne.n	5798 <_usb_d_dev_ep_read_req+0x38>
		return ERR_NONE;
    5792:	2000      	movs	r0, #0
	}
	memcpy(req_buf, (void *)addr, 8);
	_usbd_ep_ack_setup(epn);

	return bytes;
}
    5794:	bc30      	pop	{r4, r5}
    5796:	4770      	bx	lr
	memcpy(req_buf, (void *)addr, 8);
    5798:	682c      	ldr	r4, [r5, #0]
    579a:	686a      	ldr	r2, [r5, #4]
    579c:	600c      	str	r4, [r1, #0]
    579e:	604a      	str	r2, [r1, #4]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    57a0:	2210      	movs	r2, #16
    57a2:	f883 2107 	strb.w	r2, [r3, #263]	; 0x107
	return bytes;
    57a6:	e7f5      	b.n	5794 <_usb_d_dev_ep_read_req+0x34>
		return -USB_ERR_PARAM;
    57a8:	f06f 0011 	mvn.w	r0, #17
    57ac:	e7f2      	b.n	5794 <_usb_d_dev_ep_read_req+0x34>
    57ae:	f06f 0011 	mvn.w	r0, #17
    57b2:	e7ef      	b.n	5794 <_usb_d_dev_ep_read_req+0x34>
		return -USB_ERR_FUNC;
    57b4:	f06f 0012 	mvn.w	r0, #18
    57b8:	e7ec      	b.n	5794 <_usb_d_dev_ep_read_req+0x34>
    57ba:	bf00      	nop
    57bc:	200002d0 	.word	0x200002d0

000057c0 <_usb_d_dev_ep_trans>:

int32_t _usb_d_dev_ep_trans(const struct usb_d_transfer *trans)
{
    57c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    57c4:	b083      	sub	sp, #12
	uint8_t               epn = USB_EP_GET_N(trans->ep);
    57c6:	7a03      	ldrb	r3, [r0, #8]
    57c8:	b25e      	sxtb	r6, r3
	uint8_t ep_index = (epn == 0) ? 0 : (dir ? (epn + CONF_USB_D_MAX_EP_N) : epn);
    57ca:	f013 030f 	ands.w	r3, r3, #15
    57ce:	f000 80c2 	beq.w	5956 <_usb_d_dev_ep_trans+0x196>
    57d2:	2e00      	cmp	r6, #0
    57d4:	bfb4      	ite	lt
    57d6:	1c9a      	addlt	r2, r3, #2
    57d8:	461a      	movge	r2, r3
	return &dev_inst.ep[ep_index];
    57da:	4614      	mov	r4, r2
    57dc:	4969      	ldr	r1, [pc, #420]	; (5984 <_usb_d_dev_ep_trans+0x1c4>)
    57de:	f101 0760 	add.w	r7, r1, #96	; 0x60
    57e2:	1c55      	adds	r5, r2, #1
    57e4:	eb05 0585 	add.w	r5, r5, r5, lsl #2
    57e8:	eb07 0785 	add.w	r7, r7, r5, lsl #2
	bool                  dir = USB_EP_GET_DIR(trans->ep);
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);

	uint16_t size_mask      = (ept->size == 1023) ? 1023 : (ept->size - 1);
    57ec:	eb02 0282 	add.w	r2, r2, r2, lsl #2
    57f0:	eb01 0282 	add.w	r2, r1, r2, lsl #2
    57f4:	f8b2 2084 	ldrh.w	r2, [r2, #132]	; 0x84
    57f8:	f240 31ff 	movw	r1, #1023	; 0x3ff
    57fc:	428a      	cmp	r2, r1
    57fe:	d025      	beq.n	584c <_usb_d_dev_ep_trans+0x8c>
    5800:	1e55      	subs	r5, r2, #1
    5802:	b2ad      	uxth	r5, r5
	bool     size_n_aligned = (trans->size & size_mask);
    5804:	6841      	ldr	r1, [r0, #4]
    5806:	400d      	ands	r5, r1

	bool use_cache = false;

	volatile hal_atomic_t flags;

	if (epn > CONF_USB_D_MAX_EP_N) {
    5808:	2b02      	cmp	r3, #2
    580a:	f200 8092 	bhi.w	5932 <_usb_d_dev_ep_trans+0x172>
	 * 1. Buffer not in RAM (cache all).
	 * 2. IN/OUT with unaligned buffer (cache all).
	 * 3. OUT with unaligned packet size (cache last packet).
	 * 4. OUT size < 8 (sub-case for 3).
	 */
	if (!_usb_is_addr4dma(trans->buf, trans->size) || (!_usb_is_aligned(trans->buf))
    580e:	6803      	ldr	r3, [r0, #0]
    5810:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
    5814:	d31c      	bcc.n	5850 <_usb_d_dev_ep_trans+0x90>
    5816:	eb03 0c01 	add.w	ip, r3, r1
    581a:	f8df e180 	ldr.w	lr, [pc, #384]	; 599c <_usb_d_dev_ep_trans+0x1dc>
    581e:	45f4      	cmp	ip, lr
    5820:	d816      	bhi.n	5850 <_usb_d_dev_ep_trans+0x90>
    5822:	f013 0f03 	tst.w	r3, #3
    5826:	d113      	bne.n	5850 <_usb_d_dev_ep_trans+0x90>
	    || (!dir && (trans->size < ept->size))) {
    5828:	2e00      	cmp	r6, #0
    582a:	db2a      	blt.n	5882 <_usb_d_dev_ep_trans+0xc2>
    582c:	428a      	cmp	r2, r1
    582e:	f200 809c 	bhi.w	596a <_usb_d_dev_ep_trans+0x1aa>
			return -USB_ERR_FUNC;
		}
		/* Use cache all the time. */
		use_cache = true;
	}
	if (!dir && size_n_aligned) {
    5832:	b34d      	cbz	r5, 5888 <_usb_d_dev_ep_trans+0xc8>
		if (!ept->cache) {
    5834:	eb04 0384 	add.w	r3, r4, r4, lsl #2
    5838:	4a52      	ldr	r2, [pc, #328]	; (5984 <_usb_d_dev_ep_trans+0x1c4>)
    583a:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    583e:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
    5842:	2b00      	cmp	r3, #0
    5844:	d07b      	beq.n	593e <_usb_d_dev_ep_trans+0x17e>
	bool use_cache = false;
    5846:	f04f 0800 	mov.w	r8, #0
    584a:	e00c      	b.n	5866 <_usb_d_dev_ep_trans+0xa6>
	uint16_t size_mask      = (ept->size == 1023) ? 1023 : (ept->size - 1);
    584c:	4615      	mov	r5, r2
    584e:	e7d9      	b.n	5804 <_usb_d_dev_ep_trans+0x44>
		if (!ept->cache) {
    5850:	eb04 0384 	add.w	r3, r4, r4, lsl #2
    5854:	4a4b      	ldr	r2, [pc, #300]	; (5984 <_usb_d_dev_ep_trans+0x1c4>)
    5856:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    585a:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
    585e:	2b00      	cmp	r3, #0
    5860:	d06a      	beq.n	5938 <_usb_d_dev_ep_trans+0x178>
		use_cache = true;
    5862:	f04f 0801 	mov.w	r8, #1
		}
		/* Set 'use_cache' on last packet. */
	}

	/* Check halt */
	if (ept->flags.bits.is_stalled) {
    5866:	eb04 0384 	add.w	r3, r4, r4, lsl #2
    586a:	4a46      	ldr	r2, [pc, #280]	; (5984 <_usb_d_dev_ep_trans+0x1c4>)
    586c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    5870:	f893 3087 	ldrb.w	r3, [r3, #135]	; 0x87
    5874:	f013 0f08 	tst.w	r3, #8
    5878:	d009      	beq.n	588e <_usb_d_dev_ep_trans+0xce>
		return USB_HALTED;
    587a:	2002      	movs	r0, #2
	} else {
		_usb_d_dev_out_next(ept, false);
	}

	return ERR_NONE;
}
    587c:	b003      	add	sp, #12
    587e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	bool use_cache = false;
    5882:	f04f 0800 	mov.w	r8, #0
    5886:	e7ee      	b.n	5866 <_usb_d_dev_ep_trans+0xa6>
    5888:	f04f 0800 	mov.w	r8, #0
    588c:	e7eb      	b.n	5866 <_usb_d_dev_ep_trans+0xa6>
    588e:	4682      	mov	sl, r0
	atomic_enter_critical(&flags);
    5890:	a801      	add	r0, sp, #4
    5892:	4b3d      	ldr	r3, [pc, #244]	; (5988 <_usb_d_dev_ep_trans+0x1c8>)
    5894:	4798      	blx	r3
	if (_usb_d_dev_ep_is_busy(ept)) {
    5896:	eb04 0384 	add.w	r3, r4, r4, lsl #2
    589a:	4a3a      	ldr	r2, [pc, #232]	; (5984 <_usb_d_dev_ep_trans+0x1c4>)
    589c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    58a0:	f893 3087 	ldrb.w	r3, [r3, #135]	; 0x87
    58a4:	f013 0f40 	tst.w	r3, #64	; 0x40
    58a8:	d13c      	bne.n	5924 <_usb_d_dev_ep_trans+0x164>
	ept->flags.bits.is_busy = 1;
    58aa:	eb04 0984 	add.w	r9, r4, r4, lsl #2
    58ae:	4b35      	ldr	r3, [pc, #212]	; (5984 <_usb_d_dev_ep_trans+0x1c4>)
    58b0:	eb03 0989 	add.w	r9, r3, r9, lsl #2
    58b4:	f899 3087 	ldrb.w	r3, [r9, #135]	; 0x87
    58b8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    58bc:	f889 3087 	strb.w	r3, [r9, #135]	; 0x87
	atomic_leave_critical(&flags);
    58c0:	a801      	add	r0, sp, #4
    58c2:	4b32      	ldr	r3, [pc, #200]	; (598c <_usb_d_dev_ep_trans+0x1cc>)
    58c4:	4798      	blx	r3
	ept->trans_buf   = trans->buf;
    58c6:	f8da 3000 	ldr.w	r3, [sl]
    58ca:	f8c9 3074 	str.w	r3, [r9, #116]	; 0x74
	ept->trans_size  = trans->size;
    58ce:	f8da 3004 	ldr.w	r3, [sl, #4]
    58d2:	f8c9 3078 	str.w	r3, [r9, #120]	; 0x78
	ept->trans_count = 0;
    58d6:	2300      	movs	r3, #0
    58d8:	f8c9 307c 	str.w	r3, [r9, #124]	; 0x7c
	bool                  dir = USB_EP_GET_DIR(trans->ep);
    58dc:	0ff2      	lsrs	r2, r6, #31
	ept->flags.bits.dir       = dir;
    58de:	f899 3087 	ldrb.w	r3, [r9, #135]	; 0x87
    58e2:	f362 13c7 	bfi	r3, r2, #7, #1
	ept->flags.bits.use_cache = use_cache;
    58e6:	f368 1345 	bfi	r3, r8, #5, #1
    58ea:	f889 3087 	strb.w	r3, [r9, #135]	; 0x87
	ept->flags.bits.need_zlp  = (trans->zlp && (!size_n_aligned));
    58ee:	f89a 3009 	ldrb.w	r3, [sl, #9]
    58f2:	b1e3      	cbz	r3, 592e <_usb_d_dev_ep_trans+0x16e>
    58f4:	fab5 f585 	clz	r5, r5
    58f8:	096d      	lsrs	r5, r5, #5
    58fa:	eb04 0484 	add.w	r4, r4, r4, lsl #2
    58fe:	4b21      	ldr	r3, [pc, #132]	; (5984 <_usb_d_dev_ep_trans+0x1c4>)
    5900:	eb03 0484 	add.w	r4, r3, r4, lsl #2
    5904:	f894 3087 	ldrb.w	r3, [r4, #135]	; 0x87
    5908:	f365 1304 	bfi	r3, r5, #4, #1
    590c:	f884 3087 	strb.w	r3, [r4, #135]	; 0x87
	if (dir) {
    5910:	2e00      	cmp	r6, #0
		_usb_d_dev_in_next(ept, false);
    5912:	f04f 0100 	mov.w	r1, #0
    5916:	4638      	mov	r0, r7
    5918:	bfb4      	ite	lt
    591a:	4b1d      	ldrlt	r3, [pc, #116]	; (5990 <_usb_d_dev_ep_trans+0x1d0>)
		_usb_d_dev_out_next(ept, false);
    591c:	4b1d      	ldrge	r3, [pc, #116]	; (5994 <_usb_d_dev_ep_trans+0x1d4>)
    591e:	4798      	blx	r3
	return ERR_NONE;
    5920:	2000      	movs	r0, #0
    5922:	e7ab      	b.n	587c <_usb_d_dev_ep_trans+0xbc>
		atomic_leave_critical(&flags);
    5924:	a801      	add	r0, sp, #4
    5926:	4b19      	ldr	r3, [pc, #100]	; (598c <_usb_d_dev_ep_trans+0x1cc>)
    5928:	4798      	blx	r3
		return USB_BUSY;
    592a:	2001      	movs	r0, #1
    592c:	e7a6      	b.n	587c <_usb_d_dev_ep_trans+0xbc>
    592e:	2500      	movs	r5, #0
    5930:	e7e3      	b.n	58fa <_usb_d_dev_ep_trans+0x13a>
		return -USB_ERR_PARAM;
    5932:	f06f 0011 	mvn.w	r0, #17
    5936:	e7a1      	b.n	587c <_usb_d_dev_ep_trans+0xbc>
			return -USB_ERR_FUNC;
    5938:	f06f 0012 	mvn.w	r0, #18
    593c:	e79e      	b.n	587c <_usb_d_dev_ep_trans+0xbc>
			return -USB_ERR_PARAM;
    593e:	f06f 0011 	mvn.w	r0, #17
    5942:	e79b      	b.n	587c <_usb_d_dev_ep_trans+0xbc>
			return -USB_ERR_FUNC;
    5944:	f06f 0012 	mvn.w	r0, #18
    5948:	e798      	b.n	587c <_usb_d_dev_ep_trans+0xbc>
	bool     size_n_aligned = (trans->size & size_mask);
    594a:	6841      	ldr	r1, [r0, #4]
    594c:	f3c1 0509 	ubfx	r5, r1, #0, #10
	return &dev_inst.ep[ep_index];
    5950:	4f11      	ldr	r7, [pc, #68]	; (5998 <_usb_d_dev_ep_trans+0x1d8>)
    5952:	2400      	movs	r4, #0
    5954:	e75b      	b.n	580e <_usb_d_dev_ep_trans+0x4e>
	uint16_t size_mask      = (ept->size == 1023) ? 1023 : (ept->size - 1);
    5956:	4a0b      	ldr	r2, [pc, #44]	; (5984 <_usb_d_dev_ep_trans+0x1c4>)
    5958:	f8b2 2084 	ldrh.w	r2, [r2, #132]	; 0x84
    595c:	f240 31ff 	movw	r1, #1023	; 0x3ff
    5960:	428a      	cmp	r2, r1
    5962:	d0f2      	beq.n	594a <_usb_d_dev_ep_trans+0x18a>
	return &dev_inst.ep[ep_index];
    5964:	4f0c      	ldr	r7, [pc, #48]	; (5998 <_usb_d_dev_ep_trans+0x1d8>)
    5966:	2400      	movs	r4, #0
    5968:	e74a      	b.n	5800 <_usb_d_dev_ep_trans+0x40>
		if (!ept->cache) {
    596a:	eb04 0384 	add.w	r3, r4, r4, lsl #2
    596e:	4a05      	ldr	r2, [pc, #20]	; (5984 <_usb_d_dev_ep_trans+0x1c4>)
    5970:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    5974:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
    5978:	2b00      	cmp	r3, #0
    597a:	d0e3      	beq.n	5944 <_usb_d_dev_ep_trans+0x184>
    597c:	f04f 0801 	mov.w	r8, #1
    5980:	e771      	b.n	5866 <_usb_d_dev_ep_trans+0xa6>
    5982:	bf00      	nop
    5984:	200002d0 	.word	0x200002d0
    5988:	00002221 	.word	0x00002221
    598c:	0000222f 	.word	0x0000222f
    5990:	00004a49 	.word	0x00004a49
    5994:	00004bcd 	.word	0x00004bcd
    5998:	20000344 	.word	0x20000344
    599c:	20041fff 	.word	0x20041fff

000059a0 <_usb_d_dev_register_callback>:
	return USB_OK;
}

void _usb_d_dev_register_callback(const enum usb_d_cb_type type, const FUNC_PTR func)
{
	FUNC_PTR f = (func == NULL) ? (FUNC_PTR)_dummy_func_no_return : (FUNC_PTR)func;
    59a0:	4b06      	ldr	r3, [pc, #24]	; (59bc <_usb_d_dev_register_callback+0x1c>)
    59a2:	2900      	cmp	r1, #0
    59a4:	bf08      	it	eq
    59a6:	4619      	moveq	r1, r3
	if (type == USB_D_CB_EVENT) {
    59a8:	2801      	cmp	r0, #1
    59aa:	d003      	beq.n	59b4 <_usb_d_dev_register_callback+0x14>
		dev_inst.callbacks.event = (_usb_d_dev_event_cb_t)f;
	} else if (type == USB_D_CB_SOF) {
    59ac:	b908      	cbnz	r0, 59b2 <_usb_d_dev_register_callback+0x12>
		dev_inst.callbacks.sof = (_usb_d_dev_sof_cb_t)f;
    59ae:	4b04      	ldr	r3, [pc, #16]	; (59c0 <_usb_d_dev_register_callback+0x20>)
    59b0:	6619      	str	r1, [r3, #96]	; 0x60
    59b2:	4770      	bx	lr
		dev_inst.callbacks.event = (_usb_d_dev_event_cb_t)f;
    59b4:	4b02      	ldr	r3, [pc, #8]	; (59c0 <_usb_d_dev_register_callback+0x20>)
    59b6:	6659      	str	r1, [r3, #100]	; 0x64
    59b8:	4770      	bx	lr
    59ba:	bf00      	nop
    59bc:	000047c1 	.word	0x000047c1
    59c0:	200002d0 	.word	0x200002d0

000059c4 <_usb_d_dev_register_ep_callback>:
	}
}

void _usb_d_dev_register_ep_callback(const enum usb_d_dev_ep_cb_type type, const FUNC_PTR func)
{
	FUNC_PTR f = (func == NULL) ? (FUNC_PTR)_dummy_func_no_return : (FUNC_PTR)func;
    59c4:	4b09      	ldr	r3, [pc, #36]	; (59ec <_usb_d_dev_register_ep_callback+0x28>)
    59c6:	2900      	cmp	r1, #0
    59c8:	bf08      	it	eq
    59ca:	4619      	moveq	r1, r3
	if (type == USB_D_DEV_EP_CB_SETUP) {
    59cc:	4603      	mov	r3, r0
    59ce:	b130      	cbz	r0, 59de <_usb_d_dev_register_ep_callback+0x1a>
		dev_inst.ep_callbacks.setup = (_usb_d_dev_ep_cb_setup_t)f;
	} else if (type == USB_D_DEV_EP_CB_MORE) {
    59d0:	2801      	cmp	r0, #1
    59d2:	d007      	beq.n	59e4 <_usb_d_dev_register_ep_callback+0x20>
		dev_inst.ep_callbacks.more = (_usb_d_dev_ep_cb_more_t)f;
	} else if (type == USB_D_DEV_EP_CB_DONE) {
    59d4:	2802      	cmp	r0, #2
		dev_inst.ep_callbacks.done = (_usb_d_dev_ep_cb_done_t)f;
    59d6:	bf04      	itt	eq
    59d8:	4b05      	ldreq	r3, [pc, #20]	; (59f0 <_usb_d_dev_register_ep_callback+0x2c>)
    59da:	6719      	streq	r1, [r3, #112]	; 0x70
    59dc:	4770      	bx	lr
		dev_inst.ep_callbacks.setup = (_usb_d_dev_ep_cb_setup_t)f;
    59de:	4b04      	ldr	r3, [pc, #16]	; (59f0 <_usb_d_dev_register_ep_callback+0x2c>)
    59e0:	6699      	str	r1, [r3, #104]	; 0x68
    59e2:	4770      	bx	lr
		dev_inst.ep_callbacks.more = (_usb_d_dev_ep_cb_more_t)f;
    59e4:	4b02      	ldr	r3, [pc, #8]	; (59f0 <_usb_d_dev_register_ep_callback+0x2c>)
    59e6:	66d9      	str	r1, [r3, #108]	; 0x6c
    59e8:	4770      	bx	lr
    59ea:	bf00      	nop
    59ec:	000047c1 	.word	0x000047c1
    59f0:	200002d0 	.word	0x200002d0

000059f4 <USB_0_Handler>:

/**
* \brief USB interrupt handler
*/
void USB_0_Handler(void)
{
    59f4:	b508      	push	{r3, lr}

	_usb_d_dev_handler();
    59f6:	4b01      	ldr	r3, [pc, #4]	; (59fc <USB_0_Handler+0x8>)
    59f8:	4798      	blx	r3
    59fa:	bd08      	pop	{r3, pc}
    59fc:	00004dbd 	.word	0x00004dbd

00005a00 <USB_1_Handler>:
}
/**
* \brief USB interrupt handler
*/
void USB_1_Handler(void)
{
    5a00:	b508      	push	{r3, lr}

	_usb_d_dev_handler();
    5a02:	4b01      	ldr	r3, [pc, #4]	; (5a08 <USB_1_Handler+0x8>)
    5a04:	4798      	blx	r3
    5a06:	bd08      	pop	{r3, pc}
    5a08:	00004dbd 	.word	0x00004dbd

00005a0c <USB_2_Handler>:
}
/**
* \brief USB interrupt handler
*/
void USB_2_Handler(void)
{
    5a0c:	b508      	push	{r3, lr}

	_usb_d_dev_handler();
    5a0e:	4b01      	ldr	r3, [pc, #4]	; (5a14 <USB_2_Handler+0x8>)
    5a10:	4798      	blx	r3
    5a12:	bd08      	pop	{r3, pc}
    5a14:	00004dbd 	.word	0x00004dbd

00005a18 <USB_3_Handler>:
}
/**
* \brief USB interrupt handler
*/
void USB_3_Handler(void)
{
    5a18:	b508      	push	{r3, lr}

	_usb_d_dev_handler();
    5a1a:	4b01      	ldr	r3, [pc, #4]	; (5a20 <USB_3_Handler+0x8>)
    5a1c:	4798      	blx	r3
    5a1e:	bd08      	pop	{r3, pc}
    5a20:	00004dbd 	.word	0x00004dbd

00005a24 <tratto_tempo>:
}




void tratto_tempo(uint32_t tempo,machine_configuration_t *mc){
    5a24:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    5a28:	b082      	sub	sp, #8
    5a2a:	4605      	mov	r5, r0
    5a2c:	460c      	mov	r4, r1
	uint8_t index=mc->index_gun;
    5a2e:	780e      	ldrb	r6, [r1, #0]
	uint32_t time_left = 0;
	time_left=tempo;
	if (overtime(mc->active)>0){
    5a30:	784b      	ldrb	r3, [r1, #1]
    5a32:	f44f 718e 	mov.w	r1, #284	; 0x11c
    5a36:	4a77      	ldr	r2, [pc, #476]	; (5c14 <tratto_tempo+0x1f0>)
    5a38:	fb01 2303 	mla	r3, r1, r3, r2
    5a3c:	691b      	ldr	r3, [r3, #16]
    5a3e:	b923      	cbnz	r3, 5a4a <tratto_tempo+0x26>
			time_left = 0;
		}
		close_over(index);
	}
	
	if (time_left > 0){
    5a40:	2800      	cmp	r0, #0
    5a42:	d157      	bne.n	5af4 <tratto_tempo+0xd0>
		else{
			os_sleep(time_left);
			close_normal(index);
		}
	}
}
    5a44:	b002      	add	sp, #8
    5a46:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

extern TaskHandle_t xRoutineTask0;
extern TaskHandle_t xRoutineTask1;

void static open_over(uint8_t index){
	if (index){
    5a4a:	bb46      	cbnz	r6, 5a9e <tratto_tempo+0x7a>
    5a4c:	2220      	movs	r2, #32
    5a4e:	4b72      	ldr	r3, [pc, #456]	; (5c18 <tratto_tempo+0x1f4>)
    5a50:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
		if (overtime(mc->active) < time_left){
    5a54:	7863      	ldrb	r3, [r4, #1]
    5a56:	f44f 718e 	mov.w	r1, #284	; 0x11c
    5a5a:	4a6e      	ldr	r2, [pc, #440]	; (5c14 <tratto_tempo+0x1f0>)
    5a5c:	fb01 2303 	mla	r3, r1, r3, r2
    5a60:	691b      	ldr	r3, [r3, #16]
    5a62:	429d      	cmp	r5, r3
    5a64:	d920      	bls.n	5aa8 <tratto_tempo+0x84>
			TickType_t xLastWakeTime = xTaskGetTickCount ();
    5a66:	4b6d      	ldr	r3, [pc, #436]	; (5c1c <tratto_tempo+0x1f8>)
    5a68:	4798      	blx	r3
    5a6a:	ab02      	add	r3, sp, #8
    5a6c:	f843 0d04 	str.w	r0, [r3, #-4]!
			vTaskDelayUntil(&xLastWakeTime,overtime(mc->active));
    5a70:	4f68      	ldr	r7, [pc, #416]	; (5c14 <tratto_tempo+0x1f0>)
    5a72:	7862      	ldrb	r2, [r4, #1]
    5a74:	f44f 788e 	mov.w	r8, #284	; 0x11c
    5a78:	fb08 7202 	mla	r2, r8, r2, r7
    5a7c:	6911      	ldr	r1, [r2, #16]
    5a7e:	4618      	mov	r0, r3
    5a80:	4b67      	ldr	r3, [pc, #412]	; (5c20 <tratto_tempo+0x1fc>)
    5a82:	4798      	blx	r3
			time_left= time_left-overtime(mc->active);
    5a84:	7863      	ldrb	r3, [r4, #1]
    5a86:	fb08 7303 	mla	r3, r8, r3, r7
    5a8a:	691b      	ldr	r3, [r3, #16]
    5a8c:	1aed      	subs	r5, r5, r3
		pwm_enable(&PWM_0);
	}
}

void static close_over(uint8_t index){
	if (index){
    5a8e:	b99e      	cbnz	r6, 5ab8 <tratto_tempo+0x94>
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    5a90:	2220      	movs	r2, #32
    5a92:	4b61      	ldr	r3, [pc, #388]	; (5c18 <tratto_tempo+0x1f4>)
    5a94:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
	if (time_left > 0){
    5a98:	2d00      	cmp	r5, #0
    5a9a:	d0d3      	beq.n	5a44 <tratto_tempo+0x20>
    5a9c:	e02c      	b.n	5af8 <tratto_tempo+0xd4>
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    5a9e:	2210      	movs	r2, #16
    5aa0:	4b5d      	ldr	r3, [pc, #372]	; (5c18 <tratto_tempo+0x1f4>)
    5aa2:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
    5aa6:	e7d5      	b.n	5a54 <tratto_tempo+0x30>
			os_sleep(time_left);
    5aa8:	4628      	mov	r0, r5
    5aaa:	4b5e      	ldr	r3, [pc, #376]	; (5c24 <tratto_tempo+0x200>)
    5aac:	4798      	blx	r3
    5aae:	2e00      	cmp	r6, #0
    5ab0:	f040 80aa 	bne.w	5c08 <tratto_tempo+0x1e4>
			time_left = 0;
    5ab4:	2500      	movs	r5, #0
    5ab6:	e7eb      	b.n	5a90 <tratto_tempo+0x6c>
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    5ab8:	2210      	movs	r2, #16
    5aba:	4b57      	ldr	r3, [pc, #348]	; (5c18 <tratto_tempo+0x1f4>)
    5abc:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
	if (time_left > 0){
    5ac0:	2d00      	cmp	r5, #0
    5ac2:	d0bf      	beq.n	5a44 <tratto_tempo+0x20>
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    5ac4:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    5ac8:	4b53      	ldr	r3, [pc, #332]	; (5c18 <tratto_tempo+0x1f4>)
    5aca:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
		if ((undertime(mc->active)<0xFFFFFFFF)&& (time_left > undertime(mc->active))){
    5ace:	7863      	ldrb	r3, [r4, #1]
    5ad0:	f44f 718e 	mov.w	r1, #284	; 0x11c
    5ad4:	4a4f      	ldr	r2, [pc, #316]	; (5c14 <tratto_tempo+0x1f0>)
    5ad6:	fb01 2303 	mla	r3, r1, r3, r2
    5ada:	6958      	ldr	r0, [r3, #20]
    5adc:	f1b0 3fff 	cmp.w	r0, #4294967295
    5ae0:	d119      	bne.n	5b16 <tratto_tempo+0xf2>
			os_sleep(time_left);
    5ae2:	4628      	mov	r0, r5
    5ae4:	4b4f      	ldr	r3, [pc, #316]	; (5c24 <tratto_tempo+0x200>)
    5ae6:	4798      	blx	r3
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    5ae8:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    5aec:	4b4a      	ldr	r3, [pc, #296]	; (5c18 <tratto_tempo+0x1f4>)
    5aee:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
    5af2:	e7a7      	b.n	5a44 <tratto_tempo+0x20>
	if (index){
    5af4:	2e00      	cmp	r6, #0
    5af6:	d1e5      	bne.n	5ac4 <tratto_tempo+0xa0>
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    5af8:	f44f 7200 	mov.w	r2, #512	; 0x200
    5afc:	4b46      	ldr	r3, [pc, #280]	; (5c18 <tratto_tempo+0x1f4>)
    5afe:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
		if ((undertime(mc->active)<0xFFFFFFFF)&& (time_left > undertime(mc->active))){
    5b02:	7863      	ldrb	r3, [r4, #1]
    5b04:	f44f 718e 	mov.w	r1, #284	; 0x11c
    5b08:	4a42      	ldr	r2, [pc, #264]	; (5c14 <tratto_tempo+0x1f0>)
    5b0a:	fb01 2303 	mla	r3, r1, r3, r2
    5b0e:	6958      	ldr	r0, [r3, #20]
    5b10:	f1b0 3fff 	cmp.w	r0, #4294967295
    5b14:	d074      	beq.n	5c00 <tratto_tempo+0x1dc>
    5b16:	42a8      	cmp	r0, r5
    5b18:	d30a      	bcc.n	5b30 <tratto_tempo+0x10c>
			os_sleep(time_left);
    5b1a:	4628      	mov	r0, r5
    5b1c:	4b41      	ldr	r3, [pc, #260]	; (5c24 <tratto_tempo+0x200>)
    5b1e:	4798      	blx	r3
	}
}


void static close_normal(uint8_t index){
	if (index){
    5b20:	2e00      	cmp	r6, #0
    5b22:	d1e1      	bne.n	5ae8 <tratto_tempo+0xc4>
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    5b24:	f44f 7200 	mov.w	r2, #512	; 0x200
    5b28:	4b3b      	ldr	r3, [pc, #236]	; (5c18 <tratto_tempo+0x1f4>)
    5b2a:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
}
    5b2e:	e789      	b.n	5a44 <tratto_tempo+0x20>
			os_sleep(undertime(mc->active));
    5b30:	4b3c      	ldr	r3, [pc, #240]	; (5c24 <tratto_tempo+0x200>)
    5b32:	4798      	blx	r3
    5b34:	2e00      	cmp	r6, #0
    5b36:	d131      	bne.n	5b9c <tratto_tempo+0x178>
    5b38:	4e37      	ldr	r6, [pc, #220]	; (5c18 <tratto_tempo+0x1f4>)
    5b3a:	f44f 7700 	mov.w	r7, #512	; 0x200
    5b3e:	f8c6 7094 	str.w	r7, [r6, #148]	; 0x94
		PWM_0_init();
    5b42:	4b39      	ldr	r3, [pc, #228]	; (5c28 <tratto_tempo+0x204>)
    5b44:	4798      	blx	r3
		pwm_set_parameters(&PWM_0,  1000,  500);
    5b46:	f8df 80fc 	ldr.w	r8, [pc, #252]	; 5c44 <tratto_tempo+0x220>
    5b4a:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
    5b4e:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
    5b52:	4640      	mov	r0, r8
    5b54:	4b35      	ldr	r3, [pc, #212]	; (5c2c <tratto_tempo+0x208>)
    5b56:	4798      	blx	r3
		pwm_enable(&PWM_0);
    5b58:	4640      	mov	r0, r8
    5b5a:	4b35      	ldr	r3, [pc, #212]	; (5c30 <tratto_tempo+0x20c>)
    5b5c:	4798      	blx	r3
			os_sleep(time_left- undertime(mc->active));
    5b5e:	7863      	ldrb	r3, [r4, #1]
    5b60:	f44f 718e 	mov.w	r1, #284	; 0x11c
    5b64:	4a2b      	ldr	r2, [pc, #172]	; (5c14 <tratto_tempo+0x1f0>)
    5b66:	fb01 2303 	mla	r3, r1, r3, r2
    5b6a:	6958      	ldr	r0, [r3, #20]
    5b6c:	1a28      	subs	r0, r5, r0
    5b6e:	4b2d      	ldr	r3, [pc, #180]	; (5c24 <tratto_tempo+0x200>)
    5b70:	4798      	blx	r3
		gpio_set_pin_direction(PB15, GPIO_DIRECTION_OUT);
		gpio_set_pin_function(PB15, GPIO_PIN_FUNCTION_OFF);
		gpio_set_pin_level(PB15,0);
	}
	else{
		pwm_disable(&PWM_0);
    5b72:	4640      	mov	r0, r8
    5b74:	4b2f      	ldr	r3, [pc, #188]	; (5c34 <tratto_tempo+0x210>)
    5b76:	4798      	blx	r3
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    5b78:	f8c6 7088 	str.w	r7, [r6, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    5b7c:	4b2e      	ldr	r3, [pc, #184]	; (5c38 <tratto_tempo+0x214>)
    5b7e:	f8c6 30a8 	str.w	r3, [r6, #168]	; 0xa8
    5b82:	f04f 4340 	mov.w	r3, #3221225472	; 0xc0000000
    5b86:	f8c6 30a8 	str.w	r3, [r6, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    5b8a:	f896 30c9 	ldrb.w	r3, [r6, #201]	; 0xc9
	tmp &= ~PORT_PINCFG_PMUXEN;
    5b8e:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    5b92:	f886 30c9 	strb.w	r3, [r6, #201]	; 0xc9
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    5b96:	f8c6 7094 	str.w	r7, [r6, #148]	; 0x94
    5b9a:	e753      	b.n	5a44 <tratto_tempo+0x20>
    5b9c:	4e1e      	ldr	r6, [pc, #120]	; (5c18 <tratto_tempo+0x1f4>)
    5b9e:	f44f 4700 	mov.w	r7, #32768	; 0x8000
    5ba2:	f8c6 7094 	str.w	r7, [r6, #148]	; 0x94
		PWM_1_init();
    5ba6:	4b25      	ldr	r3, [pc, #148]	; (5c3c <tratto_tempo+0x218>)
    5ba8:	4798      	blx	r3
		pwm_set_parameters(&PWM_1,  1000,  500);
    5baa:	f8df 809c 	ldr.w	r8, [pc, #156]	; 5c48 <tratto_tempo+0x224>
    5bae:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
    5bb2:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
    5bb6:	4640      	mov	r0, r8
    5bb8:	4b1c      	ldr	r3, [pc, #112]	; (5c2c <tratto_tempo+0x208>)
    5bba:	4798      	blx	r3
		pwm_enable(&PWM_1);
    5bbc:	4640      	mov	r0, r8
    5bbe:	4b1c      	ldr	r3, [pc, #112]	; (5c30 <tratto_tempo+0x20c>)
    5bc0:	4798      	blx	r3
    5bc2:	7863      	ldrb	r3, [r4, #1]
    5bc4:	f44f 718e 	mov.w	r1, #284	; 0x11c
    5bc8:	4a12      	ldr	r2, [pc, #72]	; (5c14 <tratto_tempo+0x1f0>)
    5bca:	fb01 2303 	mla	r3, r1, r3, r2
    5bce:	6958      	ldr	r0, [r3, #20]
    5bd0:	1a28      	subs	r0, r5, r0
    5bd2:	4b14      	ldr	r3, [pc, #80]	; (5c24 <tratto_tempo+0x200>)
    5bd4:	4798      	blx	r3
		pwm_disable(&PWM_1);
    5bd6:	4640      	mov	r0, r8
    5bd8:	4b16      	ldr	r3, [pc, #88]	; (5c34 <tratto_tempo+0x210>)
    5bda:	4798      	blx	r3
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    5bdc:	f8c6 7088 	str.w	r7, [r6, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    5be0:	4b17      	ldr	r3, [pc, #92]	; (5c40 <tratto_tempo+0x21c>)
    5be2:	f8c6 30a8 	str.w	r3, [r6, #168]	; 0xa8
    5be6:	f04f 4340 	mov.w	r3, #3221225472	; 0xc0000000
    5bea:	f8c6 30a8 	str.w	r3, [r6, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    5bee:	f896 30cf 	ldrb.w	r3, [r6, #207]	; 0xcf
	tmp &= ~PORT_PINCFG_PMUXEN;
    5bf2:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    5bf6:	f886 30cf 	strb.w	r3, [r6, #207]	; 0xcf
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    5bfa:	f8c6 7094 	str.w	r7, [r6, #148]	; 0x94
    5bfe:	e721      	b.n	5a44 <tratto_tempo+0x20>
			os_sleep(time_left);
    5c00:	4628      	mov	r0, r5
    5c02:	4b08      	ldr	r3, [pc, #32]	; (5c24 <tratto_tempo+0x200>)
    5c04:	4798      	blx	r3
    5c06:	e78d      	b.n	5b24 <tratto_tempo+0x100>
    5c08:	2210      	movs	r2, #16
    5c0a:	4b03      	ldr	r3, [pc, #12]	; (5c18 <tratto_tempo+0x1f4>)
    5c0c:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
    5c10:	e718      	b.n	5a44 <tratto_tempo+0x20>
    5c12:	bf00      	nop
    5c14:	20001ae8 	.word	0x20001ae8
    5c18:	41008000 	.word	0x41008000
    5c1c:	00007c55 	.word	0x00007c55
    5c20:	00007e95 	.word	0x00007e95
    5c24:	00007f41 	.word	0x00007f41
    5c28:	00000a29 	.word	0x00000a29
    5c2c:	00002909 	.word	0x00002909
    5c30:	00002891 	.word	0x00002891
    5c34:	000028cd 	.word	0x000028cd
    5c38:	40000200 	.word	0x40000200
    5c3c:	00000aa1 	.word	0x00000aa1
    5c40:	40008000 	.word	0x40008000
    5c44:	200015c0 	.word	0x200015c0
    5c48:	2000165c 	.word	0x2000165c

00005c4c <controller_routine>:
}



static void controller_routine(machine_configuration_t *gc)
{
    5c4c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    5c50:	4606      	mov	r6, r0
	while(1){
		/*
		wait for pressure, requires interrupt
		*/
		
		vTaskSuspend(NULL);
    5c52:	f04f 0900 	mov.w	r9, #0
    5c56:	f8df a06c 	ldr.w	sl, [pc, #108]	; 5cc4 <controller_routine+0x78>
		uint32_t time_left = 0;
		uint8_t i=0;
		while (i<len(gc->active)){
    5c5a:	4d18      	ldr	r5, [pc, #96]	; (5cbc <controller_routine+0x70>)
			os_sleep(time_left);
			close_normal(index);
			}
			}*/
			
			tratto_tempo(times(gc->active)[i],gc);
    5c5c:	f8df 8068 	ldr.w	r8, [pc, #104]	; 5cc8 <controller_routine+0x7c>
		vTaskSuspend(NULL);
    5c60:	4648      	mov	r0, r9
    5c62:	47d0      	blx	sl
		uint8_t i=0;
    5c64:	464c      	mov	r4, r9
		while (i<len(gc->active)){
    5c66:	f44f 778e 	mov.w	r7, #284	; 0x11c
    5c6a:	7873      	ldrb	r3, [r6, #1]
    5c6c:	fb07 5203 	mla	r2, r7, r3, r5
    5c70:	f8d2 2118 	ldr.w	r2, [r2, #280]	; 0x118
    5c74:	4294      	cmp	r4, r2
    5c76:	d2f3      	bcs.n	5c60 <controller_routine+0x14>
			tratto_tempo(times(gc->active)[i],gc);
    5c78:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
    5c7c:	ebc3 03c2 	rsb	r3, r3, r2, lsl #3
    5c80:	4423      	add	r3, r4
    5c82:	3306      	adds	r3, #6
    5c84:	4631      	mov	r1, r6
    5c86:	f855 0023 	ldr.w	r0, [r5, r3, lsl #2]
    5c8a:	47c0      	blx	r8
			
			i++;
    5c8c:	1c63      	adds	r3, r4, #1
    5c8e:	b2db      	uxtb	r3, r3
			if (i<len(gc->active)){
    5c90:	7872      	ldrb	r2, [r6, #1]
    5c92:	fb07 5102 	mla	r1, r7, r2, r5
    5c96:	f8d1 1118 	ldr.w	r1, [r1, #280]	; 0x118
    5c9a:	428b      	cmp	r3, r1
    5c9c:	d301      	bcc.n	5ca2 <controller_routine+0x56>
			i++;
    5c9e:	461c      	mov	r4, r3
    5ca0:	e7e3      	b.n	5c6a <controller_routine+0x1e>
				os_sleep(times(gc->active)[i]);
    5ca2:	eb02 01c2 	add.w	r1, r2, r2, lsl #3
    5ca6:	ebc2 02c1 	rsb	r2, r2, r1, lsl #3
    5caa:	4413      	add	r3, r2
    5cac:	3306      	adds	r3, #6
    5cae:	f855 0023 	ldr.w	r0, [r5, r3, lsl #2]
    5cb2:	4b03      	ldr	r3, [pc, #12]	; (5cc0 <controller_routine+0x74>)
    5cb4:	4798      	blx	r3
				i++;
    5cb6:	3402      	adds	r4, #2
    5cb8:	b2e4      	uxtb	r4, r4
    5cba:	e7d4      	b.n	5c66 <controller_routine+0x1a>
    5cbc:	20001ae8 	.word	0x20001ae8
    5cc0:	00007f41 	.word	0x00007f41
    5cc4:	00008035 	.word	0x00008035
    5cc8:	00005a25 	.word	0x00005a25

00005ccc <start_routine>:
		}
	}
}


void start_routine(){
    5ccc:	b510      	push	{r4, lr}
    5cce:	b082      	sub	sp, #8
	if (xTaskCreate(controller_routine, "C0", TASK_EXAMPLE_STACK_SIZE,(void*)&machine_confs[0],
    5cd0:	4b0d      	ldr	r3, [pc, #52]	; (5d08 <start_routine+0x3c>)
    5cd2:	9301      	str	r3, [sp, #4]
    5cd4:	2301      	movs	r3, #1
    5cd6:	9300      	str	r3, [sp, #0]
    5cd8:	4b0c      	ldr	r3, [pc, #48]	; (5d0c <start_routine+0x40>)
    5cda:	2220      	movs	r2, #32
    5cdc:	490c      	ldr	r1, [pc, #48]	; (5d10 <start_routine+0x44>)
    5cde:	480d      	ldr	r0, [pc, #52]	; (5d14 <start_routine+0x48>)
    5ce0:	4c0d      	ldr	r4, [pc, #52]	; (5d18 <start_routine+0x4c>)
    5ce2:	47a0      	blx	r4
    5ce4:	2801      	cmp	r0, #1
    5ce6:	d000      	beq.n	5cea <start_routine+0x1e>
    5ce8:	e7fe      	b.n	5ce8 <start_routine+0x1c>
		while (1) {
			;
		}
	}

	if (xTaskCreate(controller_routine, "C1", TASK_EXAMPLE_STACK_SIZE,(void*)&machine_confs[1],
    5cea:	4b0c      	ldr	r3, [pc, #48]	; (5d1c <start_routine+0x50>)
    5cec:	9301      	str	r3, [sp, #4]
    5cee:	2301      	movs	r3, #1
    5cf0:	9300      	str	r3, [sp, #0]
    5cf2:	4b0b      	ldr	r3, [pc, #44]	; (5d20 <start_routine+0x54>)
    5cf4:	2220      	movs	r2, #32
    5cf6:	490b      	ldr	r1, [pc, #44]	; (5d24 <start_routine+0x58>)
    5cf8:	4806      	ldr	r0, [pc, #24]	; (5d14 <start_routine+0x48>)
    5cfa:	4c07      	ldr	r4, [pc, #28]	; (5d18 <start_routine+0x4c>)
    5cfc:	47a0      	blx	r4
    5cfe:	2801      	cmp	r0, #1
    5d00:	d000      	beq.n	5d04 <start_routine+0x38>
    5d02:	e7fe      	b.n	5d02 <start_routine+0x36>
	TASK_EXAMPLE_STACK_PRIORITY, &xRoutineTask1)!= pdPASS) {
		while (1) {
			;
		}
	}
    5d04:	b002      	add	sp, #8
    5d06:	bd10      	pop	{r4, pc}
    5d08:	2000168c 	.word	0x2000168c
    5d0c:	200023c8 	.word	0x200023c8
    5d10:	000099a0 	.word	0x000099a0
    5d14:	00005c4d 	.word	0x00005c4d
    5d18:	00007925 	.word	0x00007925
    5d1c:	20001688 	.word	0x20001688
    5d20:	200023cb 	.word	0x200023cb
    5d24:	000099a4 	.word	0x000099a4

00005d28 <preparesd>:

FATFS FatFs;		/* FatFs work area needed for each volume */
FIL Fil;			/* File object needed for each open file */


void preparesd(){
    5d28:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    5d2c:	b0c8      	sub	sp, #288	; 0x120
    5d2e:	4b2d      	ldr	r3, [pc, #180]	; (5de4 <preparesd+0xbc>)
    5d30:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    5d34:	2130      	movs	r1, #48	; 0x30
	uint8_t k;
	for (k=0;k<8;k++){
		formats[k].name[0]='c';
    5d36:	f04f 0e63 	mov.w	lr, #99	; 0x63
		formats[k].name[1]=48+k;
		formats[k].overtime=50;
    5d3a:	2732      	movs	r7, #50	; 0x32
		formats[k].undertime=3000;
    5d3c:	f640 36b8 	movw	r6, #3000	; 0xbb8
		formats[k].times[0]=(k+1)*1000;
		formats[k].times[1]=1000;
    5d40:	4602      	mov	r2, r0
		formats[k].times[2]=1000;
		formats[k].times[3]=1000;
		formats[k].times[4]=1000;
		formats[k].times[5]=1000;
		formats[k].len=5;
    5d42:	2505      	movs	r5, #5
	for (k=0;k<8;k++){
    5d44:	f242 3428 	movw	r4, #9000	; 0x2328
		formats[k].name[0]='c';
    5d48:	f883 e000 	strb.w	lr, [r3]
		formats[k].name[1]=48+k;
    5d4c:	7059      	strb	r1, [r3, #1]
		formats[k].overtime=50;
    5d4e:	611f      	str	r7, [r3, #16]
		formats[k].undertime=3000;
    5d50:	615e      	str	r6, [r3, #20]
		formats[k].times[0]=(k+1)*1000;
    5d52:	6198      	str	r0, [r3, #24]
		formats[k].times[1]=1000;
    5d54:	61da      	str	r2, [r3, #28]
		formats[k].times[2]=1000;
    5d56:	621a      	str	r2, [r3, #32]
		formats[k].times[3]=1000;
    5d58:	625a      	str	r2, [r3, #36]	; 0x24
		formats[k].times[4]=1000;
    5d5a:	629a      	str	r2, [r3, #40]	; 0x28
		formats[k].times[5]=1000;
    5d5c:	62da      	str	r2, [r3, #44]	; 0x2c
		formats[k].len=5;
    5d5e:	f8c3 5118 	str.w	r5, [r3, #280]	; 0x118
    5d62:	f503 738e 	add.w	r3, r3, #284	; 0x11c
    5d66:	3101      	adds	r1, #1
    5d68:	b2c9      	uxtb	r1, r1
    5d6a:	f500 707a 	add.w	r0, r0, #1000	; 0x3e8
	for (k=0;k<8;k++){
    5d6e:	42a0      	cmp	r0, r4
    5d70:	d1ea      	bne.n	5d48 <preparesd+0x20>
	}
	UINT bw;
	uint32_t buff[ sizeof(format_t)/4];
	f_mount(&FatFs, "", 0);
    5d72:	2200      	movs	r2, #0
    5d74:	491c      	ldr	r1, [pc, #112]	; (5de8 <preparesd+0xc0>)
    5d76:	481d      	ldr	r0, [pc, #116]	; (5dec <preparesd+0xc4>)
    5d78:	4b1d      	ldr	r3, [pc, #116]	; (5df0 <preparesd+0xc8>)
    5d7a:	4798      	blx	r3
	if(f_open(&Fil, "config.txt",  FA_WRITE) != FR_OK){
    5d7c:	2202      	movs	r2, #2
    5d7e:	491d      	ldr	r1, [pc, #116]	; (5df4 <preparesd+0xcc>)
    5d80:	481d      	ldr	r0, [pc, #116]	; (5df8 <preparesd+0xd0>)
    5d82:	4b1e      	ldr	r3, [pc, #120]	; (5dfc <preparesd+0xd4>)
    5d84:	4798      	blx	r3
    5d86:	b130      	cbz	r0, 5d96 <preparesd+0x6e>
		if(f_open(&Fil, "config.txt",  FA_CREATE_NEW) != FR_OK){
    5d88:	2204      	movs	r2, #4
    5d8a:	491a      	ldr	r1, [pc, #104]	; (5df4 <preparesd+0xcc>)
    5d8c:	481a      	ldr	r0, [pc, #104]	; (5df8 <preparesd+0xd0>)
    5d8e:	4b1b      	ldr	r3, [pc, #108]	; (5dfc <preparesd+0xd4>)
    5d90:	4798      	blx	r3
    5d92:	b100      	cbz	r0, 5d96 <preparesd+0x6e>
    5d94:	e7fe      	b.n	5d94 <preparesd+0x6c>
			while(1);
		}
	}
	
	buff[0]=0;
    5d96:	2300      	movs	r3, #0
    5d98:	9300      	str	r3, [sp, #0]
	f_write(&Fil,buff, 1, &bw);
    5d9a:	ab47      	add	r3, sp, #284	; 0x11c
    5d9c:	2201      	movs	r2, #1
    5d9e:	4669      	mov	r1, sp
    5da0:	4815      	ldr	r0, [pc, #84]	; (5df8 <preparesd+0xd0>)
    5da2:	4c17      	ldr	r4, [pc, #92]	; (5e00 <preparesd+0xd8>)
    5da4:	47a0      	blx	r4
    5da6:	4d17      	ldr	r5, [pc, #92]	; (5e04 <preparesd+0xdc>)
    5da8:	f505 680e 	add.w	r8, r5, #2272	; 0x8e0
    5dac:	ac46      	add	r4, sp, #280	; 0x118
		
		uint32_t* copier = &formats[i];
		for (j=0;j<sizeof(format_t)/4;j++){
			buff[j]=copier[j];
		}
		f_write(&Fil,buff, sizeof(format_t)/4, &bw);
    5dae:	4f12      	ldr	r7, [pc, #72]	; (5df8 <preparesd+0xd0>)
    5db0:	4e13      	ldr	r6, [pc, #76]	; (5e00 <preparesd+0xd8>)
    5db2:	f1ad 0304 	sub.w	r3, sp, #4
void preparesd(){
    5db6:	462a      	mov	r2, r5
			buff[j]=copier[j];
    5db8:	f852 1f04 	ldr.w	r1, [r2, #4]!
    5dbc:	f843 1f04 	str.w	r1, [r3, #4]!
		for (j=0;j<sizeof(format_t)/4;j++){
    5dc0:	42a3      	cmp	r3, r4
    5dc2:	d1f9      	bne.n	5db8 <preparesd+0x90>
		f_write(&Fil,buff, sizeof(format_t)/4, &bw);
    5dc4:	ab47      	add	r3, sp, #284	; 0x11c
    5dc6:	2247      	movs	r2, #71	; 0x47
    5dc8:	4669      	mov	r1, sp
    5dca:	4638      	mov	r0, r7
    5dcc:	47b0      	blx	r6
    5dce:	f505 758e 	add.w	r5, r5, #284	; 0x11c
	for(i=0;i<8;i++){
    5dd2:	4545      	cmp	r5, r8
    5dd4:	d1ed      	bne.n	5db2 <preparesd+0x8a>
	}
	f_close(&Fil);
    5dd6:	4808      	ldr	r0, [pc, #32]	; (5df8 <preparesd+0xd0>)
    5dd8:	4b0b      	ldr	r3, [pc, #44]	; (5e08 <preparesd+0xe0>)
    5dda:	4798      	blx	r3
}
    5ddc:	b048      	add	sp, #288	; 0x120
    5dde:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    5de2:	bf00      	nop
    5de4:	20001ae8 	.word	0x20001ae8
    5de8:	00009a68 	.word	0x00009a68
    5dec:	20001690 	.word	0x20001690
    5df0:	00001b55 	.word	0x00001b55
    5df4:	000099a8 	.word	0x000099a8
    5df8:	200018c4 	.word	0x200018c4
    5dfc:	00001bc5 	.word	0x00001bc5
    5e00:	00001f11 	.word	0x00001f11
    5e04:	20001ae4 	.word	0x20001ae4
    5e08:	000021a9 	.word	0x000021a9

00005e0c <load_times>:

void load_times(){
    5e0c:	b5f0      	push	{r4, r5, r6, r7, lr}
    5e0e:	b0c9      	sub	sp, #292	; 0x124
	//carefully, this shit accept conf only with size multiple of 4B
	UINT bw;
	uint32_t buff[ sizeof(format_t)/4];
	f_mount(&FatFs, "", 0);
    5e10:	2200      	movs	r2, #0
    5e12:	4918      	ldr	r1, [pc, #96]	; (5e74 <load_times+0x68>)
    5e14:	4818      	ldr	r0, [pc, #96]	; (5e78 <load_times+0x6c>)
    5e16:	4b19      	ldr	r3, [pc, #100]	; (5e7c <load_times+0x70>)
    5e18:	4798      	blx	r3
	
	if (f_open(&Fil, "config.txt", FA_READ | FA_OPEN_EXISTING) == FR_OK) {
    5e1a:	2201      	movs	r2, #1
    5e1c:	4918      	ldr	r1, [pc, #96]	; (5e80 <load_times+0x74>)
    5e1e:	4819      	ldr	r0, [pc, #100]	; (5e84 <load_times+0x78>)
    5e20:	4b19      	ldr	r3, [pc, #100]	; (5e88 <load_times+0x7c>)
    5e22:	4798      	blx	r3
    5e24:	b100      	cbz	r0, 5e28 <load_times+0x1c>
    5e26:	e7fe      	b.n	5e26 <load_times+0x1a>
		f_read(&Fil,buff, 1, &bw);
    5e28:	ab47      	add	r3, sp, #284	; 0x11c
    5e2a:	2201      	movs	r2, #1
    5e2c:	4669      	mov	r1, sp
    5e2e:	4815      	ldr	r0, [pc, #84]	; (5e84 <load_times+0x78>)
    5e30:	4c16      	ldr	r4, [pc, #88]	; (5e8c <load_times+0x80>)
    5e32:	47a0      	blx	r4
    5e34:	4c16      	ldr	r4, [pc, #88]	; (5e90 <load_times+0x84>)
    5e36:	f504 670e 	add.w	r7, r4, #2272	; 0x8e0
		//active0=buff[0];
		int i,j;
		for(i=0;i<8;i++){
			f_read(&Fil,buff, sizeof(format_t)/4, &bw);
    5e3a:	4e12      	ldr	r6, [pc, #72]	; (5e84 <load_times+0x78>)
    5e3c:	4d13      	ldr	r5, [pc, #76]	; (5e8c <load_times+0x80>)
    5e3e:	e003      	b.n	5e48 <load_times+0x3c>
    5e40:	f504 748e 	add.w	r4, r4, #284	; 0x11c
		for(i=0;i<8;i++){
    5e44:	42bc      	cmp	r4, r7
    5e46:	d00f      	beq.n	5e68 <load_times+0x5c>
			f_read(&Fil,buff, sizeof(format_t)/4, &bw);
    5e48:	ab47      	add	r3, sp, #284	; 0x11c
    5e4a:	2247      	movs	r2, #71	; 0x47
    5e4c:	4669      	mov	r1, sp
    5e4e:	4630      	mov	r0, r6
    5e50:	47a8      	blx	r5
    5e52:	f1ad 0304 	sub.w	r3, sp, #4
    5e56:	a846      	add	r0, sp, #280	; 0x118
    5e58:	4622      	mov	r2, r4
			uint32_t* copier = &formats[i];
			for (j=0;j<sizeof(format_t)/4;j++){
				copier[j]=buff[j];
    5e5a:	f853 1f04 	ldr.w	r1, [r3, #4]!
    5e5e:	f842 1f04 	str.w	r1, [r2, #4]!
			for (j=0;j<sizeof(format_t)/4;j++){
    5e62:	4283      	cmp	r3, r0
    5e64:	d1f9      	bne.n	5e5a <load_times+0x4e>
    5e66:	e7eb      	b.n	5e40 <load_times+0x34>
			}
		}
		f_close(&Fil);
    5e68:	4806      	ldr	r0, [pc, #24]	; (5e84 <load_times+0x78>)
    5e6a:	4b0a      	ldr	r3, [pc, #40]	; (5e94 <load_times+0x88>)
    5e6c:	4798      	blx	r3
	}
	else{
		while(1);
	}
}
    5e6e:	b049      	add	sp, #292	; 0x124
    5e70:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5e72:	bf00      	nop
    5e74:	00009a68 	.word	0x00009a68
    5e78:	20001690 	.word	0x20001690
    5e7c:	00001b55 	.word	0x00001b55
    5e80:	000099a8 	.word	0x000099a8
    5e84:	200018c4 	.word	0x200018c4
    5e88:	00001bc5 	.word	0x00001bc5
    5e8c:	00001d71 	.word	0x00001d71
    5e90:	20001ae4 	.word	0x20001ae4
    5e94:	000021a9 	.word	0x000021a9

00005e98 <start_sd>:

void get_dl_from_to(uint32_t from, uint32_t to, dl_item_t* buffer){}



void start_sd(){
    5e98:	b508      	push	{r3, lr}
	load_times();
    5e9a:	4b02      	ldr	r3, [pc, #8]	; (5ea4 <start_sd+0xc>)
    5e9c:	4798      	blx	r3
	preparesd();
    5e9e:	4b02      	ldr	r3, [pc, #8]	; (5ea8 <start_sd+0x10>)
    5ea0:	4798      	blx	r3
    5ea2:	bd08      	pop	{r3, pc}
    5ea4:	00005e0d 	.word	0x00005e0d
    5ea8:	00005d29 	.word	0x00005d29

00005eac <sd_mmc_configure_slot>:

/**
 * \brief Configures the driver with the selected card configuration
 */
static void sd_mmc_configure_slot(void)
{
    5eac:	b510      	push	{r4, lr}
    5eae:	b082      	sub	sp, #8
	driver_select_device(
	    sd_mmc_hal, sd_mmc_slot_sel, sd_mmc_card->clock, sd_mmc_card->bus_width, sd_mmc_card->high_speed);
    5eb0:	4807      	ldr	r0, [pc, #28]	; (5ed0 <sd_mmc_configure_slot+0x24>)
    5eb2:	6804      	ldr	r4, [r0, #0]
	driver_select_device(
    5eb4:	7b63      	ldrb	r3, [r4, #13]
    5eb6:	6822      	ldr	r2, [r4, #0]
    5eb8:	7901      	ldrb	r1, [r0, #4]
    5eba:	6880      	ldr	r0, [r0, #8]
    5ebc:	7fa4      	ldrb	r4, [r4, #30]
    5ebe:	3400      	adds	r4, #0
    5ec0:	bf18      	it	ne
    5ec2:	2401      	movne	r4, #1
    5ec4:	9400      	str	r4, [sp, #0]
    5ec6:	4c03      	ldr	r4, [pc, #12]	; (5ed4 <sd_mmc_configure_slot+0x28>)
    5ec8:	47a0      	blx	r4
}
    5eca:	b002      	add	sp, #8
    5ecc:	bd10      	pop	{r4, pc}
    5ece:	bf00      	nop
    5ed0:	20000620 	.word	0x20000620
    5ed4:	000025d1 	.word	0x000025d1

00005ed8 <sd_mmc_select_slot>:
	if (slot >= CONF_SD_MMC_MEM_CNT) {
    5ed8:	b108      	cbz	r0, 5ede <sd_mmc_select_slot+0x6>
		return SD_MMC_ERR_SLOT;
    5eda:	2004      	movs	r0, #4
    5edc:	4770      	bx	lr
{
    5ede:	b530      	push	{r4, r5, lr}
    5ee0:	b083      	sub	sp, #12
	if (_cd && _cd[slot].pin != -1) {
    5ee2:	4b3a      	ldr	r3, [pc, #232]	; (5fcc <sd_mmc_select_slot+0xf4>)
    5ee4:	68db      	ldr	r3, [r3, #12]
    5ee6:	2b00      	cmp	r3, #0
    5ee8:	d041      	beq.n	5f6e <sd_mmc_select_slot+0x96>
    5eea:	f9b3 3000 	ldrsh.w	r3, [r3]
    5eee:	f1b3 3fff 	cmp.w	r3, #4294967295
    5ef2:	d03c      	beq.n	5f6e <sd_mmc_select_slot+0x96>
		if (gpio_get_pin_level(_cd[slot].pin) != _cd[slot].val) {
    5ef4:	b2dd      	uxtb	r5, r3
 */
static inline uint32_t _gpio_get_level(const enum gpio_port port)
{
	uint32_t tmp;

	CRITICAL_SECTION_ENTER();
    5ef6:	a801      	add	r0, sp, #4
    5ef8:	4b35      	ldr	r3, [pc, #212]	; (5fd0 <sd_mmc_select_slot+0xf8>)
    5efa:	4798      	blx	r3
	return tmp;
}

static inline hri_port_dir_reg_t hri_port_read_DIR_reg(const void *const hw, uint8_t submodule_index)
{
	return ((Port *)hw)->Group[submodule_index].DIR.reg;
    5efc:	096b      	lsrs	r3, r5, #5
    5efe:	4935      	ldr	r1, [pc, #212]	; (5fd4 <sd_mmc_select_slot+0xfc>)
    5f00:	01db      	lsls	r3, r3, #7
    5f02:	18ca      	adds	r2, r1, r3
    5f04:	58c9      	ldr	r1, [r1, r3]
	return tmp;
}

static inline hri_port_in_reg_t hri_port_read_IN_reg(const void *const hw, uint8_t submodule_index)
{
	return ((Port *)hw)->Group[submodule_index].IN.reg;
    5f06:	6a13      	ldr	r3, [r2, #32]
	return ((Port *)hw)->Group[submodule_index].OUT.reg;
    5f08:	6914      	ldr	r4, [r2, #16]

	uint32_t dir_tmp = hri_port_read_DIR_reg(PORT, port);

	tmp = hri_port_read_IN_reg(PORT, port) & ~dir_tmp;
	tmp |= hri_port_read_OUT_reg(PORT, port) & dir_tmp;
    5f0a:	405c      	eors	r4, r3
    5f0c:	400c      	ands	r4, r1
    5f0e:	405c      	eors	r4, r3

	CRITICAL_SECTION_LEAVE();
    5f10:	a801      	add	r0, sp, #4
    5f12:	4b31      	ldr	r3, [pc, #196]	; (5fd8 <sd_mmc_select_slot+0x100>)
    5f14:	4798      	blx	r3
 *
 * \param[in] pin       The pin number for device
 */
static inline bool gpio_get_pin_level(const uint8_t pin)
{
	return (bool)(_gpio_get_level((enum gpio_port)GPIO_PORT(pin)) & (0x01U << GPIO_PIN(pin)));
    5f16:	f005 031f 	and.w	r3, r5, #31
    5f1a:	2201      	movs	r2, #1
    5f1c:	fa02 f303 	lsl.w	r3, r2, r3
    5f20:	4223      	tst	r3, r4
    5f22:	bf08      	it	eq
    5f24:	2200      	moveq	r2, #0
    5f26:	4b29      	ldr	r3, [pc, #164]	; (5fcc <sd_mmc_select_slot+0xf4>)
    5f28:	68db      	ldr	r3, [r3, #12]
    5f2a:	885b      	ldrh	r3, [r3, #2]
    5f2c:	429a      	cmp	r2, r3
    5f2e:	d004      	beq.n	5f3a <sd_mmc_select_slot+0x62>
			sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_NO_CARD;
    5f30:	2204      	movs	r2, #4
    5f32:	4b26      	ldr	r3, [pc, #152]	; (5fcc <sd_mmc_select_slot+0xf4>)
    5f34:	769a      	strb	r2, [r3, #26]
			return SD_MMC_ERR_NO_CARD;
    5f36:	2002      	movs	r0, #2
    5f38:	e039      	b.n	5fae <sd_mmc_select_slot+0xd6>
		if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_NO_CARD) {
    5f3a:	4b24      	ldr	r3, [pc, #144]	; (5fcc <sd_mmc_select_slot+0xf4>)
    5f3c:	7e9b      	ldrb	r3, [r3, #26]
    5f3e:	2b04      	cmp	r3, #4
    5f40:	d005      	beq.n	5f4e <sd_mmc_select_slot+0x76>
		if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_DEBOUNCE) {
    5f42:	2b01      	cmp	r3, #1
    5f44:	d008      	beq.n	5f58 <sd_mmc_select_slot+0x80>
		if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_UNUSABLE) {
    5f46:	2b03      	cmp	r3, #3
    5f48:	d117      	bne.n	5f7a <sd_mmc_select_slot+0xa2>
			return SD_MMC_ERR_UNUSABLE;
    5f4a:	2003      	movs	r0, #3
    5f4c:	e02f      	b.n	5fae <sd_mmc_select_slot+0xd6>
			sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_DEBOUNCE;
    5f4e:	2201      	movs	r2, #1
    5f50:	4b1e      	ldr	r3, [pc, #120]	; (5fcc <sd_mmc_select_slot+0xf4>)
    5f52:	769a      	strb	r2, [r3, #26]
			return SD_MMC_ERR_NO_CARD;
    5f54:	2002      	movs	r0, #2
    5f56:	e02a      	b.n	5fae <sd_mmc_select_slot+0xd6>
			sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_INIT;
    5f58:	4b1c      	ldr	r3, [pc, #112]	; (5fcc <sd_mmc_select_slot+0xf4>)
    5f5a:	2202      	movs	r2, #2
    5f5c:	769a      	strb	r2, [r3, #26]
			sd_mmc_cards[slot].clock      = SDMMC_CLOCK_INIT;
    5f5e:	4a1f      	ldr	r2, [pc, #124]	; (5fdc <sd_mmc_select_slot+0x104>)
    5f60:	611a      	str	r2, [r3, #16]
			sd_mmc_cards[slot].bus_width  = 1;
    5f62:	2201      	movs	r2, #1
    5f64:	775a      	strb	r2, [r3, #29]
			sd_mmc_cards[slot].high_speed = 0;
    5f66:	2200      	movs	r2, #0
    5f68:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
    5f6c:	e005      	b.n	5f7a <sd_mmc_select_slot+0xa2>
		if ((sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_NO_CARD)
    5f6e:	4b17      	ldr	r3, [pc, #92]	; (5fcc <sd_mmc_select_slot+0xf4>)
		    || (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_UNUSABLE)) {
    5f70:	7e9b      	ldrb	r3, [r3, #26]
    5f72:	3b03      	subs	r3, #3
		if ((sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_NO_CARD)
    5f74:	b2db      	uxtb	r3, r3
    5f76:	2b01      	cmp	r3, #1
    5f78:	d91b      	bls.n	5fb2 <sd_mmc_select_slot+0xda>
	ASSERT(!(sd_mmc_slot_sel != slot && sd_mmc_nb_block_remaining != 0));
    5f7a:	4b14      	ldr	r3, [pc, #80]	; (5fcc <sd_mmc_select_slot+0xf4>)
    5f7c:	791b      	ldrb	r3, [r3, #4]
    5f7e:	b31b      	cbz	r3, 5fc8 <sd_mmc_select_slot+0xf0>
    5f80:	4b12      	ldr	r3, [pc, #72]	; (5fcc <sd_mmc_select_slot+0xf4>)
    5f82:	8e18      	ldrh	r0, [r3, #48]	; 0x30
    5f84:	fab0 f080 	clz	r0, r0
    5f88:	0940      	lsrs	r0, r0, #5
    5f8a:	f240 423a 	movw	r2, #1082	; 0x43a
    5f8e:	4914      	ldr	r1, [pc, #80]	; (5fe0 <sd_mmc_select_slot+0x108>)
    5f90:	4b14      	ldr	r3, [pc, #80]	; (5fe4 <sd_mmc_select_slot+0x10c>)
    5f92:	4798      	blx	r3
	sd_mmc_slot_sel = slot;
    5f94:	4c0d      	ldr	r4, [pc, #52]	; (5fcc <sd_mmc_select_slot+0xf4>)
    5f96:	2300      	movs	r3, #0
    5f98:	7123      	strb	r3, [r4, #4]
	sd_mmc_card     = &sd_mmc_cards[slot];
    5f9a:	f104 0310 	add.w	r3, r4, #16
    5f9e:	6023      	str	r3, [r4, #0]
	sd_mmc_configure_slot();
    5fa0:	4b11      	ldr	r3, [pc, #68]	; (5fe8 <sd_mmc_select_slot+0x110>)
    5fa2:	4798      	blx	r3
	return (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_INIT) ? SD_MMC_INIT_ONGOING : SD_MMC_OK;
    5fa4:	7ea0      	ldrb	r0, [r4, #26]
    5fa6:	2802      	cmp	r0, #2
    5fa8:	bf14      	ite	ne
    5faa:	2000      	movne	r0, #0
    5fac:	2001      	moveq	r0, #1
}
    5fae:	b003      	add	sp, #12
    5fb0:	bd30      	pop	{r4, r5, pc}
			sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_INIT;
    5fb2:	4b06      	ldr	r3, [pc, #24]	; (5fcc <sd_mmc_select_slot+0xf4>)
    5fb4:	2202      	movs	r2, #2
    5fb6:	769a      	strb	r2, [r3, #26]
			sd_mmc_cards[slot].clock      = SDMMC_CLOCK_INIT;
    5fb8:	4a08      	ldr	r2, [pc, #32]	; (5fdc <sd_mmc_select_slot+0x104>)
    5fba:	611a      	str	r2, [r3, #16]
			sd_mmc_cards[slot].bus_width  = 1;
    5fbc:	2201      	movs	r2, #1
    5fbe:	775a      	strb	r2, [r3, #29]
			sd_mmc_cards[slot].high_speed = 0;
    5fc0:	2200      	movs	r2, #0
    5fc2:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
    5fc6:	e7d8      	b.n	5f7a <sd_mmc_select_slot+0xa2>
    5fc8:	2001      	movs	r0, #1
    5fca:	e7de      	b.n	5f8a <sd_mmc_select_slot+0xb2>
    5fcc:	20000620 	.word	0x20000620
    5fd0:	00002221 	.word	0x00002221
    5fd4:	41008000 	.word	0x41008000
    5fd8:	0000222f 	.word	0x0000222f
    5fdc:	00061a80 	.word	0x00061a80
    5fe0:	00009a50 	.word	0x00009a50
    5fe4:	00003205 	.word	0x00003205
    5fe8:	00005ead 	.word	0x00005ead

00005fec <sdio_cmd52>:
{
    5fec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    5ff0:	4606      	mov	r6, r0
    5ff2:	460f      	mov	r7, r1
    5ff4:	4614      	mov	r4, r2
    5ff6:	4698      	mov	r8, r3
    5ff8:	9d06      	ldr	r5, [sp, #24]
	ASSERT(io_data != NULL);
    5ffa:	f240 3282 	movw	r2, #898	; 0x382
    5ffe:	4910      	ldr	r1, [pc, #64]	; (6040 <sdio_cmd52+0x54>)
    6000:	1c28      	adds	r0, r5, #0
    6002:	bf18      	it	ne
    6004:	2001      	movne	r0, #1
    6006:	4b0f      	ldr	r3, [pc, #60]	; (6044 <sdio_cmd52+0x58>)
    6008:	4798      	blx	r3
	                         | ((uint32_t)reg_addr << SDIO_CMD52_REG_ADRR))) {
    600a:	0260      	lsls	r0, r4, #9
	if (!driver_send_cmd(sd_mmc_hal,
    600c:	ea40 60c8 	orr.w	r0, r0, r8, lsl #27
    6010:	ea40 7007 	orr.w	r0, r0, r7, lsl #28
    6014:	ea40 70c6 	orr.w	r0, r0, r6, lsl #31
	                     ((uint32_t)*io_data << SDIO_CMD52_WR_DATA) | ((uint32_t)rw_flag << SDIO_CMD52_RW_FLAG)
    6018:	782a      	ldrb	r2, [r5, #0]
	if (!driver_send_cmd(sd_mmc_hal,
    601a:	4302      	orrs	r2, r0
    601c:	f241 3134 	movw	r1, #4916	; 0x1334
    6020:	4b09      	ldr	r3, [pc, #36]	; (6048 <sdio_cmd52+0x5c>)
    6022:	6898      	ldr	r0, [r3, #8]
    6024:	4b09      	ldr	r3, [pc, #36]	; (604c <sdio_cmd52+0x60>)
    6026:	4798      	blx	r3
    6028:	4604      	mov	r4, r0
    602a:	b910      	cbnz	r0, 6032 <sdio_cmd52+0x46>
}
    602c:	4620      	mov	r0, r4
    602e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	*io_data = driver_get_response(sd_mmc_hal) & 0xFF;
    6032:	4b05      	ldr	r3, [pc, #20]	; (6048 <sdio_cmd52+0x5c>)
    6034:	6898      	ldr	r0, [r3, #8]
    6036:	4b06      	ldr	r3, [pc, #24]	; (6050 <sdio_cmd52+0x64>)
    6038:	4798      	blx	r3
    603a:	7028      	strb	r0, [r5, #0]
	return true;
    603c:	e7f6      	b.n	602c <sdio_cmd52+0x40>
    603e:	bf00      	nop
    6040:	00009a50 	.word	0x00009a50
    6044:	00003205 	.word	0x00003205
    6048:	20000620 	.word	0x20000620
    604c:	000026b5 	.word	0x000026b5
    6050:	000026e5 	.word	0x000026e5

00006054 <sd_mmc_deselect_slot>:

/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
    6054:	b508      	push	{r3, lr}
	if (sd_mmc_slot_sel < CONF_SD_MMC_MEM_CNT) {
    6056:	4b05      	ldr	r3, [pc, #20]	; (606c <sd_mmc_deselect_slot+0x18>)
    6058:	791b      	ldrb	r3, [r3, #4]
    605a:	b103      	cbz	r3, 605e <sd_mmc_deselect_slot+0xa>
    605c:	bd08      	pop	{r3, pc}
		driver_deselect_device(sd_mmc_hal, sd_mmc_slot_sel);
    605e:	2100      	movs	r1, #0
    6060:	4b02      	ldr	r3, [pc, #8]	; (606c <sd_mmc_deselect_slot+0x18>)
    6062:	6898      	ldr	r0, [r3, #8]
    6064:	4b02      	ldr	r3, [pc, #8]	; (6070 <sd_mmc_deselect_slot+0x1c>)
    6066:	4798      	blx	r3
	}
}
    6068:	e7f8      	b.n	605c <sd_mmc_deselect_slot+0x8>
    606a:	bf00      	nop
    606c:	20000620 	.word	0x20000620
    6070:	0000260d 	.word	0x0000260d

00006074 <sd_mmc_init>:
#endif

/*--------------------- PUBLIC FUNCTIONS ----------------------------*/

void sd_mmc_init(void *hal, sd_mmc_detect_t *card_detects, sd_mmc_detect_t *wp_detects)
{
    6074:	b410      	push	{r4}
	/* GPIO will be used to detect card and write protect.
	 * The related clocks and pinmux must be configurated in good
	 * condition. */

	for (uint8_t slot = 0; slot < CONF_SD_MMC_MEM_CNT; slot++) {
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_NO_CARD;
    6076:	4b05      	ldr	r3, [pc, #20]	; (608c <sd_mmc_init+0x18>)
    6078:	2404      	movs	r4, #4
    607a:	769c      	strb	r4, [r3, #26]
	}
	sd_mmc_slot_sel = 0xFF; /* No slot configurated */
    607c:	24ff      	movs	r4, #255	; 0xff
    607e:	711c      	strb	r4, [r3, #4]
	sd_mmc_hal      = hal;
    6080:	6098      	str	r0, [r3, #8]
	_cd             = card_detects;
    6082:	60d9      	str	r1, [r3, #12]
	_wp             = wp_detects;
    6084:	635a      	str	r2, [r3, #52]	; 0x34
}
    6086:	f85d 4b04 	ldr.w	r4, [sp], #4
    608a:	4770      	bx	lr
    608c:	20000620 	.word	0x20000620

00006090 <sd_mmc_check>:
{
	return CONF_SD_MMC_MEM_CNT;
}

sd_mmc_err_t sd_mmc_check(uint8_t slot)
{
    6090:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    6094:	b095      	sub	sp, #84	; 0x54
	sd_mmc_err_t sd_mmc_err;

	sd_mmc_err = sd_mmc_select_slot(slot);
    6096:	4baa      	ldr	r3, [pc, #680]	; (6340 <sd_mmc_check+0x2b0>)
    6098:	4798      	blx	r3
    609a:	4604      	mov	r4, r0
	if (sd_mmc_err != SD_MMC_INIT_ONGOING) {
    609c:	2801      	cmp	r0, #1
    609e:	d005      	beq.n	60ac <sd_mmc_check+0x1c>
		sd_mmc_deselect_slot();
    60a0:	4ba8      	ldr	r3, [pc, #672]	; (6344 <sd_mmc_check+0x2b4>)
    60a2:	4798      	blx	r3
		return SD_MMC_INIT_ONGOING;
	}
	sd_mmc_card->state = SD_MMC_CARD_STATE_UNUSABLE;
	sd_mmc_deselect_slot();
	return SD_MMC_ERR_UNUSABLE;
}
    60a4:	4620      	mov	r0, r4
    60a6:	b015      	add	sp, #84	; 0x54
    60a8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	uint8_t data = 0x08;
    60ac:	af14      	add	r7, sp, #80	; 0x50
    60ae:	2308      	movs	r3, #8
    60b0:	f807 3d45 	strb.w	r3, [r7, #-69]!
	sd_mmc_card->type    = CARD_TYPE_SD;
    60b4:	4ea4      	ldr	r6, [pc, #656]	; (6348 <sd_mmc_check+0x2b8>)
    60b6:	6833      	ldr	r3, [r6, #0]
    60b8:	f04f 0801 	mov.w	r8, #1
    60bc:	f883 800b 	strb.w	r8, [r3, #11]
	sd_mmc_card->version = CARD_VER_UNKNOWN;
    60c0:	2500      	movs	r5, #0
    60c2:	731d      	strb	r5, [r3, #12]
	sd_mmc_card->rca     = 0;
    60c4:	811d      	strh	r5, [r3, #8]
	driver_send_clock(sd_mmc_hal);
    60c6:	68b0      	ldr	r0, [r6, #8]
    60c8:	4ba0      	ldr	r3, [pc, #640]	; (634c <sd_mmc_check+0x2bc>)
    60ca:	4798      	blx	r3
	sdio_cmd52(SDIO_CMD52_WRITE_FLAG, SDIO_CIA, SDIO_CCCR_IOA, 0, &data);
    60cc:	9700      	str	r7, [sp, #0]
    60ce:	462b      	mov	r3, r5
    60d0:	2206      	movs	r2, #6
    60d2:	4629      	mov	r1, r5
    60d4:	4640      	mov	r0, r8
    60d6:	4f9e      	ldr	r7, [pc, #632]	; (6350 <sd_mmc_check+0x2c0>)
    60d8:	47b8      	blx	r7
	if (!driver_send_cmd(sd_mmc_hal, SDMMC_MCI_CMD0_GO_IDLE_STATE, 0)) {
    60da:	462a      	mov	r2, r5
    60dc:	f44f 4180 	mov.w	r1, #16384	; 0x4000
    60e0:	68b0      	ldr	r0, [r6, #8]
    60e2:	4b9c      	ldr	r3, [pc, #624]	; (6354 <sd_mmc_check+0x2c4>)
    60e4:	4798      	blx	r3
    60e6:	b930      	cbnz	r0, 60f6 <sd_mmc_check+0x66>
	sd_mmc_card->state = SD_MMC_CARD_STATE_UNUSABLE;
    60e8:	4b97      	ldr	r3, [pc, #604]	; (6348 <sd_mmc_check+0x2b8>)
    60ea:	681b      	ldr	r3, [r3, #0]
    60ec:	2403      	movs	r4, #3
    60ee:	729c      	strb	r4, [r3, #10]
	sd_mmc_deselect_slot();
    60f0:	4b94      	ldr	r3, [pc, #592]	; (6344 <sd_mmc_check+0x2b4>)
    60f2:	4798      	blx	r3
	return SD_MMC_ERR_UNUSABLE;
    60f4:	e7d6      	b.n	60a4 <sd_mmc_check+0x14>
	if (!driver_send_cmd(sd_mmc_hal, SD_CMD8_SEND_IF_COND, SD_CMD8_PATTERN | SD_CMD8_HIGH_VOLTAGE)) {
    60f6:	f44f 72d5 	mov.w	r2, #426	; 0x1aa
    60fa:	f245 5108 	movw	r1, #21768	; 0x5508
    60fe:	68b0      	ldr	r0, [r6, #8]
    6100:	4b94      	ldr	r3, [pc, #592]	; (6354 <sd_mmc_check+0x2c4>)
    6102:	4798      	blx	r3
    6104:	2800      	cmp	r0, #0
    6106:	f040 80a4 	bne.w	6252 <sd_mmc_check+0x1c2>
	*v2 = 0;
    610a:	f04f 0800 	mov.w	r8, #0
	if (!driver_send_cmd(sd_mmc_hal, SDIO_CMD5_SEND_OP_COND, 0)) {
    610e:	2200      	movs	r2, #0
    6110:	f244 5105 	movw	r1, #17669	; 0x4505
    6114:	4b8c      	ldr	r3, [pc, #560]	; (6348 <sd_mmc_check+0x2b8>)
    6116:	6898      	ldr	r0, [r3, #8]
    6118:	4b8e      	ldr	r3, [pc, #568]	; (6354 <sd_mmc_check+0x2c4>)
    611a:	4798      	blx	r3
    611c:	2800      	cmp	r0, #0
    611e:	f040 80a6 	bne.w	626e <sd_mmc_check+0x1de>
	if (sd_mmc_card->type & CARD_TYPE_SD) {
    6122:	4b89      	ldr	r3, [pc, #548]	; (6348 <sd_mmc_check+0x2b8>)
    6124:	681b      	ldr	r3, [r3, #0]
    6126:	7adb      	ldrb	r3, [r3, #11]
    6128:	f013 0f01 	tst.w	r3, #1
    612c:	f040 80c9 	bne.w	62c2 <sd_mmc_check+0x232>
	if (!driver_send_cmd(sd_mmc_hal, SD_CMD3_SEND_RELATIVE_ADDR, 0)) {
    6130:	2200      	movs	r2, #0
    6132:	f245 1103 	movw	r1, #20739	; 0x5103
    6136:	4b84      	ldr	r3, [pc, #528]	; (6348 <sd_mmc_check+0x2b8>)
    6138:	6898      	ldr	r0, [r3, #8]
    613a:	4b86      	ldr	r3, [pc, #536]	; (6354 <sd_mmc_check+0x2c4>)
    613c:	4798      	blx	r3
    613e:	2800      	cmp	r0, #0
    6140:	d0d2      	beq.n	60e8 <sd_mmc_check+0x58>
	sd_mmc_card->rca = (driver_get_response(sd_mmc_hal) >> 16) & 0xFFFF;
    6142:	4d81      	ldr	r5, [pc, #516]	; (6348 <sd_mmc_check+0x2b8>)
    6144:	682e      	ldr	r6, [r5, #0]
    6146:	68a8      	ldr	r0, [r5, #8]
    6148:	4b83      	ldr	r3, [pc, #524]	; (6358 <sd_mmc_check+0x2c8>)
    614a:	4798      	blx	r3
    614c:	0c00      	lsrs	r0, r0, #16
    614e:	8130      	strh	r0, [r6, #8]
	if (sd_mmc_card->type & CARD_TYPE_SD) {
    6150:	682b      	ldr	r3, [r5, #0]
    6152:	7ada      	ldrb	r2, [r3, #11]
    6154:	f012 0f01 	tst.w	r2, #1
    6158:	d03e      	beq.n	61d8 <sd_mmc_check+0x148>
	if (!driver_send_cmd(sd_mmc_hal, SDMMC_MCI_CMD9_SEND_CSD, (uint32_t)sd_mmc_card->rca << 16)) {
    615a:	891a      	ldrh	r2, [r3, #8]
    615c:	0412      	lsls	r2, r2, #16
    615e:	f641 3109 	movw	r1, #6921	; 0x1b09
    6162:	68a8      	ldr	r0, [r5, #8]
    6164:	4b7b      	ldr	r3, [pc, #492]	; (6354 <sd_mmc_check+0x2c4>)
    6166:	4798      	blx	r3
    6168:	2800      	cmp	r0, #0
    616a:	d0bd      	beq.n	60e8 <sd_mmc_check+0x58>
	driver_get_response_128(sd_mmc_hal, sd_mmc_card->csd);
    616c:	6829      	ldr	r1, [r5, #0]
    616e:	310e      	adds	r1, #14
    6170:	68a8      	ldr	r0, [r5, #8]
    6172:	4b7a      	ldr	r3, [pc, #488]	; (635c <sd_mmc_check+0x2cc>)
    6174:	4798      	blx	r3
	tran_speed         = CSD_TRAN_SPEED(sd_mmc_card->csd);
    6176:	682a      	ldr	r2, [r5, #0]
 * Used by : CSD, SCR, Switch status
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size, uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
    6178:	7c51      	ldrb	r1, [r2, #17]
	unit               = sd_mmc_trans_units[tran_speed & 0x7];
    617a:	4b79      	ldr	r3, [pc, #484]	; (6360 <sd_mmc_check+0x2d0>)
    617c:	f001 0007 	and.w	r0, r1, #7
	sd_mmc_card->clock = unit * mul * 1000;
    6180:	f853 5020 	ldr.w	r5, [r3, r0, lsl #2]
    6184:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    6188:	fb00 f005 	mul.w	r0, r0, r5
	mul                = sd_trans_multipliers[(tran_speed >> 3) & 0xF];
    618c:	f3c1 01c3 	ubfx	r1, r1, #3, #4
    6190:	eb03 0381 	add.w	r3, r3, r1, lsl #2
	sd_mmc_card->clock = unit * mul * 1000;
    6194:	69db      	ldr	r3, [r3, #28]
    6196:	fb03 f300 	mul.w	r3, r3, r0
    619a:	6013      	str	r3, [r2, #0]
	if (CSD_STRUCTURE_VERSION(sd_mmc_card->csd) >= SD_CSD_VER_2_0) {
    619c:	7b93      	ldrb	r3, [r2, #14]
    619e:	099b      	lsrs	r3, r3, #6
    61a0:	f040 80e2 	bne.w	6368 <sd_mmc_check+0x2d8>
    61a4:	7d91      	ldrb	r1, [r2, #22]
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
    61a6:	7d50      	ldrb	r0, [r2, #21]
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
    61a8:	7d13      	ldrb	r3, [r2, #20]
    61aa:	029b      	lsls	r3, r3, #10
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
    61ac:	ea43 0380 	orr.w	r3, r3, r0, lsl #2
    61b0:	ea43 13a1 	orr.w	r3, r3, r1, asr #6
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
    61b4:	7e10      	ldrb	r0, [r2, #24]
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
    61b6:	7dd1      	ldrb	r1, [r2, #23]
    61b8:	0049      	lsls	r1, r1, #1
    61ba:	ea41 11e0 	orr.w	r1, r1, r0, asr #7
	}
	value &= ((uint32_t)1 << size) - 1;
    61be:	f3c3 030b 	ubfx	r3, r3, #0, #12
		    = ((SD_CSD_1_0_C_SIZE(sd_mmc_card->csd) + 1) * (1 << (SD_CSD_1_0_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
    61c2:	3301      	adds	r3, #1
    61c4:	f001 0107 	and.w	r1, r1, #7
    61c8:	3102      	adds	r1, #2
		uint32_t blocknr
    61ca:	408b      	lsls	r3, r1
    61cc:	7cd1      	ldrb	r1, [r2, #19]
    61ce:	f001 010f 	and.w	r1, r1, #15
		sd_mmc_card->capacity = blocknr * (1 << SD_CSD_1_0_READ_BL_LEN(sd_mmc_card->csd)) / 1024;
    61d2:	408b      	lsls	r3, r1
    61d4:	0a9b      	lsrs	r3, r3, #10
    61d6:	6053      	str	r3, [r2, #4]
	if (!driver_send_cmd(sd_mmc_hal, SDMMC_CMD7_SELECT_CARD_CMD, (uint32_t)sd_mmc_card->rca << 16)) {
    61d8:	4b5b      	ldr	r3, [pc, #364]	; (6348 <sd_mmc_check+0x2b8>)
    61da:	681a      	ldr	r2, [r3, #0]
    61dc:	8912      	ldrh	r2, [r2, #8]
    61de:	0412      	lsls	r2, r2, #16
    61e0:	f243 1107 	movw	r1, #12551	; 0x3107
    61e4:	6898      	ldr	r0, [r3, #8]
    61e6:	4b5b      	ldr	r3, [pc, #364]	; (6354 <sd_mmc_check+0x2c4>)
    61e8:	4798      	blx	r3
    61ea:	2800      	cmp	r0, #0
    61ec:	f43f af7c 	beq.w	60e8 <sd_mmc_check+0x58>
	if (sd_mmc_card->type & CARD_TYPE_SD) {
    61f0:	4b55      	ldr	r3, [pc, #340]	; (6348 <sd_mmc_check+0x2b8>)
    61f2:	681b      	ldr	r3, [r3, #0]
    61f4:	7ada      	ldrb	r2, [r3, #11]
    61f6:	f012 0f01 	tst.w	r2, #1
    61fa:	f040 80c2 	bne.w	6382 <sd_mmc_check+0x2f2>
	if (IS_SDIO()) {
    61fe:	4b52      	ldr	r3, [pc, #328]	; (6348 <sd_mmc_check+0x2b8>)
    6200:	681b      	ldr	r3, [r3, #0]
    6202:	7adb      	ldrb	r3, [r3, #11]
    6204:	f013 0f04 	tst.w	r3, #4
    6208:	f000 8152 	beq.w	64b0 <sd_mmc_check+0x420>
    620c:	2509      	movs	r5, #9
		sdio_cmd52(SDIO_CMD52_READ_FLAG, SDIO_CIA, addr_old, 0, &addr_cis[i]);
    620e:	2700      	movs	r7, #0
    6210:	4e4f      	ldr	r6, [pc, #316]	; (6350 <sd_mmc_check+0x2c0>)
    6212:	f1a5 0309 	sub.w	r3, r5, #9
    6216:	aa03      	add	r2, sp, #12
    6218:	4413      	add	r3, r2
    621a:	9300      	str	r3, [sp, #0]
    621c:	463b      	mov	r3, r7
    621e:	462a      	mov	r2, r5
    6220:	4639      	mov	r1, r7
    6222:	4638      	mov	r0, r7
    6224:	47b0      	blx	r6
		addr_old++;
    6226:	3501      	adds	r5, #1
	for (i = 0; i < 4; i++) {
    6228:	2d0d      	cmp	r5, #13
    622a:	d1f2      	bne.n	6212 <sd_mmc_check+0x182>
	addr_old = addr_cis[0] + (addr_cis[1] << 8) + (addr_cis[2] << 16) + (addr_cis[3] << 24);
    622c:	f89d 300d 	ldrb.w	r3, [sp, #13]
    6230:	f89d 900c 	ldrb.w	r9, [sp, #12]
    6234:	eb09 2903 	add.w	r9, r9, r3, lsl #8
    6238:	f89d 300e 	ldrb.w	r3, [sp, #14]
    623c:	eb09 4903 	add.w	r9, r9, r3, lsl #16
    6240:	f89d 300f 	ldrb.w	r3, [sp, #15]
    6244:	eb09 6903 	add.w	r9, r9, r3, lsl #24
	addr_new = addr_old;
    6248:	464e      	mov	r6, r9
			sdio_cmd52(SDIO_CMD52_READ_FLAG, SDIO_CIA, addr_new, 0, &buf[i]);
    624a:	f04f 0800 	mov.w	r8, #0
    624e:	4f40      	ldr	r7, [pc, #256]	; (6350 <sd_mmc_check+0x2c0>)
    6250:	e0ed      	b.n	642e <sd_mmc_check+0x39e>
	resp = driver_get_response(sd_mmc_hal);
    6252:	68b0      	ldr	r0, [r6, #8]
    6254:	4b40      	ldr	r3, [pc, #256]	; (6358 <sd_mmc_check+0x2c8>)
    6256:	4798      	blx	r3
	if (resp == 0xFFFFFFFF) {
    6258:	f1b0 3fff 	cmp.w	r0, #4294967295
    625c:	f000 8227 	beq.w	66ae <sd_mmc_check+0x61e>
	if ((resp & (SD_CMD8_MASK_PATTERN | SD_CMD8_MASK_VOLTAGE)) != (SD_CMD8_PATTERN | SD_CMD8_HIGH_VOLTAGE)) {
    6260:	f3c0 000b 	ubfx	r0, r0, #0, #12
    6264:	f5b0 7fd5 	cmp.w	r0, #426	; 0x1aa
    6268:	f47f af3e 	bne.w	60e8 <sd_mmc_check+0x58>
    626c:	e74f      	b.n	610e <sd_mmc_check+0x7e>
	resp = driver_get_response(sd_mmc_hal);
    626e:	4b36      	ldr	r3, [pc, #216]	; (6348 <sd_mmc_check+0x2b8>)
    6270:	6898      	ldr	r0, [r3, #8]
    6272:	4b39      	ldr	r3, [pc, #228]	; (6358 <sd_mmc_check+0x2c8>)
    6274:	4798      	blx	r3
	if ((resp & OCR_SDIO_NF) == 0) {
    6276:	f010 4fe0 	tst.w	r0, #1879048192	; 0x70000000
    627a:	f43f af52 	beq.w	6122 <sd_mmc_check+0x92>
    627e:	f241 3589 	movw	r5, #5001	; 0x1389
		if (!driver_send_cmd(sd_mmc_hal, SDIO_CMD5_SEND_OP_COND, resp & SD_MMC_VOLTAGE_SUPPORT)) {
    6282:	4e31      	ldr	r6, [pc, #196]	; (6348 <sd_mmc_check+0x2b8>)
    6284:	4f33      	ldr	r7, [pc, #204]	; (6354 <sd_mmc_check+0x2c4>)
		resp = driver_get_response(sd_mmc_hal);
    6286:	f8df 90d0 	ldr.w	r9, [pc, #208]	; 6358 <sd_mmc_check+0x2c8>
		if (!driver_send_cmd(sd_mmc_hal, SDIO_CMD5_SEND_OP_COND, resp & SD_MMC_VOLTAGE_SUPPORT)) {
    628a:	f400 12fc 	and.w	r2, r0, #2064384	; 0x1f8000
    628e:	f244 5105 	movw	r1, #17669	; 0x4505
    6292:	68b0      	ldr	r0, [r6, #8]
    6294:	47b8      	blx	r7
    6296:	2800      	cmp	r0, #0
    6298:	f43f af26 	beq.w	60e8 <sd_mmc_check+0x58>
		resp = driver_get_response(sd_mmc_hal);
    629c:	68b0      	ldr	r0, [r6, #8]
    629e:	47c8      	blx	r9
		if ((resp & OCR_POWER_UP_BUSY) == OCR_POWER_UP_BUSY) {
    62a0:	2800      	cmp	r0, #0
    62a2:	db02      	blt.n	62aa <sd_mmc_check+0x21a>
		if (cmd5_retry-- == 0) {
    62a4:	3d01      	subs	r5, #1
    62a6:	d1f0      	bne.n	628a <sd_mmc_check+0x1fa>
    62a8:	e71e      	b.n	60e8 <sd_mmc_check+0x58>
	if ((resp & OCR_SDIO_MP) > 0) {
    62aa:	f010 6f00 	tst.w	r0, #134217728	; 0x8000000
    62ae:	d104      	bne.n	62ba <sd_mmc_check+0x22a>
		sd_mmc_card->type = CARD_TYPE_SDIO;
    62b0:	4b25      	ldr	r3, [pc, #148]	; (6348 <sd_mmc_check+0x2b8>)
    62b2:	681b      	ldr	r3, [r3, #0]
    62b4:	2204      	movs	r2, #4
    62b6:	72da      	strb	r2, [r3, #11]
    62b8:	e73a      	b.n	6130 <sd_mmc_check+0xa0>
		sd_mmc_card->type = CARD_TYPE_SD_COMBO;
    62ba:	4b23      	ldr	r3, [pc, #140]	; (6348 <sd_mmc_check+0x2b8>)
    62bc:	681b      	ldr	r3, [r3, #0]
    62be:	2205      	movs	r2, #5
    62c0:	72da      	strb	r2, [r3, #11]
    62c2:	f1b8 0f00 	cmp.w	r8, #0
    62c6:	4b27      	ldr	r3, [pc, #156]	; (6364 <sd_mmc_check+0x2d4>)
    62c8:	bf14      	ite	ne
    62ca:	4698      	movne	r8, r3
    62cc:	f44f 18fc 	moveq.w	r8, #2064384	; 0x1f8000
	if ((resp & OCR_SDIO_NF) == 0) {
    62d0:	f640 0635 	movw	r6, #2101	; 0x835
		if (!driver_send_cmd(sd_mmc_hal, SDMMC_CMD55_APP_CMD, 0)) {
    62d4:	4d1c      	ldr	r5, [pc, #112]	; (6348 <sd_mmc_check+0x2b8>)
    62d6:	4f1f      	ldr	r7, [pc, #124]	; (6354 <sd_mmc_check+0x2c4>)
		resp = driver_get_response(sd_mmc_hal);
    62d8:	f8df 907c 	ldr.w	r9, [pc, #124]	; 6358 <sd_mmc_check+0x2c8>
		if (!driver_send_cmd(sd_mmc_hal, SDMMC_CMD55_APP_CMD, 0)) {
    62dc:	2200      	movs	r2, #0
    62de:	f241 1137 	movw	r1, #4407	; 0x1137
    62e2:	68a8      	ldr	r0, [r5, #8]
    62e4:	47b8      	blx	r7
    62e6:	b158      	cbz	r0, 6300 <sd_mmc_check+0x270>
		if (!driver_send_cmd(sd_mmc_hal, SD_MCI_ACMD41_SD_SEND_OP_COND, arg)) {
    62e8:	4642      	mov	r2, r8
    62ea:	f244 5129 	movw	r1, #17705	; 0x4529
    62ee:	68a8      	ldr	r0, [r5, #8]
    62f0:	47b8      	blx	r7
    62f2:	b128      	cbz	r0, 6300 <sd_mmc_check+0x270>
		resp = driver_get_response(sd_mmc_hal);
    62f4:	68a8      	ldr	r0, [r5, #8]
    62f6:	47c8      	blx	r9
		if (resp & OCR_POWER_UP_BUSY) {
    62f8:	2800      	cmp	r0, #0
    62fa:	db06      	blt.n	630a <sd_mmc_check+0x27a>
		if (retry-- == 0) {
    62fc:	3e01      	subs	r6, #1
    62fe:	d1ed      	bne.n	62dc <sd_mmc_check+0x24c>
			sd_mmc_card->type = CARD_TYPE_UNKNOWN;
    6300:	4b11      	ldr	r3, [pc, #68]	; (6348 <sd_mmc_check+0x2b8>)
    6302:	681b      	ldr	r3, [r3, #0]
    6304:	2200      	movs	r2, #0
    6306:	72da      	strb	r2, [r3, #11]
    6308:	e6ee      	b.n	60e8 <sd_mmc_check+0x58>
			if ((resp & OCR_CCS) != 0) {
    630a:	f010 4f80 	tst.w	r0, #1073741824	; 0x40000000
    630e:	d005      	beq.n	631c <sd_mmc_check+0x28c>
				sd_mmc_card->type |= CARD_TYPE_HC;
    6310:	4b0d      	ldr	r3, [pc, #52]	; (6348 <sd_mmc_check+0x2b8>)
    6312:	681a      	ldr	r2, [r3, #0]
    6314:	7ad3      	ldrb	r3, [r2, #11]
    6316:	f043 0308 	orr.w	r3, r3, #8
    631a:	72d3      	strb	r3, [r2, #11]
	if (sd_mmc_card->type & CARD_TYPE_SD) {
    631c:	4b0a      	ldr	r3, [pc, #40]	; (6348 <sd_mmc_check+0x2b8>)
    631e:	681b      	ldr	r3, [r3, #0]
    6320:	7adb      	ldrb	r3, [r3, #11]
    6322:	f013 0f01 	tst.w	r3, #1
    6326:	f43f af03 	beq.w	6130 <sd_mmc_check+0xa0>
		if (!driver_send_cmd(sd_mmc_hal, SDMMC_CMD2_ALL_SEND_CID, 0)) {
    632a:	2200      	movs	r2, #0
    632c:	f645 3102 	movw	r1, #23298	; 0x5b02
    6330:	4b05      	ldr	r3, [pc, #20]	; (6348 <sd_mmc_check+0x2b8>)
    6332:	6898      	ldr	r0, [r3, #8]
    6334:	4b07      	ldr	r3, [pc, #28]	; (6354 <sd_mmc_check+0x2c4>)
    6336:	4798      	blx	r3
    6338:	2800      	cmp	r0, #0
    633a:	f47f aef9 	bne.w	6130 <sd_mmc_check+0xa0>
    633e:	e6d3      	b.n	60e8 <sd_mmc_check+0x58>
    6340:	00005ed9 	.word	0x00005ed9
    6344:	00006055 	.word	0x00006055
    6348:	20000620 	.word	0x20000620
    634c:	0000268d 	.word	0x0000268d
    6350:	00005fed 	.word	0x00005fed
    6354:	000026b5 	.word	0x000026b5
    6358:	000026e5 	.word	0x000026e5
    635c:	0000270d 	.word	0x0000270d
    6360:	000099b4 	.word	0x000099b4
    6364:	401f8000 	.word	0x401f8000
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
    6368:	7dd1      	ldrb	r1, [r2, #23]
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
    636a:	7d90      	ldrb	r0, [r2, #22]
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
    636c:	7d53      	ldrb	r3, [r2, #21]
    636e:	041b      	lsls	r3, r3, #16
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
    6370:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
    6374:	430b      	orrs	r3, r1
	value &= ((uint32_t)1 << size) - 1;
    6376:	f3c3 0315 	ubfx	r3, r3, #0, #22
		sd_mmc_card->capacity = (SD_CSD_2_0_C_SIZE(sd_mmc_card->csd) + 1) * 512;
    637a:	3301      	adds	r3, #1
    637c:	025b      	lsls	r3, r3, #9
    637e:	6053      	str	r3, [r2, #4]
    6380:	e72a      	b.n	61d8 <sd_mmc_check+0x148>
	if (!driver_send_cmd(sd_mmc_hal, SDMMC_CMD55_APP_CMD, (uint32_t)sd_mmc_card->rca << 16)) {
    6382:	891a      	ldrh	r2, [r3, #8]
    6384:	0412      	lsls	r2, r2, #16
    6386:	f241 1137 	movw	r1, #4407	; 0x1137
    638a:	4b9a      	ldr	r3, [pc, #616]	; (65f4 <sd_mmc_check+0x564>)
    638c:	6898      	ldr	r0, [r3, #8]
    638e:	4b9a      	ldr	r3, [pc, #616]	; (65f8 <sd_mmc_check+0x568>)
    6390:	4798      	blx	r3
    6392:	2800      	cmp	r0, #0
    6394:	f43f aea8 	beq.w	60e8 <sd_mmc_check+0x58>
	if (!driver_adtc_start(sd_mmc_hal, SD_ACMD51_SEND_SCR, 0, SD_SCR_REG_BSIZE, 1, true)) {
    6398:	2301      	movs	r3, #1
    639a:	9301      	str	r3, [sp, #4]
    639c:	9300      	str	r3, [sp, #0]
    639e:	2308      	movs	r3, #8
    63a0:	2200      	movs	r2, #0
    63a2:	4996      	ldr	r1, [pc, #600]	; (65fc <sd_mmc_check+0x56c>)
    63a4:	4893      	ldr	r0, [pc, #588]	; (65f4 <sd_mmc_check+0x564>)
    63a6:	6880      	ldr	r0, [r0, #8]
    63a8:	4d95      	ldr	r5, [pc, #596]	; (6600 <sd_mmc_check+0x570>)
    63aa:	47a8      	blx	r5
    63ac:	2800      	cmp	r0, #0
    63ae:	f43f ae9b 	beq.w	60e8 <sd_mmc_check+0x58>
	if (!driver_start_read_blocks(sd_mmc_hal, scr, 1)) {
    63b2:	2201      	movs	r2, #1
    63b4:	a904      	add	r1, sp, #16
    63b6:	4b8f      	ldr	r3, [pc, #572]	; (65f4 <sd_mmc_check+0x564>)
    63b8:	6898      	ldr	r0, [r3, #8]
    63ba:	4b92      	ldr	r3, [pc, #584]	; (6604 <sd_mmc_check+0x574>)
    63bc:	4798      	blx	r3
    63be:	2800      	cmp	r0, #0
    63c0:	f43f ae92 	beq.w	60e8 <sd_mmc_check+0x58>
	if (!driver_wait_end_of_read_blocks(sd_mmc_hal)) {
    63c4:	4b8b      	ldr	r3, [pc, #556]	; (65f4 <sd_mmc_check+0x564>)
    63c6:	6898      	ldr	r0, [r3, #8]
    63c8:	4b8f      	ldr	r3, [pc, #572]	; (6608 <sd_mmc_check+0x578>)
    63ca:	4798      	blx	r3
    63cc:	2800      	cmp	r0, #0
    63ce:	f43f ae8b 	beq.w	60e8 <sd_mmc_check+0x58>
	switch (SD_SCR_SD_SPEC(scr)) {
    63d2:	f89d 3010 	ldrb.w	r3, [sp, #16]
    63d6:	f003 030f 	and.w	r3, r3, #15
    63da:	2b01      	cmp	r3, #1
    63dc:	d00c      	beq.n	63f8 <sd_mmc_check+0x368>
    63de:	b133      	cbz	r3, 63ee <sd_mmc_check+0x35e>
    63e0:	2b02      	cmp	r3, #2
    63e2:	d00e      	beq.n	6402 <sd_mmc_check+0x372>
		sd_mmc_card->version = CARD_VER_SD_1_0;
    63e4:	4b83      	ldr	r3, [pc, #524]	; (65f4 <sd_mmc_check+0x564>)
    63e6:	681b      	ldr	r3, [r3, #0]
    63e8:	2210      	movs	r2, #16
    63ea:	731a      	strb	r2, [r3, #12]
    63ec:	e707      	b.n	61fe <sd_mmc_check+0x16e>
		sd_mmc_card->version = CARD_VER_SD_1_0;
    63ee:	4b81      	ldr	r3, [pc, #516]	; (65f4 <sd_mmc_check+0x564>)
    63f0:	681b      	ldr	r3, [r3, #0]
    63f2:	2210      	movs	r2, #16
    63f4:	731a      	strb	r2, [r3, #12]
    63f6:	e702      	b.n	61fe <sd_mmc_check+0x16e>
		sd_mmc_card->version = CARD_VER_SD_1_10;
    63f8:	4b7e      	ldr	r3, [pc, #504]	; (65f4 <sd_mmc_check+0x564>)
    63fa:	681b      	ldr	r3, [r3, #0]
    63fc:	221a      	movs	r2, #26
    63fe:	731a      	strb	r2, [r3, #12]
    6400:	e6fd      	b.n	61fe <sd_mmc_check+0x16e>
		if (SD_SCR_SD_SPEC3(scr) == SD_SCR_SD_SPEC_3_00) {
    6402:	f89d 3012 	ldrb.w	r3, [sp, #18]
    6406:	09db      	lsrs	r3, r3, #7
			sd_mmc_card->version = CARD_VER_SD_3_0;
    6408:	4b7a      	ldr	r3, [pc, #488]	; (65f4 <sd_mmc_check+0x564>)
    640a:	681b      	ldr	r3, [r3, #0]
    640c:	bf14      	ite	ne
    640e:	2230      	movne	r2, #48	; 0x30
			sd_mmc_card->version = CARD_VER_SD_2_0;
    6410:	2220      	moveq	r2, #32
    6412:	731a      	strb	r2, [r3, #12]
    6414:	e6f3      	b.n	61fe <sd_mmc_check+0x16e>
		if (buf[1] == 0) {
    6416:	f89d 3011 	ldrb.w	r3, [sp, #17]
    641a:	2b00      	cmp	r3, #0
    641c:	f43f ae64 	beq.w	60e8 <sd_mmc_check+0x58>
		addr_new += buf[1] - 1;
    6420:	3302      	adds	r3, #2
    6422:	441e      	add	r6, r3
		if (addr_new > (addr_old + 256)) {
    6424:	f509 7380 	add.w	r3, r9, #256	; 0x100
    6428:	429e      	cmp	r6, r3
    642a:	f63f ae5d 	bhi.w	60e8 <sd_mmc_check+0x58>
	addr_new = addr_old;
    642e:	2500      	movs	r5, #0
			sdio_cmd52(SDIO_CMD52_READ_FLAG, SDIO_CIA, addr_new, 0, &buf[i]);
    6430:	ab04      	add	r3, sp, #16
    6432:	442b      	add	r3, r5
    6434:	9300      	str	r3, [sp, #0]
    6436:	4643      	mov	r3, r8
    6438:	1972      	adds	r2, r6, r5
    643a:	4641      	mov	r1, r8
    643c:	4640      	mov	r0, r8
    643e:	47b8      	blx	r7
    6440:	3501      	adds	r5, #1
		for (i = 0; i < 3; i++) {
    6442:	2d03      	cmp	r5, #3
    6444:	d1f4      	bne.n	6430 <sd_mmc_check+0x3a0>
		if (buf[0] == SDIO_CISTPL_END) {
    6446:	f89d 3010 	ldrb.w	r3, [sp, #16]
    644a:	2bff      	cmp	r3, #255	; 0xff
    644c:	f43f ae4c 	beq.w	60e8 <sd_mmc_check+0x58>
		if (buf[0] == SDIO_CISTPL_FUNCE && buf[2] == 0x00) {
    6450:	2b22      	cmp	r3, #34	; 0x22
    6452:	d1e0      	bne.n	6416 <sd_mmc_check+0x386>
    6454:	f89d 3012 	ldrb.w	r3, [sp, #18]
    6458:	2b00      	cmp	r3, #0
    645a:	d1dc      	bne.n	6416 <sd_mmc_check+0x386>
    645c:	f106 0906 	add.w	r9, r6, #6
	addr_new -= 3;
    6460:	4635      	mov	r5, r6
		sdio_cmd52(SDIO_CMD52_READ_FLAG, SDIO_CIA, addr_new, 0, &buf[i]);
    6462:	f04f 0800 	mov.w	r8, #0
    6466:	4f69      	ldr	r7, [pc, #420]	; (660c <sd_mmc_check+0x57c>)
    6468:	1bab      	subs	r3, r5, r6
    646a:	aa04      	add	r2, sp, #16
    646c:	4413      	add	r3, r2
    646e:	9300      	str	r3, [sp, #0]
    6470:	4643      	mov	r3, r8
    6472:	462a      	mov	r2, r5
    6474:	4641      	mov	r1, r8
    6476:	4640      	mov	r0, r8
    6478:	47b8      	blx	r7
		addr_new++;
    647a:	3501      	adds	r5, #1
	for (i = 0; i < 6; i++) {
    647c:	454d      	cmp	r5, r9
    647e:	d1f3      	bne.n	6468 <sd_mmc_check+0x3d8>
	tplfe_max_tran_speed = buf[5];
    6480:	f89d 3015 	ldrb.w	r3, [sp, #21]
    6484:	2b32      	cmp	r3, #50	; 0x32
    6486:	bf28      	it	cs
    6488:	2332      	movcs	r3, #50	; 0x32
	sd_mmc_card->clock = unit * mul * 1000;
    648a:	4a5a      	ldr	r2, [pc, #360]	; (65f4 <sd_mmc_check+0x564>)
    648c:	6810      	ldr	r0, [r2, #0]
	unit               = sd_mmc_trans_units[tplfe_max_tran_speed & 0x7];
    648e:	4a60      	ldr	r2, [pc, #384]	; (6610 <sd_mmc_check+0x580>)
    6490:	f003 0107 	and.w	r1, r3, #7
	sd_mmc_card->clock = unit * mul * 1000;
    6494:	f852 5021 	ldr.w	r5, [r2, r1, lsl #2]
    6498:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
    649c:	fb01 f105 	mul.w	r1, r1, r5
	mul                = sd_trans_multipliers[(tplfe_max_tran_speed >> 3) & 0xF];
    64a0:	f3c3 03c3 	ubfx	r3, r3, #3, #4
    64a4:	eb02 0383 	add.w	r3, r2, r3, lsl #2
	sd_mmc_card->clock = unit * mul * 1000;
    64a8:	69db      	ldr	r3, [r3, #28]
    64aa:	fb03 f301 	mul.w	r3, r3, r1
    64ae:	6003      	str	r3, [r0, #0]
	if ((4 <= driver_get_bus_width(sd_mmc_hal, sd_mmc_slot_sel))) {
    64b0:	4b50      	ldr	r3, [pc, #320]	; (65f4 <sd_mmc_check+0x564>)
    64b2:	7919      	ldrb	r1, [r3, #4]
    64b4:	6898      	ldr	r0, [r3, #8]
    64b6:	4b57      	ldr	r3, [pc, #348]	; (6614 <sd_mmc_check+0x584>)
    64b8:	4798      	blx	r3
    64ba:	2803      	cmp	r0, #3
    64bc:	d926      	bls.n	650c <sd_mmc_check+0x47c>
		if (IS_SDIO()) {
    64be:	4b4d      	ldr	r3, [pc, #308]	; (65f4 <sd_mmc_check+0x564>)
    64c0:	681b      	ldr	r3, [r3, #0]
    64c2:	7adb      	ldrb	r3, [r3, #11]
    64c4:	f013 0f04 	tst.w	r3, #4
    64c8:	d14e      	bne.n	6568 <sd_mmc_check+0x4d8>
		if (sd_mmc_card->type & CARD_TYPE_SD) {
    64ca:	4b4a      	ldr	r3, [pc, #296]	; (65f4 <sd_mmc_check+0x564>)
    64cc:	681b      	ldr	r3, [r3, #0]
    64ce:	7ada      	ldrb	r2, [r3, #11]
    64d0:	f012 0f01 	tst.w	r2, #1
    64d4:	d018      	beq.n	6508 <sd_mmc_check+0x478>
	if (!driver_send_cmd(sd_mmc_hal, SDMMC_CMD55_APP_CMD, (uint32_t)sd_mmc_card->rca << 16)) {
    64d6:	891a      	ldrh	r2, [r3, #8]
    64d8:	0412      	lsls	r2, r2, #16
    64da:	f241 1137 	movw	r1, #4407	; 0x1137
    64de:	4b45      	ldr	r3, [pc, #276]	; (65f4 <sd_mmc_check+0x564>)
    64e0:	6898      	ldr	r0, [r3, #8]
    64e2:	4b45      	ldr	r3, [pc, #276]	; (65f8 <sd_mmc_check+0x568>)
    64e4:	4798      	blx	r3
    64e6:	2800      	cmp	r0, #0
    64e8:	f43f adfe 	beq.w	60e8 <sd_mmc_check+0x58>
	if (!driver_send_cmd(sd_mmc_hal, SD_ACMD6_SET_BUS_WIDTH, 0x2)) {
    64ec:	2202      	movs	r2, #2
    64ee:	f241 1106 	movw	r1, #4358	; 0x1106
    64f2:	4b40      	ldr	r3, [pc, #256]	; (65f4 <sd_mmc_check+0x564>)
    64f4:	6898      	ldr	r0, [r3, #8]
    64f6:	4b40      	ldr	r3, [pc, #256]	; (65f8 <sd_mmc_check+0x568>)
    64f8:	4798      	blx	r3
    64fa:	2800      	cmp	r0, #0
    64fc:	f43f adf4 	beq.w	60e8 <sd_mmc_check+0x58>
	sd_mmc_card->bus_width = 4;
    6500:	4b3c      	ldr	r3, [pc, #240]	; (65f4 <sd_mmc_check+0x564>)
    6502:	681b      	ldr	r3, [r3, #0]
    6504:	2204      	movs	r2, #4
    6506:	735a      	strb	r2, [r3, #13]
		sd_mmc_configure_slot();
    6508:	4b43      	ldr	r3, [pc, #268]	; (6618 <sd_mmc_check+0x588>)
    650a:	4798      	blx	r3
	if (driver_is_high_speed_capable(sd_mmc_hal)) {
    650c:	4b39      	ldr	r3, [pc, #228]	; (65f4 <sd_mmc_check+0x564>)
    650e:	6898      	ldr	r0, [r3, #8]
    6510:	4b42      	ldr	r3, [pc, #264]	; (661c <sd_mmc_check+0x58c>)
    6512:	4798      	blx	r3
    6514:	b180      	cbz	r0, 6538 <sd_mmc_check+0x4a8>
		if (IS_SDIO()) {
    6516:	4b37      	ldr	r3, [pc, #220]	; (65f4 <sd_mmc_check+0x564>)
    6518:	681b      	ldr	r3, [r3, #0]
    651a:	7adb      	ldrb	r3, [r3, #11]
    651c:	f013 0f04 	tst.w	r3, #4
    6520:	d143      	bne.n	65aa <sd_mmc_check+0x51a>
		if (sd_mmc_card->type & CARD_TYPE_SD) {
    6522:	4b34      	ldr	r3, [pc, #208]	; (65f4 <sd_mmc_check+0x564>)
    6524:	681b      	ldr	r3, [r3, #0]
    6526:	7ada      	ldrb	r2, [r3, #11]
    6528:	f012 0f01 	tst.w	r2, #1
    652c:	d002      	beq.n	6534 <sd_mmc_check+0x4a4>
			if (sd_mmc_card->version > CARD_VER_SD_1_0) {
    652e:	7b1b      	ldrb	r3, [r3, #12]
    6530:	2b10      	cmp	r3, #16
    6532:	d877      	bhi.n	6624 <sd_mmc_check+0x594>
		sd_mmc_configure_slot();
    6534:	4b38      	ldr	r3, [pc, #224]	; (6618 <sd_mmc_check+0x588>)
    6536:	4798      	blx	r3
	if (sd_mmc_card->type & CARD_TYPE_SD) {
    6538:	4b2e      	ldr	r3, [pc, #184]	; (65f4 <sd_mmc_check+0x564>)
    653a:	681b      	ldr	r3, [r3, #0]
    653c:	7adb      	ldrb	r3, [r3, #11]
    653e:	f013 0f01 	tst.w	r3, #1
    6542:	d00a      	beq.n	655a <sd_mmc_check+0x4ca>
		if (!driver_send_cmd(sd_mmc_hal, SDMMC_CMD16_SET_BLOCKLEN, SD_MMC_BLOCK_SIZE)) {
    6544:	f44f 7200 	mov.w	r2, #512	; 0x200
    6548:	f241 1110 	movw	r1, #4368	; 0x1110
    654c:	4b29      	ldr	r3, [pc, #164]	; (65f4 <sd_mmc_check+0x564>)
    654e:	6898      	ldr	r0, [r3, #8]
    6550:	4b29      	ldr	r3, [pc, #164]	; (65f8 <sd_mmc_check+0x568>)
    6552:	4798      	blx	r3
	if (sd_mmc_mci_card_init()) {
    6554:	2800      	cmp	r0, #0
    6556:	f43f adc7 	beq.w	60e8 <sd_mmc_check+0x58>
		sd_mmc_card->state = SD_MMC_CARD_STATE_READY;
    655a:	4b26      	ldr	r3, [pc, #152]	; (65f4 <sd_mmc_check+0x564>)
    655c:	681b      	ldr	r3, [r3, #0]
    655e:	2200      	movs	r2, #0
    6560:	729a      	strb	r2, [r3, #10]
		sd_mmc_deselect_slot();
    6562:	4b2f      	ldr	r3, [pc, #188]	; (6620 <sd_mmc_check+0x590>)
    6564:	4798      	blx	r3
		return SD_MMC_INIT_ONGOING;
    6566:	e59d      	b.n	60a4 <sd_mmc_check+0x14>
	if (!sdio_cmd52(SDIO_CMD52_READ_FLAG, SDIO_CIA, SDIO_CCCR_CAP, 0, &u8_value)) {
    6568:	ab04      	add	r3, sp, #16
    656a:	9300      	str	r3, [sp, #0]
    656c:	2300      	movs	r3, #0
    656e:	2208      	movs	r2, #8
    6570:	4619      	mov	r1, r3
    6572:	4618      	mov	r0, r3
    6574:	4d25      	ldr	r5, [pc, #148]	; (660c <sd_mmc_check+0x57c>)
    6576:	47a8      	blx	r5
    6578:	2800      	cmp	r0, #0
    657a:	f43f adb5 	beq.w	60e8 <sd_mmc_check+0x58>
	if ((u8_value & SDIO_CAP_4BLS) != SDIO_CAP_4BLS) {
    657e:	f99d 3010 	ldrsb.w	r3, [sp, #16]
    6582:	2b00      	cmp	r3, #0
    6584:	daa1      	bge.n	64ca <sd_mmc_check+0x43a>
	u8_value = SDIO_BUSWIDTH_4B;
    6586:	ab14      	add	r3, sp, #80	; 0x50
    6588:	2202      	movs	r2, #2
    658a:	f803 2d40 	strb.w	r2, [r3, #-64]!
	if (!sdio_cmd52(SDIO_CMD52_WRITE_FLAG, SDIO_CIA, SDIO_CCCR_BUS_CTRL, 1, &u8_value)) {
    658e:	9300      	str	r3, [sp, #0]
    6590:	2301      	movs	r3, #1
    6592:	2207      	movs	r2, #7
    6594:	2100      	movs	r1, #0
    6596:	4618      	mov	r0, r3
    6598:	47a8      	blx	r5
    659a:	2800      	cmp	r0, #0
    659c:	f43f ada4 	beq.w	60e8 <sd_mmc_check+0x58>
	sd_mmc_card->bus_width = 4;
    65a0:	4b14      	ldr	r3, [pc, #80]	; (65f4 <sd_mmc_check+0x564>)
    65a2:	681b      	ldr	r3, [r3, #0]
    65a4:	2204      	movs	r2, #4
    65a6:	735a      	strb	r2, [r3, #13]
    65a8:	e78f      	b.n	64ca <sd_mmc_check+0x43a>
	if (!sdio_cmd52(SDIO_CMD52_READ_FLAG, SDIO_CIA, SDIO_CCCR_HS, 0, &u8_value)) {
    65aa:	ab04      	add	r3, sp, #16
    65ac:	9300      	str	r3, [sp, #0]
    65ae:	2300      	movs	r3, #0
    65b0:	2213      	movs	r2, #19
    65b2:	4619      	mov	r1, r3
    65b4:	4618      	mov	r0, r3
    65b6:	4d15      	ldr	r5, [pc, #84]	; (660c <sd_mmc_check+0x57c>)
    65b8:	47a8      	blx	r5
    65ba:	2800      	cmp	r0, #0
    65bc:	f43f ad94 	beq.w	60e8 <sd_mmc_check+0x58>
	if ((u8_value & SDIO_SHS) != SDIO_SHS) {
    65c0:	f89d 3010 	ldrb.w	r3, [sp, #16]
    65c4:	f013 0f01 	tst.w	r3, #1
    65c8:	d0ab      	beq.n	6522 <sd_mmc_check+0x492>
	u8_value = SDIO_EHS;
    65ca:	ab14      	add	r3, sp, #80	; 0x50
    65cc:	2202      	movs	r2, #2
    65ce:	f803 2d40 	strb.w	r2, [r3, #-64]!
	if (!sdio_cmd52(SDIO_CMD52_WRITE_FLAG, SDIO_CIA, SDIO_CCCR_HS, 1, &u8_value)) {
    65d2:	9300      	str	r3, [sp, #0]
    65d4:	2301      	movs	r3, #1
    65d6:	2213      	movs	r2, #19
    65d8:	2100      	movs	r1, #0
    65da:	4618      	mov	r0, r3
    65dc:	47a8      	blx	r5
    65de:	2800      	cmp	r0, #0
    65e0:	f43f ad82 	beq.w	60e8 <sd_mmc_check+0x58>
	sd_mmc_card->high_speed = 1;
    65e4:	4b03      	ldr	r3, [pc, #12]	; (65f4 <sd_mmc_check+0x564>)
    65e6:	681b      	ldr	r3, [r3, #0]
    65e8:	2201      	movs	r2, #1
    65ea:	779a      	strb	r2, [r3, #30]
	sd_mmc_card->clock *= 2;
    65ec:	681a      	ldr	r2, [r3, #0]
    65ee:	0052      	lsls	r2, r2, #1
    65f0:	601a      	str	r2, [r3, #0]
    65f2:	e796      	b.n	6522 <sd_mmc_check+0x492>
    65f4:	20000620 	.word	0x20000620
    65f8:	000026b5 	.word	0x000026b5
    65fc:	00081133 	.word	0x00081133
    6600:	0000273d 	.word	0x0000273d
    6604:	00002781 	.word	0x00002781
    6608:	000027e9 	.word	0x000027e9
    660c:	00005fed 	.word	0x00005fed
    6610:	000099b4 	.word	0x000099b4
    6614:	00002639 	.word	0x00002639
    6618:	00005ead 	.word	0x00005ead
    661c:	00002665 	.word	0x00002665
    6620:	00006055 	.word	0x00006055
	uint8_t switch_status[SD_SW_STATUS_BSIZE] = {0};
    6624:	2540      	movs	r5, #64	; 0x40
    6626:	462a      	mov	r2, r5
    6628:	2100      	movs	r1, #0
    662a:	a804      	add	r0, sp, #16
    662c:	4b21      	ldr	r3, [pc, #132]	; (66b4 <sd_mmc_check+0x624>)
    662e:	4798      	blx	r3
	if (!driver_adtc_start(sd_mmc_hal,
    6630:	2301      	movs	r3, #1
    6632:	9301      	str	r3, [sp, #4]
    6634:	9300      	str	r3, [sp, #0]
    6636:	462b      	mov	r3, r5
    6638:	4a1f      	ldr	r2, [pc, #124]	; (66b8 <sd_mmc_check+0x628>)
    663a:	4920      	ldr	r1, [pc, #128]	; (66bc <sd_mmc_check+0x62c>)
    663c:	4820      	ldr	r0, [pc, #128]	; (66c0 <sd_mmc_check+0x630>)
    663e:	6880      	ldr	r0, [r0, #8]
    6640:	4d20      	ldr	r5, [pc, #128]	; (66c4 <sd_mmc_check+0x634>)
    6642:	47a8      	blx	r5
    6644:	2800      	cmp	r0, #0
    6646:	f43f ad4f 	beq.w	60e8 <sd_mmc_check+0x58>
	if (!driver_start_read_blocks(sd_mmc_hal, switch_status, 1)) {
    664a:	2201      	movs	r2, #1
    664c:	a904      	add	r1, sp, #16
    664e:	4b1c      	ldr	r3, [pc, #112]	; (66c0 <sd_mmc_check+0x630>)
    6650:	6898      	ldr	r0, [r3, #8]
    6652:	4b1d      	ldr	r3, [pc, #116]	; (66c8 <sd_mmc_check+0x638>)
    6654:	4798      	blx	r3
    6656:	2800      	cmp	r0, #0
    6658:	f43f ad46 	beq.w	60e8 <sd_mmc_check+0x58>
	if (!driver_wait_end_of_read_blocks(sd_mmc_hal)) {
    665c:	4b18      	ldr	r3, [pc, #96]	; (66c0 <sd_mmc_check+0x630>)
    665e:	6898      	ldr	r0, [r3, #8]
    6660:	4b1a      	ldr	r3, [pc, #104]	; (66cc <sd_mmc_check+0x63c>)
    6662:	4798      	blx	r3
    6664:	2800      	cmp	r0, #0
    6666:	f43f ad3f 	beq.w	60e8 <sd_mmc_check+0x58>
	if (driver_get_response(sd_mmc_hal) & CARD_STATUS_SWITCH_ERROR) {
    666a:	4b15      	ldr	r3, [pc, #84]	; (66c0 <sd_mmc_check+0x630>)
    666c:	6898      	ldr	r0, [r3, #8]
    666e:	4b18      	ldr	r3, [pc, #96]	; (66d0 <sd_mmc_check+0x640>)
    6670:	4798      	blx	r3
    6672:	f010 0f80 	tst.w	r0, #128	; 0x80
    6676:	f47f ad37 	bne.w	60e8 <sd_mmc_check+0x58>
	if (SD_SW_STATUS_FUN_GRP1_RC(switch_status) == SD_SW_STATUS_FUN_GRP_RC_ERROR) {
    667a:	f89d 3020 	ldrb.w	r3, [sp, #32]
    667e:	f003 030f 	and.w	r3, r3, #15
    6682:	2b0f      	cmp	r3, #15
    6684:	f43f af56 	beq.w	6534 <sd_mmc_check+0x4a4>
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
    6688:	f89d 302d 	ldrb.w	r3, [sp, #45]	; 0x2d
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
    668c:	f89d 202c 	ldrb.w	r2, [sp, #44]	; 0x2c
	if (SD_SW_STATUS_FUN_GRP1_BUSY(switch_status)) {
    6690:	ea53 2302 	orrs.w	r3, r3, r2, lsl #8
    6694:	f47f ad28 	bne.w	60e8 <sd_mmc_check+0x58>
	driver_send_clock(sd_mmc_hal);
    6698:	4d09      	ldr	r5, [pc, #36]	; (66c0 <sd_mmc_check+0x630>)
    669a:	68a8      	ldr	r0, [r5, #8]
    669c:	4b0d      	ldr	r3, [pc, #52]	; (66d4 <sd_mmc_check+0x644>)
    669e:	4798      	blx	r3
	sd_mmc_card->high_speed = 1;
    66a0:	682b      	ldr	r3, [r5, #0]
    66a2:	2201      	movs	r2, #1
    66a4:	779a      	strb	r2, [r3, #30]
	sd_mmc_card->clock *= 2;
    66a6:	681a      	ldr	r2, [r3, #0]
    66a8:	0052      	lsls	r2, r2, #1
    66aa:	601a      	str	r2, [r3, #0]
    66ac:	e742      	b.n	6534 <sd_mmc_check+0x4a4>
	*v2 = 0;
    66ae:	f04f 0800 	mov.w	r8, #0
    66b2:	e52c      	b.n	610e <sd_mmc_check+0x7e>
    66b4:	000096ab 	.word	0x000096ab
    66b8:	80ffff01 	.word	0x80ffff01
    66bc:	00081106 	.word	0x00081106
    66c0:	20000620 	.word	0x20000620
    66c4:	0000273d 	.word	0x0000273d
    66c8:	00002781 	.word	0x00002781
    66cc:	000027e9 	.word	0x000027e9
    66d0:	000026e5 	.word	0x000026e5
    66d4:	0000268d 	.word	0x0000268d

000066d8 <sd_mmc_get_type>:

card_type_t sd_mmc_get_type(uint8_t slot)
{
    66d8:	b508      	push	{r3, lr}
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
    66da:	4b05      	ldr	r3, [pc, #20]	; (66f0 <sd_mmc_get_type+0x18>)
    66dc:	4798      	blx	r3
    66de:	b108      	cbz	r0, 66e4 <sd_mmc_get_type+0xc>
		return CARD_TYPE_UNKNOWN;
    66e0:	2000      	movs	r0, #0
	}
	sd_mmc_deselect_slot();
	return sd_mmc_card->type;
}
    66e2:	bd08      	pop	{r3, pc}
	sd_mmc_deselect_slot();
    66e4:	4b03      	ldr	r3, [pc, #12]	; (66f4 <sd_mmc_get_type+0x1c>)
    66e6:	4798      	blx	r3
	return sd_mmc_card->type;
    66e8:	4b03      	ldr	r3, [pc, #12]	; (66f8 <sd_mmc_get_type+0x20>)
    66ea:	681b      	ldr	r3, [r3, #0]
    66ec:	7ad8      	ldrb	r0, [r3, #11]
    66ee:	bd08      	pop	{r3, pc}
    66f0:	00005ed9 	.word	0x00005ed9
    66f4:	00006055 	.word	0x00006055
    66f8:	20000620 	.word	0x20000620

000066fc <sd_mmc_get_capacity>:
	sd_mmc_deselect_slot();
	return sd_mmc_card->version;
}

uint32_t sd_mmc_get_capacity(uint8_t slot)
{
    66fc:	b508      	push	{r3, lr}
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
    66fe:	4b05      	ldr	r3, [pc, #20]	; (6714 <sd_mmc_get_capacity+0x18>)
    6700:	4798      	blx	r3
    6702:	b108      	cbz	r0, 6708 <sd_mmc_get_capacity+0xc>
		return 0;
    6704:	2000      	movs	r0, #0
	}
	sd_mmc_deselect_slot();
	return sd_mmc_card->capacity;
}
    6706:	bd08      	pop	{r3, pc}
	sd_mmc_deselect_slot();
    6708:	4b03      	ldr	r3, [pc, #12]	; (6718 <sd_mmc_get_capacity+0x1c>)
    670a:	4798      	blx	r3
	return sd_mmc_card->capacity;
    670c:	4b03      	ldr	r3, [pc, #12]	; (671c <sd_mmc_get_capacity+0x20>)
    670e:	681b      	ldr	r3, [r3, #0]
    6710:	6858      	ldr	r0, [r3, #4]
    6712:	bd08      	pop	{r3, pc}
    6714:	00005ed9 	.word	0x00005ed9
    6718:	00006055 	.word	0x00006055
    671c:	20000620 	.word	0x20000620

00006720 <sd_mmc_is_write_protected>:

bool sd_mmc_is_write_protected(uint8_t slot)
{
	/* No detection, always writable */
	if (!_wp || _wp[slot].pin == -1) {
    6720:	4b19      	ldr	r3, [pc, #100]	; (6788 <sd_mmc_is_write_protected+0x68>)
    6722:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    6724:	2b00      	cmp	r3, #0
    6726:	d02b      	beq.n	6780 <sd_mmc_is_write_protected+0x60>
{
    6728:	b570      	push	{r4, r5, r6, lr}
    672a:	b082      	sub	sp, #8
	if (!_wp || _wp[slot].pin == -1) {
    672c:	0085      	lsls	r5, r0, #2
    672e:	f933 3020 	ldrsh.w	r3, [r3, r0, lsl #2]
    6732:	f1b3 3fff 	cmp.w	r3, #4294967295
    6736:	d025      	beq.n	6784 <sd_mmc_is_write_protected+0x64>
		return false;
	}
	/* Write Protect Detect */
	if (gpio_get_pin_level(_wp[slot].pin) == _wp[slot].val) {
    6738:	b2de      	uxtb	r6, r3
	CRITICAL_SECTION_ENTER();
    673a:	a801      	add	r0, sp, #4
    673c:	4b13      	ldr	r3, [pc, #76]	; (678c <sd_mmc_is_write_protected+0x6c>)
    673e:	4798      	blx	r3
	return ((Port *)hw)->Group[submodule_index].DIR.reg;
    6740:	0973      	lsrs	r3, r6, #5
    6742:	4913      	ldr	r1, [pc, #76]	; (6790 <sd_mmc_is_write_protected+0x70>)
    6744:	01db      	lsls	r3, r3, #7
    6746:	18ca      	adds	r2, r1, r3
    6748:	58c9      	ldr	r1, [r1, r3]
	return ((Port *)hw)->Group[submodule_index].IN.reg;
    674a:	6a13      	ldr	r3, [r2, #32]
	return ((Port *)hw)->Group[submodule_index].OUT.reg;
    674c:	6914      	ldr	r4, [r2, #16]
	tmp |= hri_port_read_OUT_reg(PORT, port) & dir_tmp;
    674e:	405c      	eors	r4, r3
    6750:	400c      	ands	r4, r1
    6752:	405c      	eors	r4, r3
	CRITICAL_SECTION_LEAVE();
    6754:	a801      	add	r0, sp, #4
    6756:	4b0f      	ldr	r3, [pc, #60]	; (6794 <sd_mmc_is_write_protected+0x74>)
    6758:	4798      	blx	r3
    675a:	f006 031f 	and.w	r3, r6, #31
    675e:	2201      	movs	r2, #1
    6760:	fa02 f303 	lsl.w	r3, r2, r3
    6764:	4223      	tst	r3, r4
    6766:	bf14      	ite	ne
    6768:	4610      	movne	r0, r2
    676a:	2000      	moveq	r0, #0
    676c:	4b06      	ldr	r3, [pc, #24]	; (6788 <sd_mmc_is_write_protected+0x68>)
    676e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    6770:	441d      	add	r5, r3
    6772:	886b      	ldrh	r3, [r5, #2]
    6774:	4298      	cmp	r0, r3
    6776:	bf14      	ite	ne
    6778:	2000      	movne	r0, #0
    677a:	2001      	moveq	r0, #1
		return true;
	}
	return false;
}
    677c:	b002      	add	sp, #8
    677e:	bd70      	pop	{r4, r5, r6, pc}
		return false;
    6780:	2000      	movs	r0, #0
    6782:	4770      	bx	lr
    6784:	2000      	movs	r0, #0
    6786:	e7f9      	b.n	677c <sd_mmc_is_write_protected+0x5c>
    6788:	20000620 	.word	0x20000620
    678c:	00002221 	.word	0x00002221
    6790:	41008000 	.word	0x41008000
    6794:	0000222f 	.word	0x0000222f

00006798 <sd_mmc_init_read_blocks>:

sd_mmc_err_t sd_mmc_init_read_blocks(uint8_t slot, uint32_t start, uint16_t nb_block)
{
    6798:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    679c:	b082      	sub	sp, #8
    679e:	468a      	mov	sl, r1
    67a0:	4691      	mov	r9, r2
	sd_mmc_err_t sd_mmc_err;
	uint32_t     cmd, arg, resp;

	sd_mmc_err = sd_mmc_select_slot(slot);
    67a2:	4b29      	ldr	r3, [pc, #164]	; (6848 <sd_mmc_init_read_blocks+0xb0>)
    67a4:	4798      	blx	r3
	if (sd_mmc_err != SD_MMC_OK) {
    67a6:	4680      	mov	r8, r0
    67a8:	b118      	cbz	r0, 67b2 <sd_mmc_init_read_blocks+0x1a>
	}

	sd_mmc_nb_block_remaining  = nb_block;
	sd_mmc_nb_block_to_tranfer = nb_block;
	return SD_MMC_OK;
}
    67aa:	4640      	mov	r0, r8
    67ac:	b002      	add	sp, #8
    67ae:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    67b2:	4d26      	ldr	r5, [pc, #152]	; (684c <sd_mmc_init_read_blocks+0xb4>)
		if (!driver_send_cmd(sd_mmc_hal, SDMMC_MCI_CMD13_SEND_STATUS, (uint32_t)sd_mmc_card->rca << 16)) {
    67b4:	4c26      	ldr	r4, [pc, #152]	; (6850 <sd_mmc_init_read_blocks+0xb8>)
    67b6:	4e27      	ldr	r6, [pc, #156]	; (6854 <sd_mmc_init_read_blocks+0xbc>)
		if (driver_get_response(sd_mmc_hal) & CARD_STATUS_READY_FOR_DATA) {
    67b8:	4f27      	ldr	r7, [pc, #156]	; (6858 <sd_mmc_init_read_blocks+0xc0>)
		if (!driver_send_cmd(sd_mmc_hal, SDMMC_MCI_CMD13_SEND_STATUS, (uint32_t)sd_mmc_card->rca << 16)) {
    67ba:	6823      	ldr	r3, [r4, #0]
    67bc:	891a      	ldrh	r2, [r3, #8]
    67be:	0412      	lsls	r2, r2, #16
    67c0:	f241 110d 	movw	r1, #4365	; 0x110d
    67c4:	68a0      	ldr	r0, [r4, #8]
    67c6:	47b0      	blx	r6
    67c8:	b130      	cbz	r0, 67d8 <sd_mmc_init_read_blocks+0x40>
		if (driver_get_response(sd_mmc_hal) & CARD_STATUS_READY_FOR_DATA) {
    67ca:	68a0      	ldr	r0, [r4, #8]
    67cc:	47b8      	blx	r7
    67ce:	f410 7f80 	tst.w	r0, #256	; 0x100
    67d2:	d118      	bne.n	6806 <sd_mmc_init_read_blocks+0x6e>
		if (nec_timeout-- == 0) {
    67d4:	3d01      	subs	r5, #1
    67d6:	d1f0      	bne.n	67ba <sd_mmc_init_read_blocks+0x22>
		sd_mmc_deselect_slot();
    67d8:	4b20      	ldr	r3, [pc, #128]	; (685c <sd_mmc_init_read_blocks+0xc4>)
    67da:	4798      	blx	r3
		return SD_MMC_ERR_COMM;
    67dc:	f04f 0805 	mov.w	r8, #5
    67e0:	e7e3      	b.n	67aa <sd_mmc_init_read_blocks+0x12>
	resp = driver_get_response(sd_mmc_hal);
    67e2:	4b1b      	ldr	r3, [pc, #108]	; (6850 <sd_mmc_init_read_blocks+0xb8>)
    67e4:	6898      	ldr	r0, [r3, #8]
    67e6:	4b1c      	ldr	r3, [pc, #112]	; (6858 <sd_mmc_init_read_blocks+0xc0>)
    67e8:	4798      	blx	r3
	if (resp & CARD_STATUS_ERR_RD_WR) {
    67ea:	4b1d      	ldr	r3, [pc, #116]	; (6860 <sd_mmc_init_read_blocks+0xc8>)
    67ec:	4003      	ands	r3, r0
    67ee:	b92b      	cbnz	r3, 67fc <sd_mmc_init_read_blocks+0x64>
	sd_mmc_nb_block_remaining  = nb_block;
    67f0:	4b17      	ldr	r3, [pc, #92]	; (6850 <sd_mmc_init_read_blocks+0xb8>)
    67f2:	f8a3 9030 	strh.w	r9, [r3, #48]	; 0x30
	sd_mmc_nb_block_to_tranfer = nb_block;
    67f6:	f8a3 9038 	strh.w	r9, [r3, #56]	; 0x38
	return SD_MMC_OK;
    67fa:	e7d6      	b.n	67aa <sd_mmc_init_read_blocks+0x12>
		sd_mmc_deselect_slot();
    67fc:	4b17      	ldr	r3, [pc, #92]	; (685c <sd_mmc_init_read_blocks+0xc4>)
    67fe:	4798      	blx	r3
		return SD_MMC_ERR_COMM;
    6800:	f04f 0805 	mov.w	r8, #5
    6804:	e7d1      	b.n	67aa <sd_mmc_init_read_blocks+0x12>
		cmd = SDMMC_CMD17_READ_SINGLE_BLOCK;
    6806:	4b17      	ldr	r3, [pc, #92]	; (6864 <sd_mmc_init_read_blocks+0xcc>)
    6808:	4917      	ldr	r1, [pc, #92]	; (6868 <sd_mmc_init_read_blocks+0xd0>)
    680a:	f1b9 0f01 	cmp.w	r9, #1
    680e:	bf98      	it	ls
    6810:	4619      	movls	r1, r3
	if (sd_mmc_card->type & CARD_TYPE_HC) {
    6812:	4b0f      	ldr	r3, [pc, #60]	; (6850 <sd_mmc_init_read_blocks+0xb8>)
    6814:	681b      	ldr	r3, [r3, #0]
    6816:	7adb      	ldrb	r3, [r3, #11]
    6818:	f013 0f08 	tst.w	r3, #8
    681c:	d101      	bne.n	6822 <sd_mmc_init_read_blocks+0x8a>
		arg = (start * SD_MMC_BLOCK_SIZE);
    681e:	ea4f 2a4a 	mov.w	sl, sl, lsl #9
	if (!driver_adtc_start(sd_mmc_hal, cmd, arg, SD_MMC_BLOCK_SIZE, nb_block, true)) {
    6822:	4b0b      	ldr	r3, [pc, #44]	; (6850 <sd_mmc_init_read_blocks+0xb8>)
    6824:	6898      	ldr	r0, [r3, #8]
    6826:	2301      	movs	r3, #1
    6828:	9301      	str	r3, [sp, #4]
    682a:	f8cd 9000 	str.w	r9, [sp]
    682e:	f44f 7300 	mov.w	r3, #512	; 0x200
    6832:	4652      	mov	r2, sl
    6834:	4c0d      	ldr	r4, [pc, #52]	; (686c <sd_mmc_init_read_blocks+0xd4>)
    6836:	47a0      	blx	r4
    6838:	2800      	cmp	r0, #0
    683a:	d1d2      	bne.n	67e2 <sd_mmc_init_read_blocks+0x4a>
		sd_mmc_deselect_slot();
    683c:	4b07      	ldr	r3, [pc, #28]	; (685c <sd_mmc_init_read_blocks+0xc4>)
    683e:	4798      	blx	r3
		return SD_MMC_ERR_COMM;
    6840:	f04f 0805 	mov.w	r8, #5
    6844:	e7b1      	b.n	67aa <sd_mmc_init_read_blocks+0x12>
    6846:	bf00      	nop
    6848:	00005ed9 	.word	0x00005ed9
    684c:	00030d41 	.word	0x00030d41
    6850:	20000620 	.word	0x20000620
    6854:	000026b5 	.word	0x000026b5
    6858:	000026e5 	.word	0x000026e5
    685c:	00006055 	.word	0x00006055
    6860:	e4580000 	.word	0xe4580000
    6864:	00081111 	.word	0x00081111
    6868:	00101112 	.word	0x00101112
    686c:	0000273d 	.word	0x0000273d

00006870 <sd_mmc_start_read_blocks>:

sd_mmc_err_t sd_mmc_start_read_blocks(void *dest, uint16_t nb_block)
{
    6870:	b570      	push	{r4, r5, r6, lr}
    6872:	4606      	mov	r6, r0
    6874:	460c      	mov	r4, r1
	ASSERT(sd_mmc_nb_block_remaining >= nb_block);
    6876:	4d0d      	ldr	r5, [pc, #52]	; (68ac <sd_mmc_start_read_blocks+0x3c>)
    6878:	8e28      	ldrh	r0, [r5, #48]	; 0x30
    687a:	f240 52b1 	movw	r2, #1457	; 0x5b1
    687e:	490c      	ldr	r1, [pc, #48]	; (68b0 <sd_mmc_start_read_blocks+0x40>)
    6880:	42a0      	cmp	r0, r4
    6882:	bf34      	ite	cc
    6884:	2000      	movcc	r0, #0
    6886:	2001      	movcs	r0, #1
    6888:	4b0a      	ldr	r3, [pc, #40]	; (68b4 <sd_mmc_start_read_blocks+0x44>)
    688a:	4798      	blx	r3

	if (!driver_start_read_blocks(sd_mmc_hal, dest, nb_block)) {
    688c:	4622      	mov	r2, r4
    688e:	4631      	mov	r1, r6
    6890:	68a8      	ldr	r0, [r5, #8]
    6892:	4b09      	ldr	r3, [pc, #36]	; (68b8 <sd_mmc_start_read_blocks+0x48>)
    6894:	4798      	blx	r3
    6896:	b918      	cbnz	r0, 68a0 <sd_mmc_start_read_blocks+0x30>
		sd_mmc_nb_block_remaining = 0;
    6898:	2200      	movs	r2, #0
    689a:	862a      	strh	r2, [r5, #48]	; 0x30
		return SD_MMC_ERR_COMM;
    689c:	2005      	movs	r0, #5
    689e:	bd70      	pop	{r4, r5, r6, pc}
	}
	sd_mmc_nb_block_remaining -= nb_block;
    68a0:	4a02      	ldr	r2, [pc, #8]	; (68ac <sd_mmc_start_read_blocks+0x3c>)
    68a2:	8e13      	ldrh	r3, [r2, #48]	; 0x30
    68a4:	1b1c      	subs	r4, r3, r4
    68a6:	8614      	strh	r4, [r2, #48]	; 0x30
	return SD_MMC_OK;
    68a8:	2000      	movs	r0, #0
}
    68aa:	bd70      	pop	{r4, r5, r6, pc}
    68ac:	20000620 	.word	0x20000620
    68b0:	00009a50 	.word	0x00009a50
    68b4:	00003205 	.word	0x00003205
    68b8:	00002781 	.word	0x00002781

000068bc <sd_mmc_wait_end_of_read_blocks>:

sd_mmc_err_t sd_mmc_wait_end_of_read_blocks(bool abort)
{
    68bc:	b510      	push	{r4, lr}
    68be:	4604      	mov	r4, r0
	if (!driver_wait_end_of_read_blocks(sd_mmc_hal)) {
    68c0:	4b16      	ldr	r3, [pc, #88]	; (691c <sd_mmc_wait_end_of_read_blocks+0x60>)
    68c2:	6898      	ldr	r0, [r3, #8]
    68c4:	4b16      	ldr	r3, [pc, #88]	; (6920 <sd_mmc_wait_end_of_read_blocks+0x64>)
    68c6:	4798      	blx	r3
    68c8:	b908      	cbnz	r0, 68ce <sd_mmc_wait_end_of_read_blocks+0x12>
		return SD_MMC_ERR_COMM;
    68ca:	2005      	movs	r0, #5
    68cc:	bd10      	pop	{r4, pc}
	}
	if (abort) {
    68ce:	b194      	cbz	r4, 68f6 <sd_mmc_wait_end_of_read_blocks+0x3a>
		sd_mmc_nb_block_remaining = 0;
    68d0:	2200      	movs	r2, #0
    68d2:	4b12      	ldr	r3, [pc, #72]	; (691c <sd_mmc_wait_end_of_read_blocks+0x60>)
    68d4:	861a      	strh	r2, [r3, #48]	; 0x30
	} else if (sd_mmc_nb_block_remaining) {
		return SD_MMC_OK;
	}

	/* All blocks are transfered then stop read operation */
	if (sd_mmc_nb_block_to_tranfer == 1) {
    68d6:	4b11      	ldr	r3, [pc, #68]	; (691c <sd_mmc_wait_end_of_read_blocks+0x60>)
    68d8:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
    68da:	2b01      	cmp	r3, #1
    68dc:	d011      	beq.n	6902 <sd_mmc_wait_end_of_read_blocks+0x46>
		return SD_MMC_OK;
	}
	/* WORKAROUND for no compliance card (Atmel Internal ref. !MMC7 !SD19):
	 * The errors on this command must be ignored
	 * and one retry can be necessary in SPI mode for no compliance card.*/
	if (!driver_adtc_stop(sd_mmc_hal, SDMMC_CMD12_STOP_TRANSMISSION, 0)) {
    68de:	2200      	movs	r2, #0
    68e0:	f243 110c 	movw	r1, #12556	; 0x310c
    68e4:	4b0d      	ldr	r3, [pc, #52]	; (691c <sd_mmc_wait_end_of_read_blocks+0x60>)
    68e6:	6898      	ldr	r0, [r3, #8]
    68e8:	4b0e      	ldr	r3, [pc, #56]	; (6924 <sd_mmc_wait_end_of_read_blocks+0x68>)
    68ea:	4798      	blx	r3
    68ec:	b168      	cbz	r0, 690a <sd_mmc_wait_end_of_read_blocks+0x4e>
		driver_adtc_stop(sd_mmc_hal, SDMMC_CMD12_STOP_TRANSMISSION, 0);
	}
	sd_mmc_deselect_slot();
    68ee:	4b0e      	ldr	r3, [pc, #56]	; (6928 <sd_mmc_wait_end_of_read_blocks+0x6c>)
    68f0:	4798      	blx	r3
	return SD_MMC_OK;
    68f2:	2000      	movs	r0, #0
    68f4:	bd10      	pop	{r4, pc}
	} else if (sd_mmc_nb_block_remaining) {
    68f6:	4b09      	ldr	r3, [pc, #36]	; (691c <sd_mmc_wait_end_of_read_blocks+0x60>)
    68f8:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
    68fa:	2b00      	cmp	r3, #0
    68fc:	d0eb      	beq.n	68d6 <sd_mmc_wait_end_of_read_blocks+0x1a>
		return SD_MMC_OK;
    68fe:	2000      	movs	r0, #0
}
    6900:	bd10      	pop	{r4, pc}
		sd_mmc_deselect_slot();
    6902:	4b09      	ldr	r3, [pc, #36]	; (6928 <sd_mmc_wait_end_of_read_blocks+0x6c>)
    6904:	4798      	blx	r3
		return SD_MMC_OK;
    6906:	2000      	movs	r0, #0
    6908:	bd10      	pop	{r4, pc}
		driver_adtc_stop(sd_mmc_hal, SDMMC_CMD12_STOP_TRANSMISSION, 0);
    690a:	2200      	movs	r2, #0
    690c:	f243 110c 	movw	r1, #12556	; 0x310c
    6910:	4b02      	ldr	r3, [pc, #8]	; (691c <sd_mmc_wait_end_of_read_blocks+0x60>)
    6912:	6898      	ldr	r0, [r3, #8]
    6914:	4b03      	ldr	r3, [pc, #12]	; (6924 <sd_mmc_wait_end_of_read_blocks+0x68>)
    6916:	4798      	blx	r3
    6918:	e7e9      	b.n	68ee <sd_mmc_wait_end_of_read_blocks+0x32>
    691a:	bf00      	nop
    691c:	20000620 	.word	0x20000620
    6920:	000027e9 	.word	0x000027e9
    6924:	000026b5 	.word	0x000026b5
    6928:	00006055 	.word	0x00006055

0000692c <sd_mmc_init_write_blocks>:

sd_mmc_err_t sd_mmc_init_write_blocks(uint8_t slot, uint32_t start, uint16_t nb_block)
{
    692c:	b5f0      	push	{r4, r5, r6, r7, lr}
    692e:	b083      	sub	sp, #12
    6930:	4607      	mov	r7, r0
    6932:	460e      	mov	r6, r1
    6934:	4615      	mov	r5, r2
	sd_mmc_err_t sd_mmc_err;
	uint32_t     cmd, arg, resp;

	sd_mmc_err = sd_mmc_select_slot(slot);
    6936:	4b1c      	ldr	r3, [pc, #112]	; (69a8 <sd_mmc_init_write_blocks+0x7c>)
    6938:	4798      	blx	r3
	if (sd_mmc_err != SD_MMC_OK) {
    693a:	4604      	mov	r4, r0
    693c:	b110      	cbz	r0, 6944 <sd_mmc_init_write_blocks+0x18>
	}

	sd_mmc_nb_block_remaining  = nb_block;
	sd_mmc_nb_block_to_tranfer = nb_block;
	return SD_MMC_OK;
}
    693e:	4620      	mov	r0, r4
    6940:	b003      	add	sp, #12
    6942:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (sd_mmc_is_write_protected(slot)) {
    6944:	4638      	mov	r0, r7
    6946:	4b19      	ldr	r3, [pc, #100]	; (69ac <sd_mmc_init_write_blocks+0x80>)
    6948:	4798      	blx	r3
    694a:	b9d0      	cbnz	r0, 6982 <sd_mmc_init_write_blocks+0x56>
		cmd = SDMMC_CMD24_WRITE_BLOCK;
    694c:	4b18      	ldr	r3, [pc, #96]	; (69b0 <sd_mmc_init_write_blocks+0x84>)
    694e:	4919      	ldr	r1, [pc, #100]	; (69b4 <sd_mmc_init_write_blocks+0x88>)
    6950:	2d01      	cmp	r5, #1
    6952:	bf98      	it	ls
    6954:	4619      	movls	r1, r3
	if (sd_mmc_card->type & CARD_TYPE_HC) {
    6956:	4b18      	ldr	r3, [pc, #96]	; (69b8 <sd_mmc_init_write_blocks+0x8c>)
    6958:	681b      	ldr	r3, [r3, #0]
    695a:	7adb      	ldrb	r3, [r3, #11]
    695c:	f013 0f08 	tst.w	r3, #8
		arg = (start * SD_MMC_BLOCK_SIZE);
    6960:	bf08      	it	eq
    6962:	0276      	lsleq	r6, r6, #9
	if (!driver_adtc_start(sd_mmc_hal, cmd, arg, SD_MMC_BLOCK_SIZE, nb_block, true)) {
    6964:	4b14      	ldr	r3, [pc, #80]	; (69b8 <sd_mmc_init_write_blocks+0x8c>)
    6966:	6898      	ldr	r0, [r3, #8]
    6968:	2301      	movs	r3, #1
    696a:	9301      	str	r3, [sp, #4]
    696c:	9500      	str	r5, [sp, #0]
    696e:	f44f 7300 	mov.w	r3, #512	; 0x200
    6972:	4632      	mov	r2, r6
    6974:	4e11      	ldr	r6, [pc, #68]	; (69bc <sd_mmc_init_write_blocks+0x90>)
    6976:	47b0      	blx	r6
    6978:	b938      	cbnz	r0, 698a <sd_mmc_init_write_blocks+0x5e>
		sd_mmc_deselect_slot();
    697a:	4b11      	ldr	r3, [pc, #68]	; (69c0 <sd_mmc_init_write_blocks+0x94>)
    697c:	4798      	blx	r3
		return SD_MMC_ERR_COMM;
    697e:	2405      	movs	r4, #5
    6980:	e7dd      	b.n	693e <sd_mmc_init_write_blocks+0x12>
		sd_mmc_deselect_slot();
    6982:	4b0f      	ldr	r3, [pc, #60]	; (69c0 <sd_mmc_init_write_blocks+0x94>)
    6984:	4798      	blx	r3
		return SD_MMC_ERR_WP;
    6986:	2407      	movs	r4, #7
    6988:	e7d9      	b.n	693e <sd_mmc_init_write_blocks+0x12>
	resp = driver_get_response(sd_mmc_hal);
    698a:	4b0b      	ldr	r3, [pc, #44]	; (69b8 <sd_mmc_init_write_blocks+0x8c>)
    698c:	6898      	ldr	r0, [r3, #8]
    698e:	4b0d      	ldr	r3, [pc, #52]	; (69c4 <sd_mmc_init_write_blocks+0x98>)
    6990:	4798      	blx	r3
	if (resp & CARD_STATUS_ERR_RD_WR) {
    6992:	4b0d      	ldr	r3, [pc, #52]	; (69c8 <sd_mmc_init_write_blocks+0x9c>)
    6994:	4003      	ands	r3, r0
    6996:	b91b      	cbnz	r3, 69a0 <sd_mmc_init_write_blocks+0x74>
	sd_mmc_nb_block_remaining  = nb_block;
    6998:	4b07      	ldr	r3, [pc, #28]	; (69b8 <sd_mmc_init_write_blocks+0x8c>)
    699a:	861d      	strh	r5, [r3, #48]	; 0x30
	sd_mmc_nb_block_to_tranfer = nb_block;
    699c:	871d      	strh	r5, [r3, #56]	; 0x38
	return SD_MMC_OK;
    699e:	e7ce      	b.n	693e <sd_mmc_init_write_blocks+0x12>
		sd_mmc_deselect_slot();
    69a0:	4b07      	ldr	r3, [pc, #28]	; (69c0 <sd_mmc_init_write_blocks+0x94>)
    69a2:	4798      	blx	r3
		return SD_MMC_ERR_COMM;
    69a4:	2405      	movs	r4, #5
    69a6:	e7ca      	b.n	693e <sd_mmc_init_write_blocks+0x12>
    69a8:	00005ed9 	.word	0x00005ed9
    69ac:	00006721 	.word	0x00006721
    69b0:	00089118 	.word	0x00089118
    69b4:	00109119 	.word	0x00109119
    69b8:	20000620 	.word	0x20000620
    69bc:	0000273d 	.word	0x0000273d
    69c0:	00006055 	.word	0x00006055
    69c4:	000026e5 	.word	0x000026e5
    69c8:	e4580000 	.word	0xe4580000

000069cc <sd_mmc_start_write_blocks>:

sd_mmc_err_t sd_mmc_start_write_blocks(const void *src, uint16_t nb_block)
{
    69cc:	b570      	push	{r4, r5, r6, lr}
    69ce:	4606      	mov	r6, r0
    69d0:	460c      	mov	r4, r1
	ASSERT(sd_mmc_nb_block_remaining >= nb_block);
    69d2:	4d0d      	ldr	r5, [pc, #52]	; (6a08 <sd_mmc_start_write_blocks+0x3c>)
    69d4:	8e28      	ldrh	r0, [r5, #48]	; 0x30
    69d6:	f240 6204 	movw	r2, #1540	; 0x604
    69da:	490c      	ldr	r1, [pc, #48]	; (6a0c <sd_mmc_start_write_blocks+0x40>)
    69dc:	42a0      	cmp	r0, r4
    69de:	bf34      	ite	cc
    69e0:	2000      	movcc	r0, #0
    69e2:	2001      	movcs	r0, #1
    69e4:	4b0a      	ldr	r3, [pc, #40]	; (6a10 <sd_mmc_start_write_blocks+0x44>)
    69e6:	4798      	blx	r3
	if (!driver_start_write_blocks(sd_mmc_hal, src, nb_block)) {
    69e8:	4622      	mov	r2, r4
    69ea:	4631      	mov	r1, r6
    69ec:	68a8      	ldr	r0, [r5, #8]
    69ee:	4b09      	ldr	r3, [pc, #36]	; (6a14 <sd_mmc_start_write_blocks+0x48>)
    69f0:	4798      	blx	r3
    69f2:	b918      	cbnz	r0, 69fc <sd_mmc_start_write_blocks+0x30>
		sd_mmc_nb_block_remaining = 0;
    69f4:	2200      	movs	r2, #0
    69f6:	862a      	strh	r2, [r5, #48]	; 0x30
		return SD_MMC_ERR_COMM;
    69f8:	2005      	movs	r0, #5
    69fa:	bd70      	pop	{r4, r5, r6, pc}
	}
	sd_mmc_nb_block_remaining -= nb_block;
    69fc:	4a02      	ldr	r2, [pc, #8]	; (6a08 <sd_mmc_start_write_blocks+0x3c>)
    69fe:	8e13      	ldrh	r3, [r2, #48]	; 0x30
    6a00:	1b1c      	subs	r4, r3, r4
    6a02:	8614      	strh	r4, [r2, #48]	; 0x30
	return SD_MMC_OK;
    6a04:	2000      	movs	r0, #0
}
    6a06:	bd70      	pop	{r4, r5, r6, pc}
    6a08:	20000620 	.word	0x20000620
    6a0c:	00009a50 	.word	0x00009a50
    6a10:	00003205 	.word	0x00003205
    6a14:	000027b5 	.word	0x000027b5

00006a18 <sd_mmc_wait_end_of_write_blocks>:

sd_mmc_err_t sd_mmc_wait_end_of_write_blocks(bool abort)
{
    6a18:	b510      	push	{r4, lr}
    6a1a:	4604      	mov	r4, r0
	if (!driver_wait_end_of_write_blocks(sd_mmc_hal)) {
    6a1c:	4b14      	ldr	r3, [pc, #80]	; (6a70 <sd_mmc_wait_end_of_write_blocks+0x58>)
    6a1e:	6898      	ldr	r0, [r3, #8]
    6a20:	4b14      	ldr	r3, [pc, #80]	; (6a74 <sd_mmc_wait_end_of_write_blocks+0x5c>)
    6a22:	4798      	blx	r3
    6a24:	b908      	cbnz	r0, 6a2a <sd_mmc_wait_end_of_write_blocks+0x12>
		return SD_MMC_ERR_COMM;
    6a26:	2005      	movs	r0, #5
    6a28:	bd10      	pop	{r4, pc}
	}
	if (abort) {
    6a2a:	b194      	cbz	r4, 6a52 <sd_mmc_wait_end_of_write_blocks+0x3a>
		sd_mmc_nb_block_remaining = 0;
    6a2c:	2200      	movs	r2, #0
    6a2e:	4b10      	ldr	r3, [pc, #64]	; (6a70 <sd_mmc_wait_end_of_write_blocks+0x58>)
    6a30:	861a      	strh	r2, [r3, #48]	; 0x30
	} else if (sd_mmc_nb_block_remaining) {
		return SD_MMC_OK;
	}

	/* All blocks are transfered then stop write operation */
	if (sd_mmc_nb_block_to_tranfer == 1) {
    6a32:	4b0f      	ldr	r3, [pc, #60]	; (6a70 <sd_mmc_wait_end_of_write_blocks+0x58>)
    6a34:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
    6a36:	2b01      	cmp	r3, #1
    6a38:	d011      	beq.n	6a5e <sd_mmc_wait_end_of_write_blocks+0x46>
		return SD_MMC_OK;
	}

	/* Note: SPI multiblock writes terminate using a special
	 * token, not a STOP_TRANSMISSION request.*/
	if (!driver_adtc_stop(sd_mmc_hal, SDMMC_CMD12_STOP_TRANSMISSION, 0)) {
    6a3a:	2200      	movs	r2, #0
    6a3c:	f243 110c 	movw	r1, #12556	; 0x310c
    6a40:	4b0b      	ldr	r3, [pc, #44]	; (6a70 <sd_mmc_wait_end_of_write_blocks+0x58>)
    6a42:	6898      	ldr	r0, [r3, #8]
    6a44:	4b0c      	ldr	r3, [pc, #48]	; (6a78 <sd_mmc_wait_end_of_write_blocks+0x60>)
    6a46:	4798      	blx	r3
    6a48:	b968      	cbnz	r0, 6a66 <sd_mmc_wait_end_of_write_blocks+0x4e>
		sd_mmc_deselect_slot();
    6a4a:	4b0c      	ldr	r3, [pc, #48]	; (6a7c <sd_mmc_wait_end_of_write_blocks+0x64>)
    6a4c:	4798      	blx	r3
		return SD_MMC_ERR_COMM;
    6a4e:	2005      	movs	r0, #5
    6a50:	bd10      	pop	{r4, pc}
	} else if (sd_mmc_nb_block_remaining) {
    6a52:	4b07      	ldr	r3, [pc, #28]	; (6a70 <sd_mmc_wait_end_of_write_blocks+0x58>)
    6a54:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
    6a56:	2b00      	cmp	r3, #0
    6a58:	d0eb      	beq.n	6a32 <sd_mmc_wait_end_of_write_blocks+0x1a>
		return SD_MMC_OK;
    6a5a:	2000      	movs	r0, #0
	}

	sd_mmc_deselect_slot();
	return SD_MMC_OK;
}
    6a5c:	bd10      	pop	{r4, pc}
		sd_mmc_deselect_slot();
    6a5e:	4b07      	ldr	r3, [pc, #28]	; (6a7c <sd_mmc_wait_end_of_write_blocks+0x64>)
    6a60:	4798      	blx	r3
		return SD_MMC_OK;
    6a62:	2000      	movs	r0, #0
    6a64:	bd10      	pop	{r4, pc}
	sd_mmc_deselect_slot();
    6a66:	4b05      	ldr	r3, [pc, #20]	; (6a7c <sd_mmc_wait_end_of_write_blocks+0x64>)
    6a68:	4798      	blx	r3
	return SD_MMC_OK;
    6a6a:	2000      	movs	r0, #0
    6a6c:	bd10      	pop	{r4, pc}
    6a6e:	bf00      	nop
    6a70:	20000620 	.word	0x20000620
    6a74:	00002811 	.word	0x00002811
    6a78:	000026b5 	.word	0x000026b5
    6a7c:	00006055 	.word	0x00006055

00006a80 <sd_mmc_stack_init>:
		sdio_read_extended(0, 0, 0, 1, sd_mmc_block, 22);
	}
}

void sd_mmc_stack_init(void)
{
    6a80:	b508      	push	{r3, lr}

	sd_mmc_init(&IO_BUS, SDMMC_cd, SDMMC_wp);
    6a82:	4903      	ldr	r1, [pc, #12]	; (6a90 <sd_mmc_stack_init+0x10>)
    6a84:	460a      	mov	r2, r1
    6a86:	3104      	adds	r1, #4
    6a88:	4802      	ldr	r0, [pc, #8]	; (6a94 <sd_mmc_stack_init+0x14>)
    6a8a:	4b03      	ldr	r3, [pc, #12]	; (6a98 <sd_mmc_stack_init+0x18>)
    6a8c:	4798      	blx	r3
    6a8e:	bd08      	pop	{r3, pc}
    6a90:	20000028 	.word	0x20000028
    6a94:	20001628 	.word	0x20001628
    6a98:	00006075 	.word	0x00006075

00006a9c <SPI_buffering>:
static uint8_t ans[512];
static uint8_t rec[512];
static uint16_t rec_index;

static void SPI_buffering(const struct spi_s_async_descriptor *const desc)
{
    6a9c:	b500      	push	{lr}
    6a9e:	b083      	sub	sp, #12
	struct io_descriptor *io;
	spi_s_async_get_io_descriptor(&SPI_0, &io);
    6aa0:	a901      	add	r1, sp, #4
    6aa2:	4808      	ldr	r0, [pc, #32]	; (6ac4 <SPI_buffering+0x28>)
    6aa4:	4b08      	ldr	r3, [pc, #32]	; (6ac8 <SPI_buffering+0x2c>)
    6aa6:	4798      	blx	r3
	io_read(io, &rec[rec_index++], 1);
    6aa8:	4908      	ldr	r1, [pc, #32]	; (6acc <SPI_buffering+0x30>)
    6aaa:	880b      	ldrh	r3, [r1, #0]
    6aac:	1c5a      	adds	r2, r3, #1
    6aae:	f821 2b04 	strh.w	r2, [r1], #4
    6ab2:	2201      	movs	r2, #1
    6ab4:	4419      	add	r1, r3
    6ab6:	9801      	ldr	r0, [sp, #4]
    6ab8:	4b05      	ldr	r3, [pc, #20]	; (6ad0 <SPI_buffering+0x34>)
    6aba:	4798      	blx	r3
	
}
    6abc:	b003      	add	sp, #12
    6abe:	f85d fb04 	ldr.w	pc, [sp], #4
    6ac2:	bf00      	nop
    6ac4:	200015dc 	.word	0x200015dc
    6ac8:	00002c39 	.word	0x00002c39
    6acc:	2000065c 	.word	0x2000065c
    6ad0:	00002571 	.word	0x00002571

00006ad4 <complete_cb_SPI_0>:



static void complete_cb_SPI_0(const struct spi_s_async_descriptor *const desc)
{
    6ad4:	b510      	push	{r4, lr}
    6ad6:	b082      	sub	sp, #8
	
	struct io_descriptor *io;
	spi_s_async_get_io_descriptor(&SPI_0, &io);
    6ad8:	a901      	add	r1, sp, #4
    6ada:	482b      	ldr	r0, [pc, #172]	; (6b88 <complete_cb_SPI_0+0xb4>)
    6adc:	4b2b      	ldr	r3, [pc, #172]	; (6b8c <complete_cb_SPI_0+0xb8>)
    6ade:	4798      	blx	r3
	uint8_t x,y,z;
	x=y=z=0;
	x=rec[0];
    6ae0:	4b2b      	ldr	r3, [pc, #172]	; (6b90 <complete_cb_SPI_0+0xbc>)
    6ae2:	791a      	ldrb	r2, [r3, #4]
	y=rec[1];
    6ae4:	795b      	ldrb	r3, [r3, #5]

	//add read/edit machine conf
	//add read datalog
	
	if(x==1){
    6ae6:	2a01      	cmp	r2, #1
    6ae8:	d00a      	beq.n	6b00 <complete_cb_SPI_0+0x2c>
		//read active
		ans[0]=0xFF;
		ans[1]=machine_confs[y].active;
		io_write(io, ans, 2);
	}
	else if(x==3){
    6aea:	2a03      	cmp	r2, #3
    6aec:	d01a      	beq.n	6b24 <complete_cb_SPI_0+0x50>
		//edit active
		machine_confs[y].active=rec[2];
	}
	else if (x==2)	{
    6aee:	2a02      	cmp	r2, #2
    6af0:	d020      	beq.n	6b34 <complete_cb_SPI_0+0x60>
		for (j=0;j<sizeof(format_t);j++){
			ans[j+1]=copier[j];
		}
		io_write(io, ans, j+1);
	}
	else if (x==4)	{
    6af2:	2a04      	cmp	r2, #4
    6af4:	d038      	beq.n	6b68 <complete_cb_SPI_0+0x94>
		uint8_t* copier = &formats[y];
		for (j=0;j<sizeof(format_t);j++){
			copier[j]=rec[j+2];
		}
	}
	rec_index=0;
    6af6:	2200      	movs	r2, #0
    6af8:	4b25      	ldr	r3, [pc, #148]	; (6b90 <complete_cb_SPI_0+0xbc>)
    6afa:	801a      	strh	r2, [r3, #0]
}
    6afc:	b002      	add	sp, #8
    6afe:	bd10      	pop	{r4, pc}
		ans[0]=0xFF;
    6b00:	4923      	ldr	r1, [pc, #140]	; (6b90 <complete_cb_SPI_0+0xbc>)
    6b02:	22ff      	movs	r2, #255	; 0xff
    6b04:	f881 2204 	strb.w	r2, [r1, #516]	; 0x204
		ans[1]=machine_confs[y].active;
    6b08:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    6b0c:	4a21      	ldr	r2, [pc, #132]	; (6b94 <complete_cb_SPI_0+0xc0>)
    6b0e:	4413      	add	r3, r2
    6b10:	785b      	ldrb	r3, [r3, #1]
    6b12:	f881 3205 	strb.w	r3, [r1, #517]	; 0x205
		io_write(io, ans, 2);
    6b16:	2202      	movs	r2, #2
    6b18:	f501 7101 	add.w	r1, r1, #516	; 0x204
    6b1c:	9801      	ldr	r0, [sp, #4]
    6b1e:	4b1e      	ldr	r3, [pc, #120]	; (6b98 <complete_cb_SPI_0+0xc4>)
    6b20:	4798      	blx	r3
    6b22:	e7e8      	b.n	6af6 <complete_cb_SPI_0+0x22>
		machine_confs[y].active=rec[2];
    6b24:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    6b28:	4a1a      	ldr	r2, [pc, #104]	; (6b94 <complete_cb_SPI_0+0xc0>)
    6b2a:	4413      	add	r3, r2
    6b2c:	4a18      	ldr	r2, [pc, #96]	; (6b90 <complete_cb_SPI_0+0xbc>)
    6b2e:	7992      	ldrb	r2, [r2, #6]
    6b30:	705a      	strb	r2, [r3, #1]
    6b32:	e7e0      	b.n	6af6 <complete_cb_SPI_0+0x22>
		ans[0]=0xFF;
    6b34:	4816      	ldr	r0, [pc, #88]	; (6b90 <complete_cb_SPI_0+0xbc>)
    6b36:	22ff      	movs	r2, #255	; 0xff
    6b38:	f880 2204 	strb.w	r2, [r0, #516]	; 0x204
    6b3c:	4a17      	ldr	r2, [pc, #92]	; (6b9c <complete_cb_SPI_0+0xc8>)
    6b3e:	f44f 718e 	mov.w	r1, #284	; 0x11c
    6b42:	fb01 2303 	mla	r3, r1, r3, r2
    6b46:	f500 7201 	add.w	r2, r0, #516	; 0x204
    6b4a:	f500 7048 	add.w	r0, r0, #800	; 0x320
			ans[j+1]=copier[j];
    6b4e:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    6b52:	f802 1f01 	strb.w	r1, [r2, #1]!
		for (j=0;j<sizeof(format_t);j++){
    6b56:	4282      	cmp	r2, r0
    6b58:	d1f9      	bne.n	6b4e <complete_cb_SPI_0+0x7a>
		io_write(io, ans, j+1);
    6b5a:	f240 121d 	movw	r2, #285	; 0x11d
    6b5e:	4910      	ldr	r1, [pc, #64]	; (6ba0 <complete_cb_SPI_0+0xcc>)
    6b60:	9801      	ldr	r0, [sp, #4]
    6b62:	4b0d      	ldr	r3, [pc, #52]	; (6b98 <complete_cb_SPI_0+0xc4>)
    6b64:	4798      	blx	r3
    6b66:	e7c6      	b.n	6af6 <complete_cb_SPI_0+0x22>
    6b68:	4809      	ldr	r0, [pc, #36]	; (6b90 <complete_cb_SPI_0+0xbc>)
    6b6a:	1d42      	adds	r2, r0, #5
    6b6c:	490b      	ldr	r1, [pc, #44]	; (6b9c <complete_cb_SPI_0+0xc8>)
    6b6e:	f44f 748e 	mov.w	r4, #284	; 0x11c
    6b72:	fb04 1303 	mla	r3, r4, r3, r1
    6b76:	f200 1021 	addw	r0, r0, #289	; 0x121
			copier[j]=rec[j+2];
    6b7a:	f812 1f01 	ldrb.w	r1, [r2, #1]!
    6b7e:	f803 1f01 	strb.w	r1, [r3, #1]!
		for (j=0;j<sizeof(format_t);j++){
    6b82:	4282      	cmp	r2, r0
    6b84:	d1f9      	bne.n	6b7a <complete_cb_SPI_0+0xa6>
    6b86:	e7b6      	b.n	6af6 <complete_cb_SPI_0+0x22>
    6b88:	200015dc 	.word	0x200015dc
    6b8c:	00002c39 	.word	0x00002c39
    6b90:	2000065c 	.word	0x2000065c
    6b94:	200023c8 	.word	0x200023c8
    6b98:	00002541 	.word	0x00002541
    6b9c:	20001ae7 	.word	0x20001ae7
    6ba0:	20000860 	.word	0x20000860

00006ba4 <SPI_0_example>:

void SPI_0_example(void)
{
    6ba4:	b538      	push	{r3, r4, r5, lr}
	spi_s_async_register_callback(&SPI_0, SPI_S_CB_COMPLETE, (FUNC_PTR)complete_cb_SPI_0);
    6ba6:	4c08      	ldr	r4, [pc, #32]	; (6bc8 <SPI_0_example+0x24>)
    6ba8:	4a08      	ldr	r2, [pc, #32]	; (6bcc <SPI_0_example+0x28>)
    6baa:	2102      	movs	r1, #2
    6bac:	4620      	mov	r0, r4
    6bae:	4d08      	ldr	r5, [pc, #32]	; (6bd0 <SPI_0_example+0x2c>)
    6bb0:	47a8      	blx	r5
	spi_s_async_register_callback(&SPI_0, SPI_S_CB_RX, (FUNC_PTR)SPI_buffering);
    6bb2:	4a08      	ldr	r2, [pc, #32]	; (6bd4 <SPI_0_example+0x30>)
    6bb4:	2101      	movs	r1, #1
    6bb6:	4620      	mov	r0, r4
    6bb8:	47a8      	blx	r5
	spi_s_async_enable(&SPI_0);
    6bba:	4620      	mov	r0, r4
    6bbc:	4b06      	ldr	r3, [pc, #24]	; (6bd8 <SPI_0_example+0x34>)
    6bbe:	4798      	blx	r3
	rec_index=0;
    6bc0:	2200      	movs	r2, #0
    6bc2:	4b06      	ldr	r3, [pc, #24]	; (6bdc <SPI_0_example+0x38>)
    6bc4:	801a      	strh	r2, [r3, #0]
    6bc6:	bd38      	pop	{r3, r4, r5, pc}
    6bc8:	200015dc 	.word	0x200015dc
    6bcc:	00006ad5 	.word	0x00006ad5
    6bd0:	00002bf5 	.word	0x00002bf5
    6bd4:	00006a9d 	.word	0x00006a9d
    6bd8:	00002b99 	.word	0x00002b99
    6bdc:	2000065c 	.word	0x2000065c

00006be0 <vListInitialise>:
void vListInitialise(List_t *const pxList)
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = (ListItem_t *)&(
    6be0:	f100 0308 	add.w	r3, r0, #8
    6be4:	6043      	str	r3, [r0, #4]
	    pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is
	                          checked and valid. */

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    6be6:	f04f 32ff 	mov.w	r2, #4294967295
    6bea:	6082      	str	r2, [r0, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = (ListItem_t *)&(pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as
    6bec:	60c3      	str	r3, [r0, #12]
	                                                                the list end to save RAM.  This is checked and
	                                                                valid. */
	pxList->xListEnd.pxPrevious = (ListItem_t *)&(
    6bee:	6103      	str	r3, [r0, #16]
	    pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is
	                          checked and valid. */

	pxList->uxNumberOfItems = (UBaseType_t)0U;
    6bf0:	2300      	movs	r3, #0
    6bf2:	6003      	str	r3, [r0, #0]
    6bf4:	4770      	bx	lr

00006bf6 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem(ListItem_t *const pxItem)
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    6bf6:	2300      	movs	r3, #0
    6bf8:	6103      	str	r3, [r0, #16]
    6bfa:	4770      	bx	lr

00006bfc <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd(List_t *const pxList, ListItem_t *const pxNewListItem)
{
	ListItem_t *const pxIndex = pxList->pxIndex;
    6bfc:	6843      	ldr	r3, [r0, #4]
	listTEST_LIST_ITEM_INTEGRITY(pxNewListItem);

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext     = pxIndex;
    6bfe:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    6c00:	689a      	ldr	r2, [r3, #8]
    6c02:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    6c04:	689a      	ldr	r2, [r3, #8]
    6c06:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious         = pxNewListItem;
    6c08:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = (void *)pxList;
    6c0a:	6108      	str	r0, [r1, #16]

	(pxList->uxNumberOfItems)++;
    6c0c:	6803      	ldr	r3, [r0, #0]
    6c0e:	3301      	adds	r3, #1
    6c10:	6003      	str	r3, [r0, #0]
    6c12:	4770      	bx	lr

00006c14 <vListInsert>:
}
/*-----------------------------------------------------------*/

void vListInsert(List_t *const pxList, ListItem_t *const pxNewListItem)
{
    6c14:	b430      	push	{r4, r5}
	ListItem_t *     pxIterator;
	const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    6c16:	680d      	ldr	r5, [r1, #0]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if (xValueOfInsertion == portMAX_DELAY) {
    6c18:	f1b5 3fff 	cmp.w	r5, #4294967295
    6c1c:	d002      	beq.n	6c24 <vListInsert+0x10>
		    4) Using a queue or semaphore before it has been initialised or
		       before the scheduler has been started (are interrupts firing
		       before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for (pxIterator = (ListItem_t *)&(pxList->xListEnd); pxIterator->pxNext->xItemValue <= xValueOfInsertion;
    6c1e:	f100 0208 	add.w	r2, r0, #8
    6c22:	e002      	b.n	6c2a <vListInsert+0x16>
		pxIterator = pxList->xListEnd.pxPrevious;
    6c24:	6902      	ldr	r2, [r0, #16]
    6c26:	e004      	b.n	6c32 <vListInsert+0x1e>
		     pxIterator
		     = pxIterator
    6c28:	461a      	mov	r2, r3
		for (pxIterator = (ListItem_t *)&(pxList->xListEnd); pxIterator->pxNext->xItemValue <= xValueOfInsertion;
    6c2a:	6853      	ldr	r3, [r2, #4]
    6c2c:	681c      	ldr	r4, [r3, #0]
    6c2e:	42a5      	cmp	r5, r4
    6c30:	d2fa      	bcs.n	6c28 <vListInsert+0x14>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext             = pxIterator->pxNext;
    6c32:	6853      	ldr	r3, [r2, #4]
    6c34:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    6c36:	6099      	str	r1, [r3, #8]
	pxNewListItem->pxPrevious         = pxIterator;
    6c38:	608a      	str	r2, [r1, #8]
	pxIterator->pxNext                = pxNewListItem;
    6c3a:	6051      	str	r1, [r2, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = (void *)pxList;
    6c3c:	6108      	str	r0, [r1, #16]

	(pxList->uxNumberOfItems)++;
    6c3e:	6803      	ldr	r3, [r0, #0]
    6c40:	3301      	adds	r3, #1
    6c42:	6003      	str	r3, [r0, #0]
}
    6c44:	bc30      	pop	{r4, r5}
    6c46:	4770      	bx	lr

00006c48 <uxListRemove>:

UBaseType_t uxListRemove(ListItem_t *const pxItemToRemove)
{
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	List_t *const pxList = (List_t *)pxItemToRemove->pvContainer;
    6c48:	6903      	ldr	r3, [r0, #16]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    6c4a:	6842      	ldr	r2, [r0, #4]
    6c4c:	6881      	ldr	r1, [r0, #8]
    6c4e:	6091      	str	r1, [r2, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    6c50:	6882      	ldr	r2, [r0, #8]
    6c52:	6841      	ldr	r1, [r0, #4]
    6c54:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if (pxList->pxIndex == pxItemToRemove) {
    6c56:	685a      	ldr	r2, [r3, #4]
    6c58:	4290      	cmp	r0, r2
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    6c5a:	bf04      	itt	eq
    6c5c:	6882      	ldreq	r2, [r0, #8]
    6c5e:	605a      	streq	r2, [r3, #4]
	} else {
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    6c60:	2200      	movs	r2, #0
    6c62:	6102      	str	r2, [r0, #16]
	(pxList->uxNumberOfItems)--;
    6c64:	681a      	ldr	r2, [r3, #0]
    6c66:	3a01      	subs	r2, #1
    6c68:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
    6c6a:	6818      	ldr	r0, [r3, #0]
}
    6c6c:	4770      	bx	lr
	...

00006c70 <prvTaskExitError>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

static void prvTaskExitError(void)
{
    6c70:	b082      	sub	sp, #8
	volatile uint32_t ulDummy = 0;
    6c72:	2300      	movs	r3, #0
    6c74:	9301      	str	r3, [sp, #4]
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT(uxCriticalNesting == ~0UL);
    6c76:	4b0d      	ldr	r3, [pc, #52]	; (6cac <prvTaskExitError+0x3c>)
    6c78:	681b      	ldr	r3, [r3, #0]
    6c7a:	f1b3 3fff 	cmp.w	r3, #4294967295
    6c7e:	d008      	beq.n	6c92 <prvTaskExitError+0x22>

portFORCE_INLINE static void vPortRaiseBASEPRI(void)
{
	uint32_t ulNewBASEPRI;

	__asm volatile("	mov %0, %1												\n"
    6c80:	f04f 0380 	mov.w	r3, #128	; 0x80
    6c84:	f383 8811 	msr	BASEPRI, r3
    6c88:	f3bf 8f6f 	isb	sy
    6c8c:	f3bf 8f4f 	dsb	sy
    6c90:	e7fe      	b.n	6c90 <prvTaskExitError+0x20>
    6c92:	f04f 0380 	mov.w	r3, #128	; 0x80
    6c96:	f383 8811 	msr	BASEPRI, r3
    6c9a:	f3bf 8f6f 	isb	sy
    6c9e:	f3bf 8f4f 	dsb	sy
	portDISABLE_INTERRUPTS();
	while (ulDummy == 0) {
    6ca2:	9b01      	ldr	r3, [sp, #4]
    6ca4:	2b00      	cmp	r3, #0
    6ca6:	d0fc      	beq.n	6ca2 <prvTaskExitError+0x32>
		about code appearing after this function is called - making ulDummy
		volatile makes the compiler think the function could return and
		therefore not output an 'unreachable code' warning for code that appears
		after it. */
	}
}
    6ca8:	b002      	add	sp, #8
    6caa:	4770      	bx	lr
    6cac:	20000030 	.word	0x20000030

00006cb0 <prvPortStartFirstTask>:
{
	/* Start the first task.  This also clears the bit that indicates the FPU is
	in use in case the FPU was used before the scheduler was started - which
	would otherwise result in the unnecessary leaving of space in the SVC stack
	for lazy saving of FPU registers. */
	__asm volatile(" ldr r0, =0xE000ED08 	\n" /* Use the NVIC offset register to locate the stack. */
    6cb0:	4808      	ldr	r0, [pc, #32]	; (6cd4 <prvPortStartFirstTask+0x24>)
    6cb2:	6800      	ldr	r0, [r0, #0]
    6cb4:	6800      	ldr	r0, [r0, #0]
    6cb6:	f380 8808 	msr	MSP, r0
    6cba:	f04f 0000 	mov.w	r0, #0
    6cbe:	f380 8814 	msr	CONTROL, r0
    6cc2:	b662      	cpsie	i
    6cc4:	b661      	cpsie	f
    6cc6:	f3bf 8f4f 	dsb	sy
    6cca:	f3bf 8f6f 	isb	sy
    6cce:	df00      	svc	0
    6cd0:	bf00      	nop
    6cd2:	0000      	.short	0x0000
    6cd4:	e000ed08 	.word	0xe000ed08

00006cd8 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP(void)
{
	__asm volatile("	ldr.w r0, =0xE000ED88		\n" /* The FPU enable bits are in the CPACR. */
    6cd8:	f8df 000c 	ldr.w	r0, [pc, #12]	; 6ce8 <vPortEnableVFP+0x10>
    6cdc:	6801      	ldr	r1, [r0, #0]
    6cde:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    6ce2:	6001      	str	r1, [r0, #0]
    6ce4:	4770      	bx	lr
    6ce6:	0000      	.short	0x0000
    6ce8:	e000ed88 	.word	0xe000ed88

00006cec <pxPortInitialiseStack>:
	*pxTopOfStack = portINITIAL_XPSR; /* xPSR */
    6cec:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
    6cf0:	f840 3c04 	str.w	r3, [r0, #-4]
	*pxTopOfStack = ((StackType_t)pxCode) & portSTART_ADDRESS_MASK; /* PC */
    6cf4:	f021 0101 	bic.w	r1, r1, #1
    6cf8:	f840 1c08 	str.w	r1, [r0, #-8]
	*pxTopOfStack = (StackType_t)portTASK_RETURN_ADDRESS; /* LR */
    6cfc:	4b05      	ldr	r3, [pc, #20]	; (6d14 <pxPortInitialiseStack+0x28>)
    6cfe:	f840 3c0c 	str.w	r3, [r0, #-12]
	*pxTopOfStack = (StackType_t)pvParameters; /* R0 */
    6d02:	f840 2c20 	str.w	r2, [r0, #-32]
	*pxTopOfStack = portINITIAL_EXC_RETURN;
    6d06:	f06f 0302 	mvn.w	r3, #2
    6d0a:	f840 3c24 	str.w	r3, [r0, #-36]
}
    6d0e:	3844      	subs	r0, #68	; 0x44
    6d10:	4770      	bx	lr
    6d12:	bf00      	nop
    6d14:	00006c71 	.word	0x00006c71
	...

00006d20 <SVC_Handler>:
	__asm volatile("	ldr	r3, pxCurrentTCBConst2		\n" /* Restore the context. */
    6d20:	4b07      	ldr	r3, [pc, #28]	; (6d40 <pxCurrentTCBConst2>)
    6d22:	6819      	ldr	r1, [r3, #0]
    6d24:	6808      	ldr	r0, [r1, #0]
    6d26:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6d2a:	f380 8809 	msr	PSP, r0
    6d2e:	f3bf 8f6f 	isb	sy
    6d32:	f04f 0000 	mov.w	r0, #0
    6d36:	f380 8811 	msr	BASEPRI, r0
    6d3a:	4770      	bx	lr
    6d3c:	f3af 8000 	nop.w

00006d40 <pxCurrentTCBConst2>:
    6d40:	20001468 	.word	0x20001468

00006d44 <vPortEnterCritical>:
    6d44:	f04f 0380 	mov.w	r3, #128	; 0x80
    6d48:	f383 8811 	msr	BASEPRI, r3
    6d4c:	f3bf 8f6f 	isb	sy
    6d50:	f3bf 8f4f 	dsb	sy
	uxCriticalNesting++;
    6d54:	4a0a      	ldr	r2, [pc, #40]	; (6d80 <vPortEnterCritical+0x3c>)
    6d56:	6813      	ldr	r3, [r2, #0]
    6d58:	3301      	adds	r3, #1
    6d5a:	6013      	str	r3, [r2, #0]
	if (uxCriticalNesting == 1) {
    6d5c:	2b01      	cmp	r3, #1
    6d5e:	d10d      	bne.n	6d7c <vPortEnterCritical+0x38>
		configASSERT((portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK) == 0);
    6d60:	4b08      	ldr	r3, [pc, #32]	; (6d84 <vPortEnterCritical+0x40>)
    6d62:	681b      	ldr	r3, [r3, #0]
    6d64:	f013 0fff 	tst.w	r3, #255	; 0xff
    6d68:	d008      	beq.n	6d7c <vPortEnterCritical+0x38>
    6d6a:	f04f 0380 	mov.w	r3, #128	; 0x80
    6d6e:	f383 8811 	msr	BASEPRI, r3
    6d72:	f3bf 8f6f 	isb	sy
    6d76:	f3bf 8f4f 	dsb	sy
    6d7a:	e7fe      	b.n	6d7a <vPortEnterCritical+0x36>
    6d7c:	4770      	bx	lr
    6d7e:	bf00      	nop
    6d80:	20000030 	.word	0x20000030
    6d84:	e000ed04 	.word	0xe000ed04

00006d88 <vPortExitCritical>:
	configASSERT(uxCriticalNesting);
    6d88:	4b09      	ldr	r3, [pc, #36]	; (6db0 <vPortExitCritical+0x28>)
    6d8a:	681b      	ldr	r3, [r3, #0]
    6d8c:	b943      	cbnz	r3, 6da0 <vPortExitCritical+0x18>
    6d8e:	f04f 0380 	mov.w	r3, #128	; 0x80
    6d92:	f383 8811 	msr	BASEPRI, r3
    6d96:	f3bf 8f6f 	isb	sy
    6d9a:	f3bf 8f4f 	dsb	sy
    6d9e:	e7fe      	b.n	6d9e <vPortExitCritical+0x16>
	uxCriticalNesting--;
    6da0:	3b01      	subs	r3, #1
    6da2:	4a03      	ldr	r2, [pc, #12]	; (6db0 <vPortExitCritical+0x28>)
    6da4:	6013      	str	r3, [r2, #0]
	if (uxCriticalNesting == 0) {
    6da6:	b90b      	cbnz	r3, 6dac <vPortExitCritical+0x24>
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI(uint32_t ulNewMaskValue)
{
	__asm volatile("	msr basepri, %0	" ::"r"(ulNewMaskValue) : "memory");
    6da8:	f383 8811 	msr	BASEPRI, r3
    6dac:	4770      	bx	lr
    6dae:	bf00      	nop
    6db0:	20000030 	.word	0x20000030
	...

00006dc0 <PendSV_Handler>:
	__asm volatile(
    6dc0:	f3ef 8009 	mrs	r0, PSP
    6dc4:	f3bf 8f6f 	isb	sy
    6dc8:	4b15      	ldr	r3, [pc, #84]	; (6e20 <pxCurrentTCBConst>)
    6dca:	681a      	ldr	r2, [r3, #0]
    6dcc:	f01e 0f10 	tst.w	lr, #16
    6dd0:	bf08      	it	eq
    6dd2:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
    6dd6:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6dda:	6010      	str	r0, [r2, #0]
    6ddc:	e92d 0009 	stmdb	sp!, {r0, r3}
    6de0:	f04f 0080 	mov.w	r0, #128	; 0x80
    6de4:	f380 8811 	msr	BASEPRI, r0
    6de8:	f3bf 8f4f 	dsb	sy
    6dec:	f3bf 8f6f 	isb	sy
    6df0:	f001 f8d2 	bl	7f98 <vTaskSwitchContext>
    6df4:	f04f 0000 	mov.w	r0, #0
    6df8:	f380 8811 	msr	BASEPRI, r0
    6dfc:	bc09      	pop	{r0, r3}
    6dfe:	6819      	ldr	r1, [r3, #0]
    6e00:	6808      	ldr	r0, [r1, #0]
    6e02:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6e06:	f01e 0f10 	tst.w	lr, #16
    6e0a:	bf08      	it	eq
    6e0c:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
    6e10:	f380 8809 	msr	PSP, r0
    6e14:	f3bf 8f6f 	isb	sy
    6e18:	4770      	bx	lr
    6e1a:	bf00      	nop
    6e1c:	f3af 8000 	nop.w

00006e20 <pxCurrentTCBConst>:
    6e20:	20001468 	.word	0x20001468

00006e24 <SysTick_Handler>:
{
    6e24:	b508      	push	{r3, lr}
	__asm volatile("	mov %0, %1												\n"
    6e26:	f04f 0380 	mov.w	r3, #128	; 0x80
    6e2a:	f383 8811 	msr	BASEPRI, r3
    6e2e:	f3bf 8f6f 	isb	sy
    6e32:	f3bf 8f4f 	dsb	sy
		if (xTaskIncrementTick() != pdFALSE) {
    6e36:	4b05      	ldr	r3, [pc, #20]	; (6e4c <SysTick_Handler+0x28>)
    6e38:	4798      	blx	r3
    6e3a:	b118      	cbz	r0, 6e44 <SysTick_Handler+0x20>
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
    6e3c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    6e40:	4b03      	ldr	r3, [pc, #12]	; (6e50 <SysTick_Handler+0x2c>)
    6e42:	601a      	str	r2, [r3, #0]
	__asm volatile("	msr basepri, %0	" ::"r"(ulNewMaskValue) : "memory");
    6e44:	2300      	movs	r3, #0
    6e46:	f383 8811 	msr	BASEPRI, r3
    6e4a:	bd08      	pop	{r3, pc}
    6e4c:	00007c61 	.word	0x00007c61
    6e50:	e000ed04 	.word	0xe000ed04

00006e54 <vPortSetupTimerInterrupt>:
	portNVIC_SYSTICK_CTRL_REG          = 0UL;
    6e54:	4b05      	ldr	r3, [pc, #20]	; (6e6c <vPortSetupTimerInterrupt+0x18>)
    6e56:	2200      	movs	r2, #0
    6e58:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
    6e5a:	4905      	ldr	r1, [pc, #20]	; (6e70 <vPortSetupTimerInterrupt+0x1c>)
    6e5c:	600a      	str	r2, [r1, #0]
	portNVIC_SYSTICK_LOAD_REG = (configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ) - 1UL;
    6e5e:	f642 61df 	movw	r1, #11999	; 0x2edf
    6e62:	4a04      	ldr	r2, [pc, #16]	; (6e74 <vPortSetupTimerInterrupt+0x20>)
    6e64:	6011      	str	r1, [r2, #0]
	portNVIC_SYSTICK_CTRL_REG = (portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT);
    6e66:	2207      	movs	r2, #7
    6e68:	601a      	str	r2, [r3, #0]
    6e6a:	4770      	bx	lr
    6e6c:	e000e010 	.word	0xe000e010
    6e70:	e000e018 	.word	0xe000e018
    6e74:	e000e014 	.word	0xe000e014

00006e78 <xPortStartScheduler>:
	configASSERT(portCPUID != portCORTEX_M7_r0p1_ID);
    6e78:	4b3b      	ldr	r3, [pc, #236]	; (6f68 <xPortStartScheduler+0xf0>)
    6e7a:	681a      	ldr	r2, [r3, #0]
    6e7c:	4b3b      	ldr	r3, [pc, #236]	; (6f6c <xPortStartScheduler+0xf4>)
    6e7e:	429a      	cmp	r2, r3
    6e80:	d108      	bne.n	6e94 <xPortStartScheduler+0x1c>
	__asm volatile("	mov %0, %1												\n"
    6e82:	f04f 0380 	mov.w	r3, #128	; 0x80
    6e86:	f383 8811 	msr	BASEPRI, r3
    6e8a:	f3bf 8f6f 	isb	sy
    6e8e:	f3bf 8f4f 	dsb	sy
    6e92:	e7fe      	b.n	6e92 <xPortStartScheduler+0x1a>
	configASSERT(portCPUID != portCORTEX_M7_r0p0_ID);
    6e94:	4b34      	ldr	r3, [pc, #208]	; (6f68 <xPortStartScheduler+0xf0>)
    6e96:	681a      	ldr	r2, [r3, #0]
    6e98:	4b35      	ldr	r3, [pc, #212]	; (6f70 <xPortStartScheduler+0xf8>)
    6e9a:	429a      	cmp	r2, r3
    6e9c:	d108      	bne.n	6eb0 <xPortStartScheduler+0x38>
    6e9e:	f04f 0380 	mov.w	r3, #128	; 0x80
    6ea2:	f383 8811 	msr	BASEPRI, r3
    6ea6:	f3bf 8f6f 	isb	sy
    6eaa:	f3bf 8f4f 	dsb	sy
    6eae:	e7fe      	b.n	6eae <xPortStartScheduler+0x36>
{
    6eb0:	b510      	push	{r4, lr}
    6eb2:	b082      	sub	sp, #8
		ulOriginalPriority = *pucFirstUserPriorityRegister;
    6eb4:	4b2f      	ldr	r3, [pc, #188]	; (6f74 <xPortStartScheduler+0xfc>)
    6eb6:	781a      	ldrb	r2, [r3, #0]
    6eb8:	b2d2      	uxtb	r2, r2
    6eba:	9201      	str	r2, [sp, #4]
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
    6ebc:	22ff      	movs	r2, #255	; 0xff
    6ebe:	701a      	strb	r2, [r3, #0]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
    6ec0:	781b      	ldrb	r3, [r3, #0]
    6ec2:	b2db      	uxtb	r3, r3
    6ec4:	f88d 3003 	strb.w	r3, [sp, #3]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
    6ec8:	f89d 3003 	ldrb.w	r3, [sp, #3]
    6ecc:	4a2a      	ldr	r2, [pc, #168]	; (6f78 <xPortStartScheduler+0x100>)
    6ece:	f003 0380 	and.w	r3, r3, #128	; 0x80
    6ed2:	7013      	strb	r3, [r2, #0]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
    6ed4:	2307      	movs	r3, #7
    6ed6:	6053      	str	r3, [r2, #4]
		while ((ucMaxPriorityValue & portTOP_BIT_OF_BYTE) == portTOP_BIT_OF_BYTE) {
    6ed8:	f89d 3003 	ldrb.w	r3, [sp, #3]
    6edc:	f013 0f80 	tst.w	r3, #128	; 0x80
    6ee0:	d012      	beq.n	6f08 <xPortStartScheduler+0x90>
    6ee2:	2306      	movs	r3, #6
    6ee4:	e000      	b.n	6ee8 <xPortStartScheduler+0x70>
    6ee6:	460b      	mov	r3, r1
			ucMaxPriorityValue <<= (uint8_t)0x01;
    6ee8:	f89d 2003 	ldrb.w	r2, [sp, #3]
    6eec:	0052      	lsls	r2, r2, #1
    6eee:	b2d2      	uxtb	r2, r2
    6ef0:	f88d 2003 	strb.w	r2, [sp, #3]
		while ((ucMaxPriorityValue & portTOP_BIT_OF_BYTE) == portTOP_BIT_OF_BYTE) {
    6ef4:	f89d 2003 	ldrb.w	r2, [sp, #3]
    6ef8:	1e59      	subs	r1, r3, #1
    6efa:	f012 0f80 	tst.w	r2, #128	; 0x80
    6efe:	d1f2      	bne.n	6ee6 <xPortStartScheduler+0x6e>
    6f00:	4a1d      	ldr	r2, [pc, #116]	; (6f78 <xPortStartScheduler+0x100>)
    6f02:	6053      	str	r3, [r2, #4]
			configASSERT((portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue) == configPRIO_BITS);
    6f04:	2b04      	cmp	r3, #4
    6f06:	d008      	beq.n	6f1a <xPortStartScheduler+0xa2>
    6f08:	f04f 0380 	mov.w	r3, #128	; 0x80
    6f0c:	f383 8811 	msr	BASEPRI, r3
    6f10:	f3bf 8f6f 	isb	sy
    6f14:	f3bf 8f4f 	dsb	sy
    6f18:	e7fe      	b.n	6f18 <xPortStartScheduler+0xa0>
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
    6f1a:	021b      	lsls	r3, r3, #8
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
    6f1c:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    6f20:	4a15      	ldr	r2, [pc, #84]	; (6f78 <xPortStartScheduler+0x100>)
    6f22:	6053      	str	r3, [r2, #4]
		*pucFirstUserPriorityRegister = ulOriginalPriority;
    6f24:	9b01      	ldr	r3, [sp, #4]
    6f26:	b2db      	uxtb	r3, r3
    6f28:	4a12      	ldr	r2, [pc, #72]	; (6f74 <xPortStartScheduler+0xfc>)
    6f2a:	7013      	strb	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
    6f2c:	4b13      	ldr	r3, [pc, #76]	; (6f7c <xPortStartScheduler+0x104>)
    6f2e:	681a      	ldr	r2, [r3, #0]
    6f30:	f442 0260 	orr.w	r2, r2, #14680064	; 0xe00000
    6f34:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
    6f36:	681a      	ldr	r2, [r3, #0]
    6f38:	f042 4260 	orr.w	r2, r2, #3758096384	; 0xe0000000
    6f3c:	601a      	str	r2, [r3, #0]
	vPortSetupTimerInterrupt();
    6f3e:	4b10      	ldr	r3, [pc, #64]	; (6f80 <xPortStartScheduler+0x108>)
    6f40:	4798      	blx	r3
	uxCriticalNesting = 0;
    6f42:	2400      	movs	r4, #0
    6f44:	4b0f      	ldr	r3, [pc, #60]	; (6f84 <xPortStartScheduler+0x10c>)
    6f46:	601c      	str	r4, [r3, #0]
	vPortEnableVFP();
    6f48:	4b0f      	ldr	r3, [pc, #60]	; (6f88 <xPortStartScheduler+0x110>)
    6f4a:	4798      	blx	r3
	*(portFPCCR) |= portASPEN_AND_LSPEN_BITS;
    6f4c:	4a0f      	ldr	r2, [pc, #60]	; (6f8c <xPortStartScheduler+0x114>)
    6f4e:	6813      	ldr	r3, [r2, #0]
    6f50:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
    6f54:	6013      	str	r3, [r2, #0]
	prvPortStartFirstTask();
    6f56:	4b0e      	ldr	r3, [pc, #56]	; (6f90 <xPortStartScheduler+0x118>)
    6f58:	4798      	blx	r3
	vTaskSwitchContext();
    6f5a:	4b0e      	ldr	r3, [pc, #56]	; (6f94 <xPortStartScheduler+0x11c>)
    6f5c:	4798      	blx	r3
	prvTaskExitError();
    6f5e:	4b0e      	ldr	r3, [pc, #56]	; (6f98 <xPortStartScheduler+0x120>)
    6f60:	4798      	blx	r3
}
    6f62:	4620      	mov	r0, r4
    6f64:	b002      	add	sp, #8
    6f66:	bd10      	pop	{r4, pc}
    6f68:	e000ed00 	.word	0xe000ed00
    6f6c:	410fc271 	.word	0x410fc271
    6f70:	410fc270 	.word	0x410fc270
    6f74:	e000e400 	.word	0xe000e400
    6f78:	20000a60 	.word	0x20000a60
    6f7c:	e000ed20 	.word	0xe000ed20
    6f80:	00006e55 	.word	0x00006e55
    6f84:	20000030 	.word	0x20000030
    6f88:	00006cd9 	.word	0x00006cd9
    6f8c:	e000ef34 	.word	0xe000ef34
    6f90:	00006cb1 	.word	0x00006cb1
    6f94:	00007f99 	.word	0x00007f99
    6f98:	00006c71 	.word	0x00006c71

00006f9c <vPortValidateInterruptPriority>:
{
	uint32_t ulCurrentInterrupt;
	uint8_t  ucCurrentPriority;

	/* Obtain the number of the currently executing interrupt. */
	__asm volatile("mrs %0, ipsr" : "=r"(ulCurrentInterrupt)::"memory");
    6f9c:	f3ef 8305 	mrs	r3, IPSR

	/* Is the interrupt number a user defined interrupt? */
	if (ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER) {
    6fa0:	2b0f      	cmp	r3, #15
    6fa2:	d90f      	bls.n	6fc4 <vPortValidateInterruptPriority+0x28>
		/* Look up the interrupt's priority. */
		ucCurrentPriority = pcInterruptPriorityRegisters[ulCurrentInterrupt];
    6fa4:	4a10      	ldr	r2, [pc, #64]	; (6fe8 <vPortValidateInterruptPriority+0x4c>)
    6fa6:	5c9b      	ldrb	r3, [r3, r2]
    6fa8:	b2db      	uxtb	r3, r3
		interrupt entry is as fast and simple as possible.

		The following links provide detailed information:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html
		http://www.freertos.org/FAQHelp.html */
		configASSERT(ucCurrentPriority >= ucMaxSysCallPriority);
    6faa:	4a10      	ldr	r2, [pc, #64]	; (6fec <vPortValidateInterruptPriority+0x50>)
    6fac:	7812      	ldrb	r2, [r2, #0]
    6fae:	429a      	cmp	r2, r3
    6fb0:	d908      	bls.n	6fc4 <vPortValidateInterruptPriority+0x28>
    6fb2:	f04f 0380 	mov.w	r3, #128	; 0x80
    6fb6:	f383 8811 	msr	BASEPRI, r3
    6fba:	f3bf 8f6f 	isb	sy
    6fbe:	f3bf 8f4f 	dsb	sy
    6fc2:	e7fe      	b.n	6fc2 <vPortValidateInterruptPriority+0x26>
	configuration then the correct setting can be achieved on all Cortex-M
	devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
	scheduler.  Note however that some vendor specific peripheral libraries
	assume a non-zero priority group setting, in which cases using a value
	of zero will result in unpredictable behaviour. */
	configASSERT((portAIRCR_REG & portPRIORITY_GROUP_MASK) <= ulMaxPRIGROUPValue);
    6fc4:	4b0a      	ldr	r3, [pc, #40]	; (6ff0 <vPortValidateInterruptPriority+0x54>)
    6fc6:	681b      	ldr	r3, [r3, #0]
    6fc8:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    6fcc:	4a07      	ldr	r2, [pc, #28]	; (6fec <vPortValidateInterruptPriority+0x50>)
    6fce:	6852      	ldr	r2, [r2, #4]
    6fd0:	4293      	cmp	r3, r2
    6fd2:	d908      	bls.n	6fe6 <vPortValidateInterruptPriority+0x4a>
    6fd4:	f04f 0380 	mov.w	r3, #128	; 0x80
    6fd8:	f383 8811 	msr	BASEPRI, r3
    6fdc:	f3bf 8f6f 	isb	sy
    6fe0:	f3bf 8f4f 	dsb	sy
    6fe4:	e7fe      	b.n	6fe4 <vPortValidateInterruptPriority+0x48>
    6fe6:	4770      	bx	lr
    6fe8:	e000e3f0 	.word	0xe000e3f0
    6fec:	20000a60 	.word	0x20000a60
    6ff0:	e000ed0c 	.word	0xe000ed0c

00006ff4 <pvPortMalloc>:
static size_t xNextFreeByte = (size_t)0;

/*-----------------------------------------------------------*/

void *pvPortMalloc(size_t xWantedSize)
{
    6ff4:	b538      	push	{r3, r4, r5, lr}
    6ff6:	4604      	mov	r4, r0
	static uint8_t *pucAlignedHeap = NULL;

/* Ensure that blocks are always aligned to the required number of bytes. */
#if (portBYTE_ALIGNMENT != 1)
	{
		if (xWantedSize & portBYTE_ALIGNMENT_MASK) {
    6ff8:	f010 0f07 	tst.w	r0, #7
			/* Byte alignment required. */
			xWantedSize += (portBYTE_ALIGNMENT - (xWantedSize & portBYTE_ALIGNMENT_MASK));
    6ffc:	bf1c      	itt	ne
    6ffe:	f020 0407 	bicne.w	r4, r0, #7
    7002:	3408      	addne	r4, #8
		}
	}
#endif

	vTaskSuspendAll();
    7004:	4b11      	ldr	r3, [pc, #68]	; (704c <pvPortMalloc+0x58>)
    7006:	4798      	blx	r3
	{
		if (pucAlignedHeap == NULL) {
    7008:	4b11      	ldr	r3, [pc, #68]	; (7050 <pvPortMalloc+0x5c>)
    700a:	681b      	ldr	r3, [r3, #0]
    700c:	b193      	cbz	r3, 7034 <pvPortMalloc+0x40>
			pucAlignedHeap = (uint8_t *)(((portPOINTER_SIZE_TYPE)&ucHeap[portBYTE_ALIGNMENT])
			                             & (~((portPOINTER_SIZE_TYPE)portBYTE_ALIGNMENT_MASK)));
		}

		/* Check there is enough room left for the allocation. */
		if (((xNextFreeByte + xWantedSize) < configADJUSTED_HEAP_SIZE)
    700e:	4b10      	ldr	r3, [pc, #64]	; (7050 <pvPortMalloc+0x5c>)
    7010:	f8d3 3964 	ldr.w	r3, [r3, #2404]	; 0x964
    7014:	441c      	add	r4, r3
    7016:	f640 1257 	movw	r2, #2391	; 0x957
    701a:	4294      	cmp	r4, r2
    701c:	d811      	bhi.n	7042 <pvPortMalloc+0x4e>
		    && ((xNextFreeByte + xWantedSize) > xNextFreeByte)) /* Check for overflow. */
    701e:	42a3      	cmp	r3, r4
    7020:	d211      	bcs.n	7046 <pvPortMalloc+0x52>
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    7022:	4a0b      	ldr	r2, [pc, #44]	; (7050 <pvPortMalloc+0x5c>)
    7024:	6815      	ldr	r5, [r2, #0]
    7026:	441d      	add	r5, r3
			xNextFreeByte += xWantedSize;
    7028:	f8c2 4964 	str.w	r4, [r2, #2404]	; 0x964
		}

		traceMALLOC(pvReturn, xWantedSize);
	}
	(void)xTaskResumeAll();
    702c:	4b09      	ldr	r3, [pc, #36]	; (7054 <pvPortMalloc+0x60>)
    702e:	4798      	blx	r3
		}
	}
#endif

	return pvReturn;
}
    7030:	4628      	mov	r0, r5
    7032:	bd38      	pop	{r3, r4, r5, pc}
			pucAlignedHeap = (uint8_t *)(((portPOINTER_SIZE_TYPE)&ucHeap[portBYTE_ALIGNMENT])
    7034:	4a06      	ldr	r2, [pc, #24]	; (7050 <pvPortMalloc+0x5c>)
    7036:	f102 030c 	add.w	r3, r2, #12
			                             & (~((portPOINTER_SIZE_TYPE)portBYTE_ALIGNMENT_MASK)));
    703a:	f023 0307 	bic.w	r3, r3, #7
			pucAlignedHeap = (uint8_t *)(((portPOINTER_SIZE_TYPE)&ucHeap[portBYTE_ALIGNMENT])
    703e:	6013      	str	r3, [r2, #0]
    7040:	e7e5      	b.n	700e <pvPortMalloc+0x1a>
	void *          pvReturn       = NULL;
    7042:	2500      	movs	r5, #0
    7044:	e7f2      	b.n	702c <pvPortMalloc+0x38>
    7046:	2500      	movs	r5, #0
    7048:	e7f0      	b.n	702c <pvPortMalloc+0x38>
    704a:	bf00      	nop
    704c:	00007c41 	.word	0x00007c41
    7050:	20000a68 	.word	0x20000a68
    7054:	00007d89 	.word	0x00007d89

00007058 <vPortFree>:
	heap_4.c for alternative implementations, and the memory management pages of
	http://www.FreeRTOS.org for more information. */
	(void)pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT(pv == NULL);
    7058:	b140      	cbz	r0, 706c <vPortFree+0x14>
    705a:	f04f 0380 	mov.w	r3, #128	; 0x80
    705e:	f383 8811 	msr	BASEPRI, r3
    7062:	f3bf 8f6f 	isb	sy
    7066:	f3bf 8f4f 	dsb	sy
    706a:	e7fe      	b.n	706a <vPortFree+0x12>
    706c:	4770      	bx	lr
	...

00007070 <prvIsQueueEmpty>:
	taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty(const Queue_t *pxQueue)
{
    7070:	b510      	push	{r4, lr}
    7072:	4604      	mov	r4, r0
	BaseType_t xReturn;

	taskENTER_CRITICAL();
    7074:	4b04      	ldr	r3, [pc, #16]	; (7088 <prvIsQueueEmpty+0x18>)
    7076:	4798      	blx	r3
	{
		if (pxQueue->uxMessagesWaiting == (UBaseType_t)0) {
    7078:	6ba4      	ldr	r4, [r4, #56]	; 0x38
			xReturn = pdTRUE;
		} else {
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    707a:	4b04      	ldr	r3, [pc, #16]	; (708c <prvIsQueueEmpty+0x1c>)
    707c:	4798      	blx	r3

	return xReturn;
}
    707e:	fab4 f084 	clz	r0, r4
    7082:	0940      	lsrs	r0, r0, #5
    7084:	bd10      	pop	{r4, pc}
    7086:	bf00      	nop
    7088:	00006d45 	.word	0x00006d45
    708c:	00006d89 	.word	0x00006d89

00007090 <prvCopyDataToQueue>:
{
    7090:	b570      	push	{r4, r5, r6, lr}
    7092:	4604      	mov	r4, r0
    7094:	4616      	mov	r6, r2
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    7096:	6b85      	ldr	r5, [r0, #56]	; 0x38
	if (pxQueue->uxItemSize == (UBaseType_t)0) {
    7098:	6c02      	ldr	r2, [r0, #64]	; 0x40
    709a:	b952      	cbnz	r2, 70b2 <prvCopyDataToQueue+0x22>
			if (pxQueue->uxQueueType == queueQUEUE_IS_MUTEX) {
    709c:	6803      	ldr	r3, [r0, #0]
    709e:	2b00      	cmp	r3, #0
    70a0:	d12a      	bne.n	70f8 <prvCopyDataToQueue+0x68>
				xReturn                = xTaskPriorityDisinherit((void *)pxQueue->pxMutexHolder);
    70a2:	6840      	ldr	r0, [r0, #4]
    70a4:	4b18      	ldr	r3, [pc, #96]	; (7108 <prvCopyDataToQueue+0x78>)
    70a6:	4798      	blx	r3
				pxQueue->pxMutexHolder = NULL;
    70a8:	2300      	movs	r3, #0
    70aa:	6063      	str	r3, [r4, #4]
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + (UBaseType_t)1;
    70ac:	3501      	adds	r5, #1
    70ae:	63a5      	str	r5, [r4, #56]	; 0x38
}
    70b0:	bd70      	pop	{r4, r5, r6, pc}
	} else if (xPosition == queueSEND_TO_BACK) {
    70b2:	b96e      	cbnz	r6, 70d0 <prvCopyDataToQueue+0x40>
		(void)memcpy((void *)pxQueue->pcWriteTo,
    70b4:	6880      	ldr	r0, [r0, #8]
    70b6:	4b15      	ldr	r3, [pc, #84]	; (710c <prvCopyDataToQueue+0x7c>)
    70b8:	4798      	blx	r3
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    70ba:	68a3      	ldr	r3, [r4, #8]
    70bc:	6c22      	ldr	r2, [r4, #64]	; 0x40
    70be:	4413      	add	r3, r2
    70c0:	60a3      	str	r3, [r4, #8]
		if (pxQueue->pcWriteTo >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as comparison of pointers is
    70c2:	6862      	ldr	r2, [r4, #4]
    70c4:	4293      	cmp	r3, r2
    70c6:	d319      	bcc.n	70fc <prvCopyDataToQueue+0x6c>
			pxQueue->pcWriteTo = pxQueue->pcHead;
    70c8:	6823      	ldr	r3, [r4, #0]
    70ca:	60a3      	str	r3, [r4, #8]
	BaseType_t  xReturn = pdFALSE;
    70cc:	2000      	movs	r0, #0
    70ce:	e7ed      	b.n	70ac <prvCopyDataToQueue+0x1c>
		(void)memcpy((void *)pxQueue->u.pcReadFrom,
    70d0:	68c0      	ldr	r0, [r0, #12]
    70d2:	4b0e      	ldr	r3, [pc, #56]	; (710c <prvCopyDataToQueue+0x7c>)
    70d4:	4798      	blx	r3
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    70d6:	6c23      	ldr	r3, [r4, #64]	; 0x40
    70d8:	425b      	negs	r3, r3
    70da:	68e2      	ldr	r2, [r4, #12]
    70dc:	441a      	add	r2, r3
    70de:	60e2      	str	r2, [r4, #12]
		if (pxQueue->u.pcReadFrom
    70e0:	6821      	ldr	r1, [r4, #0]
    70e2:	428a      	cmp	r2, r1
    70e4:	d202      	bcs.n	70ec <prvCopyDataToQueue+0x5c>
			pxQueue->u.pcReadFrom = (pxQueue->pcTail - pxQueue->uxItemSize);
    70e6:	6862      	ldr	r2, [r4, #4]
    70e8:	4413      	add	r3, r2
    70ea:	60e3      	str	r3, [r4, #12]
		if (xPosition == queueOVERWRITE) {
    70ec:	2e02      	cmp	r6, #2
    70ee:	d107      	bne.n	7100 <prvCopyDataToQueue+0x70>
			if (uxMessagesWaiting > (UBaseType_t)0) {
    70f0:	b145      	cbz	r5, 7104 <prvCopyDataToQueue+0x74>
				--uxMessagesWaiting;
    70f2:	3d01      	subs	r5, #1
	BaseType_t  xReturn = pdFALSE;
    70f4:	2000      	movs	r0, #0
    70f6:	e7d9      	b.n	70ac <prvCopyDataToQueue+0x1c>
    70f8:	2000      	movs	r0, #0
    70fa:	e7d7      	b.n	70ac <prvCopyDataToQueue+0x1c>
    70fc:	2000      	movs	r0, #0
    70fe:	e7d5      	b.n	70ac <prvCopyDataToQueue+0x1c>
    7100:	2000      	movs	r0, #0
    7102:	e7d3      	b.n	70ac <prvCopyDataToQueue+0x1c>
    7104:	2000      	movs	r0, #0
    7106:	e7d1      	b.n	70ac <prvCopyDataToQueue+0x1c>
    7108:	000082e9 	.word	0x000082e9
    710c:	00009695 	.word	0x00009695

00007110 <prvNotifyQueueSetContainer>:
/*-----------------------------------------------------------*/

#if (configUSE_QUEUE_SETS == 1)

static BaseType_t prvNotifyQueueSetContainer(const Queue_t *const pxQueue, const BaseType_t xCopyPosition)
{
    7110:	b570      	push	{r4, r5, r6, lr}
    7112:	b082      	sub	sp, #8
    7114:	9001      	str	r0, [sp, #4]
	Queue_t *  pxQueueSetContainer = pxQueue->pxQueueSetContainer;
    7116:	6c84      	ldr	r4, [r0, #72]	; 0x48
	BaseType_t xReturn             = pdFALSE;

	/* This function must be called form a critical section. */

	configASSERT(pxQueueSetContainer);
    7118:	b164      	cbz	r4, 7134 <prvNotifyQueueSetContainer+0x24>
	configASSERT(pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength);
    711a:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    711c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    711e:	429a      	cmp	r2, r3
    7120:	d311      	bcc.n	7146 <prvNotifyQueueSetContainer+0x36>
    7122:	f04f 0380 	mov.w	r3, #128	; 0x80
    7126:	f383 8811 	msr	BASEPRI, r3
    712a:	f3bf 8f6f 	isb	sy
    712e:	f3bf 8f4f 	dsb	sy
    7132:	e7fe      	b.n	7132 <prvNotifyQueueSetContainer+0x22>
    7134:	f04f 0380 	mov.w	r3, #128	; 0x80
    7138:	f383 8811 	msr	BASEPRI, r3
    713c:	f3bf 8f6f 	isb	sy
    7140:	f3bf 8f4f 	dsb	sy
    7144:	e7fe      	b.n	7144 <prvNotifyQueueSetContainer+0x34>

	if (pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength) {
    7146:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    7148:	4293      	cmp	r3, r2
    714a:	d803      	bhi.n	7154 <prvNotifyQueueSetContainer+0x44>
	BaseType_t xReturn             = pdFALSE;
    714c:	2600      	movs	r6, #0
	} else {
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
    714e:	4630      	mov	r0, r6
    7150:	b002      	add	sp, #8
    7152:	bd70      	pop	{r4, r5, r6, pc}
    7154:	460a      	mov	r2, r1
		const int8_t cTxLock = pxQueueSetContainer->cTxLock;
    7156:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
    715a:	b26d      	sxtb	r5, r5
		xReturn = prvCopyDataToQueue(pxQueueSetContainer, &pxQueue, xCopyPosition);
    715c:	a901      	add	r1, sp, #4
    715e:	4620      	mov	r0, r4
    7160:	4b0a      	ldr	r3, [pc, #40]	; (718c <prvNotifyQueueSetContainer+0x7c>)
    7162:	4798      	blx	r3
    7164:	4606      	mov	r6, r0
		if (cTxLock == queueUNLOCKED) {
    7166:	f1b5 3fff 	cmp.w	r5, #4294967295
    716a:	d10a      	bne.n	7182 <prvNotifyQueueSetContainer+0x72>
			if (listLIST_IS_EMPTY(&(pxQueueSetContainer->xTasksWaitingToReceive)) == pdFALSE) {
    716c:	6a63      	ldr	r3, [r4, #36]	; 0x24
    716e:	2b00      	cmp	r3, #0
    7170:	d0ed      	beq.n	714e <prvNotifyQueueSetContainer+0x3e>
				if (xTaskRemoveFromEventList(&(pxQueueSetContainer->xTasksWaitingToReceive)) != pdFALSE) {
    7172:	f104 0024 	add.w	r0, r4, #36	; 0x24
    7176:	4b06      	ldr	r3, [pc, #24]	; (7190 <prvNotifyQueueSetContainer+0x80>)
    7178:	4798      	blx	r3
    717a:	2800      	cmp	r0, #0
					xReturn = pdTRUE;
    717c:	bf18      	it	ne
    717e:	2601      	movne	r6, #1
    7180:	e7e5      	b.n	714e <prvNotifyQueueSetContainer+0x3e>
			pxQueueSetContainer->cTxLock = (int8_t)(cTxLock + 1);
    7182:	1c6b      	adds	r3, r5, #1
    7184:	b25b      	sxtb	r3, r3
    7186:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
    718a:	e7e0      	b.n	714e <prvNotifyQueueSetContainer+0x3e>
    718c:	00007091 	.word	0x00007091
    7190:	00008189 	.word	0x00008189

00007194 <prvCopyDataFromQueue>:
	if (pxQueue->uxItemSize != (UBaseType_t)0) {
    7194:	6c02      	ldr	r2, [r0, #64]	; 0x40
    7196:	b172      	cbz	r2, 71b6 <prvCopyDataFromQueue+0x22>
{
    7198:	b510      	push	{r4, lr}
    719a:	4603      	mov	r3, r0
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    719c:	68c4      	ldr	r4, [r0, #12]
    719e:	4414      	add	r4, r2
    71a0:	60c4      	str	r4, [r0, #12]
		if (pxQueue->u.pcReadFrom >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as use of the relational
    71a2:	6840      	ldr	r0, [r0, #4]
    71a4:	4284      	cmp	r4, r0
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    71a6:	bf24      	itt	cs
    71a8:	6818      	ldrcs	r0, [r3, #0]
    71aa:	60d8      	strcs	r0, [r3, #12]
    71ac:	4608      	mov	r0, r1
		(void)memcpy((void *)pvBuffer,
    71ae:	68d9      	ldr	r1, [r3, #12]
    71b0:	4b01      	ldr	r3, [pc, #4]	; (71b8 <prvCopyDataFromQueue+0x24>)
    71b2:	4798      	blx	r3
    71b4:	bd10      	pop	{r4, pc}
    71b6:	4770      	bx	lr
    71b8:	00009695 	.word	0x00009695

000071bc <prvUnlockQueue>:
{
    71bc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    71c0:	4605      	mov	r5, r0
	taskENTER_CRITICAL();
    71c2:	4b23      	ldr	r3, [pc, #140]	; (7250 <prvUnlockQueue+0x94>)
    71c4:	4798      	blx	r3
		int8_t cTxLock = pxQueue->cTxLock;
    71c6:	f895 4045 	ldrb.w	r4, [r5, #69]	; 0x45
    71ca:	b264      	sxtb	r4, r4
		while (cTxLock > queueLOCKED_UNMODIFIED) {
    71cc:	2c00      	cmp	r4, #0
    71ce:	dd19      	ble.n	7204 <prvUnlockQueue+0x48>
					if (prvNotifyQueueSetContainer(pxQueue, queueSEND_TO_BACK) != pdFALSE) {
    71d0:	4e20      	ldr	r6, [pc, #128]	; (7254 <prvUnlockQueue+0x98>)
						vTaskMissedYield();
    71d2:	f8df 808c 	ldr.w	r8, [pc, #140]	; 7260 <prvUnlockQueue+0xa4>
						if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
    71d6:	4f20      	ldr	r7, [pc, #128]	; (7258 <prvUnlockQueue+0x9c>)
    71d8:	e008      	b.n	71ec <prvUnlockQueue+0x30>
					if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
    71da:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    71dc:	b193      	cbz	r3, 7204 <prvUnlockQueue+0x48>
						if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
    71de:	f105 0024 	add.w	r0, r5, #36	; 0x24
    71e2:	47b8      	blx	r7
    71e4:	b960      	cbnz	r0, 7200 <prvUnlockQueue+0x44>
    71e6:	3c01      	subs	r4, #1
    71e8:	b264      	sxtb	r4, r4
		while (cTxLock > queueLOCKED_UNMODIFIED) {
    71ea:	b15c      	cbz	r4, 7204 <prvUnlockQueue+0x48>
				if (pxQueue->pxQueueSetContainer != NULL) {
    71ec:	6cab      	ldr	r3, [r5, #72]	; 0x48
    71ee:	2b00      	cmp	r3, #0
    71f0:	d0f3      	beq.n	71da <prvUnlockQueue+0x1e>
					if (prvNotifyQueueSetContainer(pxQueue, queueSEND_TO_BACK) != pdFALSE) {
    71f2:	2100      	movs	r1, #0
    71f4:	4628      	mov	r0, r5
    71f6:	47b0      	blx	r6
    71f8:	2800      	cmp	r0, #0
    71fa:	d0f4      	beq.n	71e6 <prvUnlockQueue+0x2a>
						vTaskMissedYield();
    71fc:	47c0      	blx	r8
    71fe:	e7f2      	b.n	71e6 <prvUnlockQueue+0x2a>
							vTaskMissedYield();
    7200:	47c0      	blx	r8
    7202:	e7f0      	b.n	71e6 <prvUnlockQueue+0x2a>
		pxQueue->cTxLock = queueUNLOCKED;
    7204:	23ff      	movs	r3, #255	; 0xff
    7206:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
	taskEXIT_CRITICAL();
    720a:	4b14      	ldr	r3, [pc, #80]	; (725c <prvUnlockQueue+0xa0>)
    720c:	4798      	blx	r3
	taskENTER_CRITICAL();
    720e:	4b10      	ldr	r3, [pc, #64]	; (7250 <prvUnlockQueue+0x94>)
    7210:	4798      	blx	r3
		int8_t cRxLock = pxQueue->cRxLock;
    7212:	f895 4044 	ldrb.w	r4, [r5, #68]	; 0x44
    7216:	b264      	sxtb	r4, r4
		while (cRxLock > queueLOCKED_UNMODIFIED) {
    7218:	2c00      	cmp	r4, #0
    721a:	dd12      	ble.n	7242 <prvUnlockQueue+0x86>
			if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
    721c:	692b      	ldr	r3, [r5, #16]
    721e:	b183      	cbz	r3, 7242 <prvUnlockQueue+0x86>
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
    7220:	f105 0710 	add.w	r7, r5, #16
    7224:	4e0c      	ldr	r6, [pc, #48]	; (7258 <prvUnlockQueue+0x9c>)
					vTaskMissedYield();
    7226:	f8df 8038 	ldr.w	r8, [pc, #56]	; 7260 <prvUnlockQueue+0xa4>
    722a:	e004      	b.n	7236 <prvUnlockQueue+0x7a>
    722c:	3c01      	subs	r4, #1
    722e:	b264      	sxtb	r4, r4
		while (cRxLock > queueLOCKED_UNMODIFIED) {
    7230:	b13c      	cbz	r4, 7242 <prvUnlockQueue+0x86>
			if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
    7232:	692b      	ldr	r3, [r5, #16]
    7234:	b12b      	cbz	r3, 7242 <prvUnlockQueue+0x86>
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
    7236:	4638      	mov	r0, r7
    7238:	47b0      	blx	r6
    723a:	2800      	cmp	r0, #0
    723c:	d0f6      	beq.n	722c <prvUnlockQueue+0x70>
					vTaskMissedYield();
    723e:	47c0      	blx	r8
    7240:	e7f4      	b.n	722c <prvUnlockQueue+0x70>
		pxQueue->cRxLock = queueUNLOCKED;
    7242:	23ff      	movs	r3, #255	; 0xff
    7244:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
	taskEXIT_CRITICAL();
    7248:	4b04      	ldr	r3, [pc, #16]	; (725c <prvUnlockQueue+0xa0>)
    724a:	4798      	blx	r3
    724c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    7250:	00006d45 	.word	0x00006d45
    7254:	00007111 	.word	0x00007111
    7258:	00008189 	.word	0x00008189
    725c:	00006d89 	.word	0x00006d89
    7260:	000082b9 	.word	0x000082b9

00007264 <xQueueGenericReset>:
{
    7264:	b538      	push	{r3, r4, r5, lr}
	configASSERT(pxQueue);
    7266:	b330      	cbz	r0, 72b6 <xQueueGenericReset+0x52>
    7268:	4604      	mov	r4, r0
    726a:	460d      	mov	r5, r1
	taskENTER_CRITICAL();
    726c:	4b1c      	ldr	r3, [pc, #112]	; (72e0 <xQueueGenericReset+0x7c>)
    726e:	4798      	blx	r3
		pxQueue->pcTail            = pxQueue->pcHead + (pxQueue->uxLength * pxQueue->uxItemSize);
    7270:	6822      	ldr	r2, [r4, #0]
    7272:	6c21      	ldr	r1, [r4, #64]	; 0x40
    7274:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    7276:	fb03 f301 	mul.w	r3, r3, r1
    727a:	18d0      	adds	r0, r2, r3
    727c:	6060      	str	r0, [r4, #4]
		pxQueue->uxMessagesWaiting = (UBaseType_t)0U;
    727e:	2000      	movs	r0, #0
    7280:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->pcWriteTo         = pxQueue->pcHead;
    7282:	60a2      	str	r2, [r4, #8]
		pxQueue->u.pcReadFrom      = pxQueue->pcHead + ((pxQueue->uxLength - (UBaseType_t)1U) * pxQueue->uxItemSize);
    7284:	1a5b      	subs	r3, r3, r1
    7286:	4413      	add	r3, r2
    7288:	60e3      	str	r3, [r4, #12]
		pxQueue->cRxLock           = queueUNLOCKED;
    728a:	23ff      	movs	r3, #255	; 0xff
    728c:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
		pxQueue->cTxLock           = queueUNLOCKED;
    7290:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
		if (xNewQueue == pdFALSE) {
    7294:	b9c5      	cbnz	r5, 72c8 <xQueueGenericReset+0x64>
			if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
    7296:	6923      	ldr	r3, [r4, #16]
    7298:	b1eb      	cbz	r3, 72d6 <xQueueGenericReset+0x72>
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
    729a:	f104 0010 	add.w	r0, r4, #16
    729e:	4b11      	ldr	r3, [pc, #68]	; (72e4 <xQueueGenericReset+0x80>)
    72a0:	4798      	blx	r3
    72a2:	b1c0      	cbz	r0, 72d6 <xQueueGenericReset+0x72>
					queueYIELD_IF_USING_PREEMPTION();
    72a4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    72a8:	4b0f      	ldr	r3, [pc, #60]	; (72e8 <xQueueGenericReset+0x84>)
    72aa:	601a      	str	r2, [r3, #0]
    72ac:	f3bf 8f4f 	dsb	sy
    72b0:	f3bf 8f6f 	isb	sy
    72b4:	e00f      	b.n	72d6 <xQueueGenericReset+0x72>
    72b6:	f04f 0380 	mov.w	r3, #128	; 0x80
    72ba:	f383 8811 	msr	BASEPRI, r3
    72be:	f3bf 8f6f 	isb	sy
    72c2:	f3bf 8f4f 	dsb	sy
    72c6:	e7fe      	b.n	72c6 <xQueueGenericReset+0x62>
			vListInitialise(&(pxQueue->xTasksWaitingToSend));
    72c8:	f104 0010 	add.w	r0, r4, #16
    72cc:	4d07      	ldr	r5, [pc, #28]	; (72ec <xQueueGenericReset+0x88>)
    72ce:	47a8      	blx	r5
			vListInitialise(&(pxQueue->xTasksWaitingToReceive));
    72d0:	f104 0024 	add.w	r0, r4, #36	; 0x24
    72d4:	47a8      	blx	r5
	taskEXIT_CRITICAL();
    72d6:	4b06      	ldr	r3, [pc, #24]	; (72f0 <xQueueGenericReset+0x8c>)
    72d8:	4798      	blx	r3
}
    72da:	2001      	movs	r0, #1
    72dc:	bd38      	pop	{r3, r4, r5, pc}
    72de:	bf00      	nop
    72e0:	00006d45 	.word	0x00006d45
    72e4:	00008189 	.word	0x00008189
    72e8:	e000ed04 	.word	0xe000ed04
    72ec:	00006be1 	.word	0x00006be1
    72f0:	00006d89 	.word	0x00006d89

000072f4 <xQueueGenericCreate>:
{
    72f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	configASSERT(uxQueueLength > (UBaseType_t)0);
    72f6:	b940      	cbnz	r0, 730a <xQueueGenericCreate+0x16>
    72f8:	f04f 0380 	mov.w	r3, #128	; 0x80
    72fc:	f383 8811 	msr	BASEPRI, r3
    7300:	f3bf 8f6f 	isb	sy
    7304:	f3bf 8f4f 	dsb	sy
    7308:	e7fe      	b.n	7308 <xQueueGenericCreate+0x14>
    730a:	4606      	mov	r6, r0
    730c:	4617      	mov	r7, r2
    730e:	460d      	mov	r5, r1
		xQueueSizeInBytes = (size_t)(
    7310:	fb01 f000 	mul.w	r0, r1, r0
	pxNewQueue = (Queue_t *)pvPortMalloc(sizeof(Queue_t) + xQueueSizeInBytes);
    7314:	3054      	adds	r0, #84	; 0x54
    7316:	4b0b      	ldr	r3, [pc, #44]	; (7344 <xQueueGenericCreate+0x50>)
    7318:	4798      	blx	r3
	if (pxNewQueue != NULL) {
    731a:	4604      	mov	r4, r0
    731c:	b178      	cbz	r0, 733e <xQueueGenericCreate+0x4a>
	if (uxItemSize == (UBaseType_t)0) {
    731e:	b11d      	cbz	r5, 7328 <xQueueGenericCreate+0x34>
		pucQueueStorage = ((uint8_t *)pxNewQueue) + sizeof(Queue_t);
    7320:	f100 0354 	add.w	r3, r0, #84	; 0x54
		pxNewQueue->pcHead = (int8_t *)pucQueueStorage;
    7324:	6003      	str	r3, [r0, #0]
    7326:	e000      	b.n	732a <xQueueGenericCreate+0x36>
		pxNewQueue->pcHead = (int8_t *)pxNewQueue;
    7328:	6020      	str	r0, [r4, #0]
	pxNewQueue->uxLength   = uxQueueLength;
    732a:	63e6      	str	r6, [r4, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
    732c:	6425      	str	r5, [r4, #64]	; 0x40
	(void)xQueueGenericReset(pxNewQueue, pdTRUE);
    732e:	2101      	movs	r1, #1
    7330:	4620      	mov	r0, r4
    7332:	4b05      	ldr	r3, [pc, #20]	; (7348 <xQueueGenericCreate+0x54>)
    7334:	4798      	blx	r3
		pxNewQueue->ucQueueType = ucQueueType;
    7336:	f884 7050 	strb.w	r7, [r4, #80]	; 0x50
		pxNewQueue->pxQueueSetContainer = NULL;
    733a:	2300      	movs	r3, #0
    733c:	64a3      	str	r3, [r4, #72]	; 0x48
}
    733e:	4620      	mov	r0, r4
    7340:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    7342:	bf00      	nop
    7344:	00006ff5 	.word	0x00006ff5
    7348:	00007265 	.word	0x00007265

0000734c <xQueueGenericSend>:
{
    734c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7350:	b085      	sub	sp, #20
    7352:	9201      	str	r2, [sp, #4]
	configASSERT(pxQueue);
    7354:	b198      	cbz	r0, 737e <xQueueGenericSend+0x32>
    7356:	4604      	mov	r4, r0
	configASSERT(!((pvItemToQueue == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
    7358:	b1d1      	cbz	r1, 7390 <xQueueGenericSend+0x44>
	configASSERT(!((xCopyPosition == queueOVERWRITE) && (pxQueue->uxLength != 1)));
    735a:	2b02      	cmp	r3, #2
    735c:	d024      	beq.n	73a8 <xQueueGenericSend+0x5c>
    735e:	461e      	mov	r6, r3
    7360:	460f      	mov	r7, r1
		configASSERT(!((xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED) && (xTicksToWait != 0)));
    7362:	4b64      	ldr	r3, [pc, #400]	; (74f4 <xQueueGenericSend+0x1a8>)
    7364:	4798      	blx	r3
    7366:	bb58      	cbnz	r0, 73c0 <xQueueGenericSend+0x74>
    7368:	9b01      	ldr	r3, [sp, #4]
    736a:	b38b      	cbz	r3, 73d0 <xQueueGenericSend+0x84>
    736c:	f04f 0380 	mov.w	r3, #128	; 0x80
    7370:	f383 8811 	msr	BASEPRI, r3
    7374:	f3bf 8f6f 	isb	sy
    7378:	f3bf 8f4f 	dsb	sy
    737c:	e7fe      	b.n	737c <xQueueGenericSend+0x30>
    737e:	f04f 0380 	mov.w	r3, #128	; 0x80
    7382:	f383 8811 	msr	BASEPRI, r3
    7386:	f3bf 8f6f 	isb	sy
    738a:	f3bf 8f4f 	dsb	sy
    738e:	e7fe      	b.n	738e <xQueueGenericSend+0x42>
	configASSERT(!((pvItemToQueue == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
    7390:	6c02      	ldr	r2, [r0, #64]	; 0x40
    7392:	2a00      	cmp	r2, #0
    7394:	d0e1      	beq.n	735a <xQueueGenericSend+0xe>
    7396:	f04f 0380 	mov.w	r3, #128	; 0x80
    739a:	f383 8811 	msr	BASEPRI, r3
    739e:	f3bf 8f6f 	isb	sy
    73a2:	f3bf 8f4f 	dsb	sy
    73a6:	e7fe      	b.n	73a6 <xQueueGenericSend+0x5a>
	configASSERT(!((xCopyPosition == queueOVERWRITE) && (pxQueue->uxLength != 1)));
    73a8:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    73aa:	2a01      	cmp	r2, #1
    73ac:	d0d7      	beq.n	735e <xQueueGenericSend+0x12>
    73ae:	f04f 0380 	mov.w	r3, #128	; 0x80
    73b2:	f383 8811 	msr	BASEPRI, r3
    73b6:	f3bf 8f6f 	isb	sy
    73ba:	f3bf 8f4f 	dsb	sy
    73be:	e7fe      	b.n	73be <xQueueGenericSend+0x72>
    73c0:	2500      	movs	r5, #0
		taskENTER_CRITICAL();
    73c2:	f8df 815c 	ldr.w	r8, [pc, #348]	; 7520 <xQueueGenericSend+0x1d4>
					vTaskInternalSetTimeOutState(&xTimeOut);
    73c6:	f8df a15c 	ldr.w	sl, [pc, #348]	; 7524 <xQueueGenericSend+0x1d8>
					portYIELD_WITHIN_API();
    73ca:	f8df 9134 	ldr.w	r9, [pc, #308]	; 7500 <xQueueGenericSend+0x1b4>
    73ce:	e041      	b.n	7454 <xQueueGenericSend+0x108>
    73d0:	2500      	movs	r5, #0
    73d2:	e7f6      	b.n	73c2 <xQueueGenericSend+0x76>
				xYieldRequired = prvCopyDataToQueue(pxQueue, pvItemToQueue, xCopyPosition);
    73d4:	4632      	mov	r2, r6
    73d6:	4639      	mov	r1, r7
    73d8:	4620      	mov	r0, r4
    73da:	4b47      	ldr	r3, [pc, #284]	; (74f8 <xQueueGenericSend+0x1ac>)
    73dc:	4798      	blx	r3
					if (pxQueue->pxQueueSetContainer != NULL) {
    73de:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    73e0:	b193      	cbz	r3, 7408 <xQueueGenericSend+0xbc>
						if (prvNotifyQueueSetContainer(pxQueue, xCopyPosition) != pdFALSE) {
    73e2:	4631      	mov	r1, r6
    73e4:	4620      	mov	r0, r4
    73e6:	4b45      	ldr	r3, [pc, #276]	; (74fc <xQueueGenericSend+0x1b0>)
    73e8:	4798      	blx	r3
    73ea:	b138      	cbz	r0, 73fc <xQueueGenericSend+0xb0>
							queueYIELD_IF_USING_PREEMPTION();
    73ec:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    73f0:	4b43      	ldr	r3, [pc, #268]	; (7500 <xQueueGenericSend+0x1b4>)
    73f2:	601a      	str	r2, [r3, #0]
    73f4:	f3bf 8f4f 	dsb	sy
    73f8:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
    73fc:	4b41      	ldr	r3, [pc, #260]	; (7504 <xQueueGenericSend+0x1b8>)
    73fe:	4798      	blx	r3
				return pdPASS;
    7400:	2001      	movs	r0, #1
}
    7402:	b005      	add	sp, #20
    7404:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
						if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
    7408:	6a63      	ldr	r3, [r4, #36]	; 0x24
    740a:	b173      	cbz	r3, 742a <xQueueGenericSend+0xde>
							if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
    740c:	f104 0024 	add.w	r0, r4, #36	; 0x24
    7410:	4b3d      	ldr	r3, [pc, #244]	; (7508 <xQueueGenericSend+0x1bc>)
    7412:	4798      	blx	r3
    7414:	2800      	cmp	r0, #0
    7416:	d0f1      	beq.n	73fc <xQueueGenericSend+0xb0>
								queueYIELD_IF_USING_PREEMPTION();
    7418:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    741c:	4b38      	ldr	r3, [pc, #224]	; (7500 <xQueueGenericSend+0x1b4>)
    741e:	601a      	str	r2, [r3, #0]
    7420:	f3bf 8f4f 	dsb	sy
    7424:	f3bf 8f6f 	isb	sy
    7428:	e7e8      	b.n	73fc <xQueueGenericSend+0xb0>
						} else if (xYieldRequired != pdFALSE) {
    742a:	2800      	cmp	r0, #0
    742c:	d0e6      	beq.n	73fc <xQueueGenericSend+0xb0>
							queueYIELD_IF_USING_PREEMPTION();
    742e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    7432:	4b33      	ldr	r3, [pc, #204]	; (7500 <xQueueGenericSend+0x1b4>)
    7434:	601a      	str	r2, [r3, #0]
    7436:	f3bf 8f4f 	dsb	sy
    743a:	f3bf 8f6f 	isb	sy
    743e:	e7dd      	b.n	73fc <xQueueGenericSend+0xb0>
					taskEXIT_CRITICAL();
    7440:	4b30      	ldr	r3, [pc, #192]	; (7504 <xQueueGenericSend+0x1b8>)
    7442:	4798      	blx	r3
					return errQUEUE_FULL;
    7444:	2000      	movs	r0, #0
    7446:	e7dc      	b.n	7402 <xQueueGenericSend+0xb6>
				prvUnlockQueue(pxQueue);
    7448:	4620      	mov	r0, r4
    744a:	4b30      	ldr	r3, [pc, #192]	; (750c <xQueueGenericSend+0x1c0>)
    744c:	4798      	blx	r3
				(void)xTaskResumeAll();
    744e:	4b30      	ldr	r3, [pc, #192]	; (7510 <xQueueGenericSend+0x1c4>)
    7450:	4798      	blx	r3
    7452:	2501      	movs	r5, #1
		taskENTER_CRITICAL();
    7454:	47c0      	blx	r8
			if ((pxQueue->uxMessagesWaiting < pxQueue->uxLength) || (xCopyPosition == queueOVERWRITE)) {
    7456:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    7458:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    745a:	429a      	cmp	r2, r3
    745c:	d3ba      	bcc.n	73d4 <xQueueGenericSend+0x88>
    745e:	2e02      	cmp	r6, #2
    7460:	d0b8      	beq.n	73d4 <xQueueGenericSend+0x88>
				if (xTicksToWait == (TickType_t)0) {
    7462:	9b01      	ldr	r3, [sp, #4]
    7464:	2b00      	cmp	r3, #0
    7466:	d0eb      	beq.n	7440 <xQueueGenericSend+0xf4>
				} else if (xEntryTimeSet == pdFALSE) {
    7468:	b90d      	cbnz	r5, 746e <xQueueGenericSend+0x122>
					vTaskInternalSetTimeOutState(&xTimeOut);
    746a:	a802      	add	r0, sp, #8
    746c:	47d0      	blx	sl
		taskEXIT_CRITICAL();
    746e:	4b25      	ldr	r3, [pc, #148]	; (7504 <xQueueGenericSend+0x1b8>)
    7470:	4798      	blx	r3
		vTaskSuspendAll();
    7472:	4b28      	ldr	r3, [pc, #160]	; (7514 <xQueueGenericSend+0x1c8>)
    7474:	4798      	blx	r3
		prvLockQueue(pxQueue);
    7476:	47c0      	blx	r8
    7478:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
    747c:	b25b      	sxtb	r3, r3
    747e:	f1b3 3fff 	cmp.w	r3, #4294967295
    7482:	bf04      	itt	eq
    7484:	2300      	moveq	r3, #0
    7486:	f884 3044 	strbeq.w	r3, [r4, #68]	; 0x44
    748a:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
    748e:	b25b      	sxtb	r3, r3
    7490:	f1b3 3fff 	cmp.w	r3, #4294967295
    7494:	bf04      	itt	eq
    7496:	2300      	moveq	r3, #0
    7498:	f884 3045 	strbeq.w	r3, [r4, #69]	; 0x45
    749c:	4b19      	ldr	r3, [pc, #100]	; (7504 <xQueueGenericSend+0x1b8>)
    749e:	4798      	blx	r3
		if (xTaskCheckForTimeOut(&xTimeOut, &xTicksToWait) == pdFALSE) {
    74a0:	a901      	add	r1, sp, #4
    74a2:	a802      	add	r0, sp, #8
    74a4:	4b1c      	ldr	r3, [pc, #112]	; (7518 <xQueueGenericSend+0x1cc>)
    74a6:	4798      	blx	r3
    74a8:	b9e0      	cbnz	r0, 74e4 <xQueueGenericSend+0x198>
	taskENTER_CRITICAL();
    74aa:	47c0      	blx	r8
		if (pxQueue->uxMessagesWaiting == pxQueue->uxLength) {
    74ac:	f8d4 b038 	ldr.w	fp, [r4, #56]	; 0x38
    74b0:	6be5      	ldr	r5, [r4, #60]	; 0x3c
	taskEXIT_CRITICAL();
    74b2:	4b14      	ldr	r3, [pc, #80]	; (7504 <xQueueGenericSend+0x1b8>)
    74b4:	4798      	blx	r3
			if (prvIsQueueFull(pxQueue) != pdFALSE) {
    74b6:	45ab      	cmp	fp, r5
    74b8:	d1c6      	bne.n	7448 <xQueueGenericSend+0xfc>
				vTaskPlaceOnEventList(&(pxQueue->xTasksWaitingToSend), xTicksToWait);
    74ba:	9901      	ldr	r1, [sp, #4]
    74bc:	f104 0010 	add.w	r0, r4, #16
    74c0:	4b16      	ldr	r3, [pc, #88]	; (751c <xQueueGenericSend+0x1d0>)
    74c2:	4798      	blx	r3
				prvUnlockQueue(pxQueue);
    74c4:	4620      	mov	r0, r4
    74c6:	4b11      	ldr	r3, [pc, #68]	; (750c <xQueueGenericSend+0x1c0>)
    74c8:	4798      	blx	r3
				if (xTaskResumeAll() == pdFALSE) {
    74ca:	4b11      	ldr	r3, [pc, #68]	; (7510 <xQueueGenericSend+0x1c4>)
    74cc:	4798      	blx	r3
    74ce:	2800      	cmp	r0, #0
    74d0:	d1bf      	bne.n	7452 <xQueueGenericSend+0x106>
					portYIELD_WITHIN_API();
    74d2:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    74d6:	f8c9 3000 	str.w	r3, [r9]
    74da:	f3bf 8f4f 	dsb	sy
    74de:	f3bf 8f6f 	isb	sy
    74e2:	e7b6      	b.n	7452 <xQueueGenericSend+0x106>
			prvUnlockQueue(pxQueue);
    74e4:	4620      	mov	r0, r4
    74e6:	4b09      	ldr	r3, [pc, #36]	; (750c <xQueueGenericSend+0x1c0>)
    74e8:	4798      	blx	r3
			(void)xTaskResumeAll();
    74ea:	4b09      	ldr	r3, [pc, #36]	; (7510 <xQueueGenericSend+0x1c4>)
    74ec:	4798      	blx	r3
			return errQUEUE_FULL;
    74ee:	2000      	movs	r0, #0
    74f0:	e787      	b.n	7402 <xQueueGenericSend+0xb6>
    74f2:	bf00      	nop
    74f4:	000082c9 	.word	0x000082c9
    74f8:	00007091 	.word	0x00007091
    74fc:	00007111 	.word	0x00007111
    7500:	e000ed04 	.word	0xe000ed04
    7504:	00006d89 	.word	0x00006d89
    7508:	00008189 	.word	0x00008189
    750c:	000071bd 	.word	0x000071bd
    7510:	00007d89 	.word	0x00007d89
    7514:	00007c41 	.word	0x00007c41
    7518:	0000822d 	.word	0x0000822d
    751c:	00008109 	.word	0x00008109
    7520:	00006d45 	.word	0x00006d45
    7524:	00008219 	.word	0x00008219

00007528 <xQueueGenericSendFromISR>:
{
    7528:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	configASSERT(pxQueue);
    752c:	2800      	cmp	r0, #0
    752e:	d036      	beq.n	759e <xQueueGenericSendFromISR+0x76>
    7530:	4604      	mov	r4, r0
	configASSERT(!((pvItemToQueue == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
    7532:	2900      	cmp	r1, #0
    7534:	d03c      	beq.n	75b0 <xQueueGenericSendFromISR+0x88>
	configASSERT(!((xCopyPosition == queueOVERWRITE) && (pxQueue->uxLength != 1)));
    7536:	2b02      	cmp	r3, #2
    7538:	d046      	beq.n	75c8 <xQueueGenericSendFromISR+0xa0>
    753a:	461f      	mov	r7, r3
    753c:	4690      	mov	r8, r2
    753e:	4689      	mov	r9, r1
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
    7540:	4b37      	ldr	r3, [pc, #220]	; (7620 <xQueueGenericSendFromISR+0xf8>)
    7542:	4798      	blx	r3
	__asm volatile("	mrs %0, basepri											\n"
    7544:	f3ef 8611 	mrs	r6, BASEPRI
    7548:	f04f 0380 	mov.w	r3, #128	; 0x80
    754c:	f383 8811 	msr	BASEPRI, r3
    7550:	f3bf 8f6f 	isb	sy
    7554:	f3bf 8f4f 	dsb	sy
		if ((pxQueue->uxMessagesWaiting < pxQueue->uxLength) || (xCopyPosition == queueOVERWRITE)) {
    7558:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    755a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    755c:	429a      	cmp	r2, r3
    755e:	d301      	bcc.n	7564 <xQueueGenericSendFromISR+0x3c>
    7560:	2f02      	cmp	r7, #2
    7562:	d151      	bne.n	7608 <xQueueGenericSendFromISR+0xe0>
			const int8_t cTxLock = pxQueue->cTxLock;
    7564:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
    7568:	b26d      	sxtb	r5, r5
			(void)prvCopyDataToQueue(pxQueue, pvItemToQueue, xCopyPosition);
    756a:	463a      	mov	r2, r7
    756c:	4649      	mov	r1, r9
    756e:	4620      	mov	r0, r4
    7570:	4b2c      	ldr	r3, [pc, #176]	; (7624 <xQueueGenericSendFromISR+0xfc>)
    7572:	4798      	blx	r3
			if (cTxLock == queueUNLOCKED) {
    7574:	f1b5 3fff 	cmp.w	r5, #4294967295
    7578:	d140      	bne.n	75fc <xQueueGenericSendFromISR+0xd4>
					if (pxQueue->pxQueueSetContainer != NULL) {
    757a:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    757c:	b383      	cbz	r3, 75e0 <xQueueGenericSendFromISR+0xb8>
						if (prvNotifyQueueSetContainer(pxQueue, xCopyPosition) != pdFALSE) {
    757e:	4639      	mov	r1, r7
    7580:	4620      	mov	r0, r4
    7582:	4b29      	ldr	r3, [pc, #164]	; (7628 <xQueueGenericSendFromISR+0x100>)
    7584:	4798      	blx	r3
    7586:	2800      	cmp	r0, #0
    7588:	d040      	beq.n	760c <xQueueGenericSendFromISR+0xe4>
							if (pxHigherPriorityTaskWoken != NULL) {
    758a:	f1b8 0f00 	cmp.w	r8, #0
    758e:	d03f      	beq.n	7610 <xQueueGenericSendFromISR+0xe8>
								*pxHigherPriorityTaskWoken = pdTRUE;
    7590:	2001      	movs	r0, #1
    7592:	f8c8 0000 	str.w	r0, [r8]
	__asm volatile("	msr basepri, %0	" ::"r"(ulNewMaskValue) : "memory");
    7596:	f386 8811 	msr	BASEPRI, r6
}
    759a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	__asm volatile("	mov %0, %1												\n"
    759e:	f04f 0380 	mov.w	r3, #128	; 0x80
    75a2:	f383 8811 	msr	BASEPRI, r3
    75a6:	f3bf 8f6f 	isb	sy
    75aa:	f3bf 8f4f 	dsb	sy
    75ae:	e7fe      	b.n	75ae <xQueueGenericSendFromISR+0x86>
	configASSERT(!((pvItemToQueue == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
    75b0:	6c00      	ldr	r0, [r0, #64]	; 0x40
    75b2:	2800      	cmp	r0, #0
    75b4:	d0bf      	beq.n	7536 <xQueueGenericSendFromISR+0xe>
    75b6:	f04f 0380 	mov.w	r3, #128	; 0x80
    75ba:	f383 8811 	msr	BASEPRI, r3
    75be:	f3bf 8f6f 	isb	sy
    75c2:	f3bf 8f4f 	dsb	sy
    75c6:	e7fe      	b.n	75c6 <xQueueGenericSendFromISR+0x9e>
	configASSERT(!((xCopyPosition == queueOVERWRITE) && (pxQueue->uxLength != 1)));
    75c8:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    75ca:	2801      	cmp	r0, #1
    75cc:	d0b5      	beq.n	753a <xQueueGenericSendFromISR+0x12>
    75ce:	f04f 0380 	mov.w	r3, #128	; 0x80
    75d2:	f383 8811 	msr	BASEPRI, r3
    75d6:	f3bf 8f6f 	isb	sy
    75da:	f3bf 8f4f 	dsb	sy
    75de:	e7fe      	b.n	75de <xQueueGenericSendFromISR+0xb6>
						if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
    75e0:	6a63      	ldr	r3, [r4, #36]	; 0x24
    75e2:	b1bb      	cbz	r3, 7614 <xQueueGenericSendFromISR+0xec>
							if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
    75e4:	f104 0024 	add.w	r0, r4, #36	; 0x24
    75e8:	4b10      	ldr	r3, [pc, #64]	; (762c <xQueueGenericSendFromISR+0x104>)
    75ea:	4798      	blx	r3
    75ec:	b1a0      	cbz	r0, 7618 <xQueueGenericSendFromISR+0xf0>
								if (pxHigherPriorityTaskWoken != NULL) {
    75ee:	f1b8 0f00 	cmp.w	r8, #0
    75f2:	d013      	beq.n	761c <xQueueGenericSendFromISR+0xf4>
									*pxHigherPriorityTaskWoken = pdTRUE;
    75f4:	2001      	movs	r0, #1
    75f6:	f8c8 0000 	str.w	r0, [r8]
    75fa:	e7cc      	b.n	7596 <xQueueGenericSendFromISR+0x6e>
				pxQueue->cTxLock = (int8_t)(cTxLock + 1);
    75fc:	1c6b      	adds	r3, r5, #1
    75fe:	b25b      	sxtb	r3, r3
    7600:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
			xReturn = pdPASS;
    7604:	2001      	movs	r0, #1
    7606:	e7c6      	b.n	7596 <xQueueGenericSendFromISR+0x6e>
			xReturn = errQUEUE_FULL;
    7608:	2000      	movs	r0, #0
    760a:	e7c4      	b.n	7596 <xQueueGenericSendFromISR+0x6e>
			xReturn = pdPASS;
    760c:	2001      	movs	r0, #1
    760e:	e7c2      	b.n	7596 <xQueueGenericSendFromISR+0x6e>
    7610:	2001      	movs	r0, #1
    7612:	e7c0      	b.n	7596 <xQueueGenericSendFromISR+0x6e>
    7614:	2001      	movs	r0, #1
    7616:	e7be      	b.n	7596 <xQueueGenericSendFromISR+0x6e>
    7618:	2001      	movs	r0, #1
    761a:	e7bc      	b.n	7596 <xQueueGenericSendFromISR+0x6e>
    761c:	2001      	movs	r0, #1
    761e:	e7ba      	b.n	7596 <xQueueGenericSendFromISR+0x6e>
    7620:	00006f9d 	.word	0x00006f9d
    7624:	00007091 	.word	0x00007091
    7628:	00007111 	.word	0x00007111
    762c:	00008189 	.word	0x00008189

00007630 <xQueueReceive>:
{
    7630:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    7634:	b084      	sub	sp, #16
    7636:	9201      	str	r2, [sp, #4]
	configASSERT((pxQueue));
    7638:	b180      	cbz	r0, 765c <xQueueReceive+0x2c>
    763a:	4604      	mov	r4, r0
	configASSERT(!(((pvBuffer) == NULL) && ((pxQueue)->uxItemSize != (UBaseType_t)0U)));
    763c:	b1b9      	cbz	r1, 766e <xQueueReceive+0x3e>
    763e:	460e      	mov	r6, r1
		configASSERT(!((xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED) && (xTicksToWait != 0)));
    7640:	4b50      	ldr	r3, [pc, #320]	; (7784 <xQueueReceive+0x154>)
    7642:	4798      	blx	r3
    7644:	b9f8      	cbnz	r0, 7686 <xQueueReceive+0x56>
    7646:	9b01      	ldr	r3, [sp, #4]
    7648:	b32b      	cbz	r3, 7696 <xQueueReceive+0x66>
    764a:	f04f 0380 	mov.w	r3, #128	; 0x80
    764e:	f383 8811 	msr	BASEPRI, r3
    7652:	f3bf 8f6f 	isb	sy
    7656:	f3bf 8f4f 	dsb	sy
    765a:	e7fe      	b.n	765a <xQueueReceive+0x2a>
    765c:	f04f 0380 	mov.w	r3, #128	; 0x80
    7660:	f383 8811 	msr	BASEPRI, r3
    7664:	f3bf 8f6f 	isb	sy
    7668:	f3bf 8f4f 	dsb	sy
    766c:	e7fe      	b.n	766c <xQueueReceive+0x3c>
	configASSERT(!(((pvBuffer) == NULL) && ((pxQueue)->uxItemSize != (UBaseType_t)0U)));
    766e:	6c03      	ldr	r3, [r0, #64]	; 0x40
    7670:	2b00      	cmp	r3, #0
    7672:	d0e4      	beq.n	763e <xQueueReceive+0xe>
    7674:	f04f 0380 	mov.w	r3, #128	; 0x80
    7678:	f383 8811 	msr	BASEPRI, r3
    767c:	f3bf 8f6f 	isb	sy
    7680:	f3bf 8f4f 	dsb	sy
    7684:	e7fe      	b.n	7684 <xQueueReceive+0x54>
    7686:	2700      	movs	r7, #0
		taskENTER_CRITICAL();
    7688:	f8df 8124 	ldr.w	r8, [pc, #292]	; 77b0 <xQueueReceive+0x180>
					vTaskInternalSetTimeOutState(&xTimeOut);
    768c:	f8df a124 	ldr.w	sl, [pc, #292]	; 77b4 <xQueueReceive+0x184>
					portYIELD_WITHIN_API();
    7690:	f8df 90fc 	ldr.w	r9, [pc, #252]	; 7790 <xQueueReceive+0x160>
    7694:	e029      	b.n	76ea <xQueueReceive+0xba>
    7696:	2700      	movs	r7, #0
    7698:	e7f6      	b.n	7688 <xQueueReceive+0x58>
				prvCopyDataFromQueue(pxQueue, pvBuffer);
    769a:	4631      	mov	r1, r6
    769c:	4620      	mov	r0, r4
    769e:	4b3a      	ldr	r3, [pc, #232]	; (7788 <xQueueReceive+0x158>)
    76a0:	4798      	blx	r3
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - (UBaseType_t)1;
    76a2:	3d01      	subs	r5, #1
    76a4:	63a5      	str	r5, [r4, #56]	; 0x38
				if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
    76a6:	6923      	ldr	r3, [r4, #16]
    76a8:	b163      	cbz	r3, 76c4 <xQueueReceive+0x94>
					if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
    76aa:	f104 0010 	add.w	r0, r4, #16
    76ae:	4b37      	ldr	r3, [pc, #220]	; (778c <xQueueReceive+0x15c>)
    76b0:	4798      	blx	r3
    76b2:	b138      	cbz	r0, 76c4 <xQueueReceive+0x94>
						queueYIELD_IF_USING_PREEMPTION();
    76b4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    76b8:	4b35      	ldr	r3, [pc, #212]	; (7790 <xQueueReceive+0x160>)
    76ba:	601a      	str	r2, [r3, #0]
    76bc:	f3bf 8f4f 	dsb	sy
    76c0:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
    76c4:	4b33      	ldr	r3, [pc, #204]	; (7794 <xQueueReceive+0x164>)
    76c6:	4798      	blx	r3
				return pdPASS;
    76c8:	2001      	movs	r0, #1
}
    76ca:	b004      	add	sp, #16
    76cc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
					taskEXIT_CRITICAL();
    76d0:	4b30      	ldr	r3, [pc, #192]	; (7794 <xQueueReceive+0x164>)
    76d2:	4798      	blx	r3
					return errQUEUE_EMPTY;
    76d4:	2000      	movs	r0, #0
    76d6:	e7f8      	b.n	76ca <xQueueReceive+0x9a>
					vTaskInternalSetTimeOutState(&xTimeOut);
    76d8:	a802      	add	r0, sp, #8
    76da:	47d0      	blx	sl
    76dc:	e00e      	b.n	76fc <xQueueReceive+0xcc>
				prvUnlockQueue(pxQueue);
    76de:	4620      	mov	r0, r4
    76e0:	4b2d      	ldr	r3, [pc, #180]	; (7798 <xQueueReceive+0x168>)
    76e2:	4798      	blx	r3
				(void)xTaskResumeAll();
    76e4:	4b2d      	ldr	r3, [pc, #180]	; (779c <xQueueReceive+0x16c>)
    76e6:	4798      	blx	r3
    76e8:	2701      	movs	r7, #1
		taskENTER_CRITICAL();
    76ea:	47c0      	blx	r8
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    76ec:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if (uxMessagesWaiting > (UBaseType_t)0) {
    76ee:	2d00      	cmp	r5, #0
    76f0:	d1d3      	bne.n	769a <xQueueReceive+0x6a>
				if (xTicksToWait == (TickType_t)0) {
    76f2:	9b01      	ldr	r3, [sp, #4]
    76f4:	2b00      	cmp	r3, #0
    76f6:	d0eb      	beq.n	76d0 <xQueueReceive+0xa0>
				} else if (xEntryTimeSet == pdFALSE) {
    76f8:	2f00      	cmp	r7, #0
    76fa:	d0ed      	beq.n	76d8 <xQueueReceive+0xa8>
		taskEXIT_CRITICAL();
    76fc:	4b25      	ldr	r3, [pc, #148]	; (7794 <xQueueReceive+0x164>)
    76fe:	4798      	blx	r3
		vTaskSuspendAll();
    7700:	4b27      	ldr	r3, [pc, #156]	; (77a0 <xQueueReceive+0x170>)
    7702:	4798      	blx	r3
		prvLockQueue(pxQueue);
    7704:	47c0      	blx	r8
    7706:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
    770a:	b25b      	sxtb	r3, r3
    770c:	f1b3 3fff 	cmp.w	r3, #4294967295
    7710:	bf04      	itt	eq
    7712:	2300      	moveq	r3, #0
    7714:	f884 3044 	strbeq.w	r3, [r4, #68]	; 0x44
    7718:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
    771c:	b25b      	sxtb	r3, r3
    771e:	f1b3 3fff 	cmp.w	r3, #4294967295
    7722:	bf04      	itt	eq
    7724:	2300      	moveq	r3, #0
    7726:	f884 3045 	strbeq.w	r3, [r4, #69]	; 0x45
    772a:	4b1a      	ldr	r3, [pc, #104]	; (7794 <xQueueReceive+0x164>)
    772c:	4798      	blx	r3
		if (xTaskCheckForTimeOut(&xTimeOut, &xTicksToWait) == pdFALSE) {
    772e:	a901      	add	r1, sp, #4
    7730:	a802      	add	r0, sp, #8
    7732:	4b1c      	ldr	r3, [pc, #112]	; (77a4 <xQueueReceive+0x174>)
    7734:	4798      	blx	r3
    7736:	b9c8      	cbnz	r0, 776c <xQueueReceive+0x13c>
			if (prvIsQueueEmpty(pxQueue) != pdFALSE) {
    7738:	4620      	mov	r0, r4
    773a:	4b1b      	ldr	r3, [pc, #108]	; (77a8 <xQueueReceive+0x178>)
    773c:	4798      	blx	r3
    773e:	2800      	cmp	r0, #0
    7740:	d0cd      	beq.n	76de <xQueueReceive+0xae>
				vTaskPlaceOnEventList(&(pxQueue->xTasksWaitingToReceive), xTicksToWait);
    7742:	9901      	ldr	r1, [sp, #4]
    7744:	f104 0024 	add.w	r0, r4, #36	; 0x24
    7748:	4b18      	ldr	r3, [pc, #96]	; (77ac <xQueueReceive+0x17c>)
    774a:	4798      	blx	r3
				prvUnlockQueue(pxQueue);
    774c:	4620      	mov	r0, r4
    774e:	4b12      	ldr	r3, [pc, #72]	; (7798 <xQueueReceive+0x168>)
    7750:	4798      	blx	r3
				if (xTaskResumeAll() == pdFALSE) {
    7752:	4b12      	ldr	r3, [pc, #72]	; (779c <xQueueReceive+0x16c>)
    7754:	4798      	blx	r3
    7756:	2800      	cmp	r0, #0
    7758:	d1c6      	bne.n	76e8 <xQueueReceive+0xb8>
					portYIELD_WITHIN_API();
    775a:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    775e:	f8c9 3000 	str.w	r3, [r9]
    7762:	f3bf 8f4f 	dsb	sy
    7766:	f3bf 8f6f 	isb	sy
    776a:	e7bd      	b.n	76e8 <xQueueReceive+0xb8>
			prvUnlockQueue(pxQueue);
    776c:	4620      	mov	r0, r4
    776e:	4b0a      	ldr	r3, [pc, #40]	; (7798 <xQueueReceive+0x168>)
    7770:	4798      	blx	r3
			(void)xTaskResumeAll();
    7772:	4b0a      	ldr	r3, [pc, #40]	; (779c <xQueueReceive+0x16c>)
    7774:	4798      	blx	r3
			if (prvIsQueueEmpty(pxQueue) != pdFALSE) {
    7776:	4620      	mov	r0, r4
    7778:	4b0b      	ldr	r3, [pc, #44]	; (77a8 <xQueueReceive+0x178>)
    777a:	4798      	blx	r3
    777c:	2800      	cmp	r0, #0
    777e:	d0b3      	beq.n	76e8 <xQueueReceive+0xb8>
				return errQUEUE_EMPTY;
    7780:	2000      	movs	r0, #0
    7782:	e7a2      	b.n	76ca <xQueueReceive+0x9a>
    7784:	000082c9 	.word	0x000082c9
    7788:	00007195 	.word	0x00007195
    778c:	00008189 	.word	0x00008189
    7790:	e000ed04 	.word	0xe000ed04
    7794:	00006d89 	.word	0x00006d89
    7798:	000071bd 	.word	0x000071bd
    779c:	00007d89 	.word	0x00007d89
    77a0:	00007c41 	.word	0x00007c41
    77a4:	0000822d 	.word	0x0000822d
    77a8:	00007071 	.word	0x00007071
    77ac:	00008109 	.word	0x00008109
    77b0:	00006d45 	.word	0x00006d45
    77b4:	00008219 	.word	0x00008219

000077b8 <vQueueWaitForMessageRestricted>:
{
    77b8:	b570      	push	{r4, r5, r6, lr}
    77ba:	4604      	mov	r4, r0
    77bc:	460d      	mov	r5, r1
    77be:	4616      	mov	r6, r2
	prvLockQueue(pxQueue);
    77c0:	4b11      	ldr	r3, [pc, #68]	; (7808 <vQueueWaitForMessageRestricted+0x50>)
    77c2:	4798      	blx	r3
    77c4:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
    77c8:	b25b      	sxtb	r3, r3
    77ca:	f1b3 3fff 	cmp.w	r3, #4294967295
    77ce:	bf04      	itt	eq
    77d0:	2300      	moveq	r3, #0
    77d2:	f884 3044 	strbeq.w	r3, [r4, #68]	; 0x44
    77d6:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
    77da:	b25b      	sxtb	r3, r3
    77dc:	f1b3 3fff 	cmp.w	r3, #4294967295
    77e0:	bf04      	itt	eq
    77e2:	2300      	moveq	r3, #0
    77e4:	f884 3045 	strbeq.w	r3, [r4, #69]	; 0x45
    77e8:	4b08      	ldr	r3, [pc, #32]	; (780c <vQueueWaitForMessageRestricted+0x54>)
    77ea:	4798      	blx	r3
	if (pxQueue->uxMessagesWaiting == (UBaseType_t)0U) {
    77ec:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    77ee:	b11b      	cbz	r3, 77f8 <vQueueWaitForMessageRestricted+0x40>
	prvUnlockQueue(pxQueue);
    77f0:	4620      	mov	r0, r4
    77f2:	4b07      	ldr	r3, [pc, #28]	; (7810 <vQueueWaitForMessageRestricted+0x58>)
    77f4:	4798      	blx	r3
    77f6:	bd70      	pop	{r4, r5, r6, pc}
		vTaskPlaceOnEventListRestricted(&(pxQueue->xTasksWaitingToReceive), xTicksToWait, xWaitIndefinitely);
    77f8:	4632      	mov	r2, r6
    77fa:	4629      	mov	r1, r5
    77fc:	f104 0024 	add.w	r0, r4, #36	; 0x24
    7800:	4b04      	ldr	r3, [pc, #16]	; (7814 <vQueueWaitForMessageRestricted+0x5c>)
    7802:	4798      	blx	r3
    7804:	e7f4      	b.n	77f0 <vQueueWaitForMessageRestricted+0x38>
    7806:	bf00      	nop
    7808:	00006d45 	.word	0x00006d45
    780c:	00006d89 	.word	0x00006d89
    7810:	000071bd 	.word	0x000071bd
    7814:	00008145 	.word	0x00008145

00007818 <prvTaskIsTaskSuspended>:

	/* Accesses xPendingReadyList so must be called from a critical
	section. */

	/* It does not make sense to check if the calling task is suspended. */
	configASSERT(xTask);
    7818:	b160      	cbz	r0, 7834 <prvTaskIsTaskSuspended+0x1c>

	/* Is the task being resumed actually in the suspended list? */
	if (listIS_CONTAINED_WITHIN(&xSuspendedTaskList, &(pxTCB->xStateListItem)) != pdFALSE) {
    781a:	6941      	ldr	r1, [r0, #20]
    781c:	4a0c      	ldr	r2, [pc, #48]	; (7850 <prvTaskIsTaskSuspended+0x38>)
    781e:	4291      	cmp	r1, r2
    7820:	d111      	bne.n	7846 <prvTaskIsTaskSuspended+0x2e>
		/* Has the task already been resumed from within an ISR? */
		if (listIS_CONTAINED_WITHIN(&xPendingReadyList, &(pxTCB->xEventListItem)) == pdFALSE) {
    7822:	6a80      	ldr	r0, [r0, #40]	; 0x28
    7824:	f102 0314 	add.w	r3, r2, #20
    7828:	4298      	cmp	r0, r3
    782a:	d00e      	beq.n	784a <prvTaskIsTaskSuspended+0x32>
			/* Is it in the suspended list because it is in the	Suspended
			state, or because is is blocked with no timeout? */
			if (listIS_CONTAINED_WITHIN(NULL, &(pxTCB->xEventListItem))
			    != pdFALSE) /*lint !e961.  The cast is only redundant when NULL is used. */
    782c:	fab0 f080 	clz	r0, r0
    7830:	0940      	lsrs	r0, r0, #5
    7832:	4770      	bx	lr
    7834:	f04f 0380 	mov.w	r3, #128	; 0x80
    7838:	f383 8811 	msr	BASEPRI, r3
    783c:	f3bf 8f6f 	isb	sy
    7840:	f3bf 8f4f 	dsb	sy
    7844:	e7fe      	b.n	7844 <prvTaskIsTaskSuspended+0x2c>
	BaseType_t         xReturn = pdFALSE;
    7846:	2000      	movs	r0, #0
    7848:	4770      	bx	lr
    784a:	2000      	movs	r0, #0
	} else {
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    784c:	4770      	bx	lr
    784e:	bf00      	nop
    7850:	200013d0 	.word	0x200013d0

00007854 <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[tskIDLE_PRIORITY])) > (UBaseType_t)1) {
    7854:	4a06      	ldr	r2, [pc, #24]	; (7870 <prvIdleTask+0x1c>)
				taskYIELD();
    7856:	4807      	ldr	r0, [pc, #28]	; (7874 <prvIdleTask+0x20>)
    7858:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[tskIDLE_PRIORITY])) > (UBaseType_t)1) {
    785c:	6a93      	ldr	r3, [r2, #40]	; 0x28
    785e:	2b01      	cmp	r3, #1
    7860:	d9fc      	bls.n	785c <prvIdleTask+0x8>
				taskYIELD();
    7862:	6001      	str	r1, [r0, #0]
    7864:	f3bf 8f4f 	dsb	sy
    7868:	f3bf 8f6f 	isb	sy
    786c:	e7f6      	b.n	785c <prvIdleTask+0x8>
    786e:	bf00      	nop
    7870:	200013d0 	.word	0x200013d0
    7874:	e000ed04 	.word	0xe000ed04

00007878 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime(void)
{
	TCB_t *pxTCB;

	if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
    7878:	4b09      	ldr	r3, [pc, #36]	; (78a0 <prvResetNextTaskUnblockTime+0x28>)
    787a:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
    787e:	681b      	ldr	r3, [r3, #0]
    7880:	b143      	cbz	r3, 7894 <prvResetNextTaskUnblockTime+0x1c>
	} else {
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		(pxTCB)              = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
    7882:	4b07      	ldr	r3, [pc, #28]	; (78a0 <prvResetNextTaskUnblockTime+0x28>)
    7884:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
    7888:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE(&((pxTCB)->xStateListItem));
    788a:	68d2      	ldr	r2, [r2, #12]
    788c:	6852      	ldr	r2, [r2, #4]
    788e:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
    7892:	4770      	bx	lr
		xNextTaskUnblockTime = portMAX_DELAY;
    7894:	f04f 32ff 	mov.w	r2, #4294967295
    7898:	4b01      	ldr	r3, [pc, #4]	; (78a0 <prvResetNextTaskUnblockTime+0x28>)
    789a:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
    789e:	4770      	bx	lr
    78a0:	200013d0 	.word	0x200013d0

000078a4 <prvAddCurrentTaskToDelayedList>:

#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList(TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely)
{
    78a4:	b570      	push	{r4, r5, r6, lr}
    78a6:	4604      	mov	r4, r0
    78a8:	460e      	mov	r6, r1
	TickType_t       xTimeToWake;
	const TickType_t xConstTickCount = xTickCount;
    78aa:	4b1a      	ldr	r3, [pc, #104]	; (7914 <prvAddCurrentTaskToDelayedList+0x70>)
    78ac:	f8d3 5094 	ldr.w	r5, [r3, #148]	; 0x94
	}
#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if (uxListRemove(&(pxCurrentTCB->xStateListItem)) == (UBaseType_t)0) {
    78b0:	f8d3 0098 	ldr.w	r0, [r3, #152]	; 0x98
    78b4:	3004      	adds	r0, #4
    78b6:	4b18      	ldr	r3, [pc, #96]	; (7918 <prvAddCurrentTaskToDelayedList+0x74>)
    78b8:	4798      	blx	r3
		mtCOVERAGE_TEST_MARKER();
	}

#if (INCLUDE_vTaskSuspend == 1)
	{
		if ((xTicksToWait == portMAX_DELAY) && (xCanBlockIndefinitely != pdFALSE)) {
    78ba:	f1b4 3fff 	cmp.w	r4, #4294967295
    78be:	d016      	beq.n	78ee <prvAddCurrentTaskToDelayedList+0x4a>
			vListInsertEnd(&xSuspendedTaskList, &(pxCurrentTCB->xStateListItem));
		} else {
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    78c0:	442c      	add	r4, r5

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE(&(pxCurrentTCB->xStateListItem), xTimeToWake);
    78c2:	4b14      	ldr	r3, [pc, #80]	; (7914 <prvAddCurrentTaskToDelayedList+0x70>)
    78c4:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
    78c8:	605c      	str	r4, [r3, #4]

			if (xTimeToWake < xConstTickCount) {
    78ca:	42a5      	cmp	r5, r4
    78cc:	d818      	bhi.n	7900 <prvAddCurrentTaskToDelayedList+0x5c>
				list. */
				vListInsert(pxOverflowDelayedTaskList, &(pxCurrentTCB->xStateListItem));
			} else {
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert(pxDelayedTaskList, &(pxCurrentTCB->xStateListItem));
    78ce:	4d11      	ldr	r5, [pc, #68]	; (7914 <prvAddCurrentTaskToDelayedList+0x70>)
    78d0:	f8d5 008c 	ldr.w	r0, [r5, #140]	; 0x8c
    78d4:	f8d5 1098 	ldr.w	r1, [r5, #152]	; 0x98
    78d8:	3104      	adds	r1, #4
    78da:	4b10      	ldr	r3, [pc, #64]	; (791c <prvAddCurrentTaskToDelayedList+0x78>)
    78dc:	4798      	blx	r3

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if (xTimeToWake < xNextTaskUnblockTime) {
    78de:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
    78e2:	429c      	cmp	r4, r3
					xNextTaskUnblockTime = xTimeToWake;
    78e4:	bf3c      	itt	cc
    78e6:	462b      	movcc	r3, r5
    78e8:	f8c3 4090 	strcc.w	r4, [r3, #144]	; 0x90
    78ec:	bd70      	pop	{r4, r5, r6, pc}
		if ((xTicksToWait == portMAX_DELAY) && (xCanBlockIndefinitely != pdFALSE)) {
    78ee:	2e00      	cmp	r6, #0
    78f0:	d0e6      	beq.n	78c0 <prvAddCurrentTaskToDelayedList+0x1c>
			vListInsertEnd(&xSuspendedTaskList, &(pxCurrentTCB->xStateListItem));
    78f2:	4808      	ldr	r0, [pc, #32]	; (7914 <prvAddCurrentTaskToDelayedList+0x70>)
    78f4:	f8d0 1098 	ldr.w	r1, [r0, #152]	; 0x98
    78f8:	3104      	adds	r1, #4
    78fa:	4b09      	ldr	r3, [pc, #36]	; (7920 <prvAddCurrentTaskToDelayedList+0x7c>)
    78fc:	4798      	blx	r3
    78fe:	bd70      	pop	{r4, r5, r6, pc}
				vListInsert(pxOverflowDelayedTaskList, &(pxCurrentTCB->xStateListItem));
    7900:	4b04      	ldr	r3, [pc, #16]	; (7914 <prvAddCurrentTaskToDelayedList+0x70>)
    7902:	f8d3 009c 	ldr.w	r0, [r3, #156]	; 0x9c
    7906:	f8d3 1098 	ldr.w	r1, [r3, #152]	; 0x98
    790a:	3104      	adds	r1, #4
    790c:	4b03      	ldr	r3, [pc, #12]	; (791c <prvAddCurrentTaskToDelayedList+0x78>)
    790e:	4798      	blx	r3
    7910:	bd70      	pop	{r4, r5, r6, pc}
    7912:	bf00      	nop
    7914:	200013d0 	.word	0x200013d0
    7918:	00006c49 	.word	0x00006c49
    791c:	00006c15 	.word	0x00006c15
    7920:	00006bfd 	.word	0x00006bfd

00007924 <xTaskCreate>:
{
    7924:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7928:	b083      	sub	sp, #12
    792a:	4683      	mov	fp, r0
    792c:	460d      	mov	r5, r1
    792e:	9301      	str	r3, [sp, #4]
    7930:	f8dd a034 	ldr.w	sl, [sp, #52]	; 0x34
		pxStack = (StackType_t *)pvPortMalloc(
    7934:	0096      	lsls	r6, r2, #2
    7936:	4630      	mov	r0, r6
    7938:	4b66      	ldr	r3, [pc, #408]	; (7ad4 <xTaskCreate+0x1b0>)
    793a:	4798      	blx	r3
		if (pxStack != NULL) {
    793c:	2800      	cmp	r0, #0
    793e:	f000 8096 	beq.w	7a6e <xTaskCreate+0x14a>
    7942:	4607      	mov	r7, r0
			pxNewTCB = (TCB_t *)pvPortMalloc(
    7944:	2054      	movs	r0, #84	; 0x54
    7946:	4b63      	ldr	r3, [pc, #396]	; (7ad4 <xTaskCreate+0x1b0>)
    7948:	4798      	blx	r3
			if (pxNewTCB != NULL) {
    794a:	4604      	mov	r4, r0
    794c:	2800      	cmp	r0, #0
    794e:	f000 808b 	beq.w	7a68 <xTaskCreate+0x144>
				pxNewTCB->pxStack = pxStack;
    7952:	6307      	str	r7, [r0, #48]	; 0x30
		(void)memset(pxNewTCB->pxStack, (int)tskSTACK_FILL_BYTE, (size_t)ulStackDepth * sizeof(StackType_t));
    7954:	4632      	mov	r2, r6
    7956:	21a5      	movs	r1, #165	; 0xa5
    7958:	4638      	mov	r0, r7
    795a:	4b5f      	ldr	r3, [pc, #380]	; (7ad8 <xTaskCreate+0x1b4>)
    795c:	4798      	blx	r3
		pxTopOfStack = pxNewTCB->pxStack + (ulStackDepth - (uint32_t)1);
    795e:	3e04      	subs	r6, #4
    7960:	6b23      	ldr	r3, [r4, #48]	; 0x30
    7962:	441e      	add	r6, r3
		                      & (~(
    7964:	f026 0607 	bic.w	r6, r6, #7
		pxNewTCB->pcTaskName[x] = pcName[x];
    7968:	782b      	ldrb	r3, [r5, #0]
    796a:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
		if (pcName[x] == 0x00) {
    796e:	782b      	ldrb	r3, [r5, #0]
    7970:	b15b      	cbz	r3, 798a <xTaskCreate+0x66>
    7972:	462b      	mov	r3, r5
    7974:	f104 0235 	add.w	r2, r4, #53	; 0x35
    7978:	1de9      	adds	r1, r5, #7
		pxNewTCB->pcTaskName[x] = pcName[x];
    797a:	7858      	ldrb	r0, [r3, #1]
    797c:	f802 0b01 	strb.w	r0, [r2], #1
		if (pcName[x] == 0x00) {
    7980:	f813 0f01 	ldrb.w	r0, [r3, #1]!
    7984:	b108      	cbz	r0, 798a <xTaskCreate+0x66>
	for (x = (UBaseType_t)0; x < (UBaseType_t)configMAX_TASK_NAME_LEN; x++) {
    7986:	4299      	cmp	r1, r3
    7988:	d1f7      	bne.n	797a <xTaskCreate+0x56>
	pxNewTCB->pcTaskName[configMAX_TASK_NAME_LEN - 1] = '\0';
    798a:	2700      	movs	r7, #0
    798c:	f884 703b 	strb.w	r7, [r4, #59]	; 0x3b
    7990:	9d0c      	ldr	r5, [sp, #48]	; 0x30
    7992:	2d04      	cmp	r5, #4
    7994:	bf28      	it	cs
    7996:	2504      	movcs	r5, #4
	pxNewTCB->uxPriority = uxPriority;
    7998:	62e5      	str	r5, [r4, #44]	; 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
    799a:	6465      	str	r5, [r4, #68]	; 0x44
		pxNewTCB->uxMutexesHeld  = 0;
    799c:	64a7      	str	r7, [r4, #72]	; 0x48
	vListInitialiseItem(&(pxNewTCB->xStateListItem));
    799e:	f104 0804 	add.w	r8, r4, #4
    79a2:	4640      	mov	r0, r8
    79a4:	f8df 9154 	ldr.w	r9, [pc, #340]	; 7afc <xTaskCreate+0x1d8>
    79a8:	47c8      	blx	r9
	vListInitialiseItem(&(pxNewTCB->xEventListItem));
    79aa:	f104 0018 	add.w	r0, r4, #24
    79ae:	47c8      	blx	r9
	listSET_LIST_ITEM_OWNER(&(pxNewTCB->xStateListItem), pxNewTCB);
    79b0:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_VALUE(
    79b2:	f1c5 0505 	rsb	r5, r5, #5
    79b6:	61a5      	str	r5, [r4, #24]
	listSET_LIST_ITEM_OWNER(&(pxNewTCB->xEventListItem), pxNewTCB);
    79b8:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->ulNotifiedValue = 0;
    79ba:	64e7      	str	r7, [r4, #76]	; 0x4c
		pxNewTCB->ucNotifyState   = taskNOT_WAITING_NOTIFICATION;
    79bc:	f884 7050 	strb.w	r7, [r4, #80]	; 0x50
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack(pxTopOfStack, pxTaskCode, pvParameters);
    79c0:	9a01      	ldr	r2, [sp, #4]
    79c2:	4659      	mov	r1, fp
    79c4:	4630      	mov	r0, r6
    79c6:	4b45      	ldr	r3, [pc, #276]	; (7adc <xTaskCreate+0x1b8>)
    79c8:	4798      	blx	r3
    79ca:	6020      	str	r0, [r4, #0]
	if ((void *)pxCreatedTask != NULL) {
    79cc:	f1ba 0f00 	cmp.w	sl, #0
    79d0:	d001      	beq.n	79d6 <xTaskCreate+0xb2>
		*pxCreatedTask = (TaskHandle_t)pxNewTCB;
    79d2:	f8ca 4000 	str.w	r4, [sl]
	taskENTER_CRITICAL();
    79d6:	4b42      	ldr	r3, [pc, #264]	; (7ae0 <xTaskCreate+0x1bc>)
    79d8:	4798      	blx	r3
		uxCurrentNumberOfTasks++;
    79da:	4b42      	ldr	r3, [pc, #264]	; (7ae4 <xTaskCreate+0x1c0>)
    79dc:	f8d3 20a0 	ldr.w	r2, [r3, #160]	; 0xa0
    79e0:	3201      	adds	r2, #1
    79e2:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
		if (pxCurrentTCB == NULL) {
    79e6:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
    79ea:	2b00      	cmp	r3, #0
    79ec:	d042      	beq.n	7a74 <xTaskCreate+0x150>
			if (xSchedulerRunning == pdFALSE) {
    79ee:	4b3d      	ldr	r3, [pc, #244]	; (7ae4 <xTaskCreate+0x1c0>)
    79f0:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
    79f4:	b94b      	cbnz	r3, 7a0a <xTaskCreate+0xe6>
				if (pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority) {
    79f6:	4b3b      	ldr	r3, [pc, #236]	; (7ae4 <xTaskCreate+0x1c0>)
    79f8:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
    79fc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    79fe:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    7a00:	429a      	cmp	r2, r3
					pxCurrentTCB = pxNewTCB;
    7a02:	bf9c      	itt	ls
    7a04:	4b37      	ldrls	r3, [pc, #220]	; (7ae4 <xTaskCreate+0x1c0>)
    7a06:	f8c3 4098 	strls.w	r4, [r3, #152]	; 0x98
		uxTaskNumber++;
    7a0a:	4a36      	ldr	r2, [pc, #216]	; (7ae4 <xTaskCreate+0x1c0>)
    7a0c:	f8d2 30d0 	ldr.w	r3, [r2, #208]	; 0xd0
    7a10:	3301      	adds	r3, #1
    7a12:	f8c2 30d0 	str.w	r3, [r2, #208]	; 0xd0
			pxNewTCB->uxTCBNumber = uxTaskNumber;
    7a16:	63e3      	str	r3, [r4, #60]	; 0x3c
		prvAddTaskToReadyList(pxNewTCB);
    7a18:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    7a1a:	f8d2 20d4 	ldr.w	r2, [r2, #212]	; 0xd4
    7a1e:	4293      	cmp	r3, r2
    7a20:	bf84      	itt	hi
    7a22:	4a30      	ldrhi	r2, [pc, #192]	; (7ae4 <xTaskCreate+0x1c0>)
    7a24:	f8c2 30d4 	strhi.w	r3, [r2, #212]	; 0xd4
    7a28:	4d2e      	ldr	r5, [pc, #184]	; (7ae4 <xTaskCreate+0x1c0>)
    7a2a:	f105 0028 	add.w	r0, r5, #40	; 0x28
    7a2e:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    7a32:	4641      	mov	r1, r8
    7a34:	eb00 0083 	add.w	r0, r0, r3, lsl #2
    7a38:	4b2b      	ldr	r3, [pc, #172]	; (7ae8 <xTaskCreate+0x1c4>)
    7a3a:	4798      	blx	r3
	taskEXIT_CRITICAL();
    7a3c:	4b2b      	ldr	r3, [pc, #172]	; (7aec <xTaskCreate+0x1c8>)
    7a3e:	4798      	blx	r3
	if (xSchedulerRunning != pdFALSE) {
    7a40:	f8d5 30cc 	ldr.w	r3, [r5, #204]	; 0xcc
    7a44:	2b00      	cmp	r3, #0
    7a46:	d03f      	beq.n	7ac8 <xTaskCreate+0x1a4>
		if (pxCurrentTCB->uxPriority < pxNewTCB->uxPriority) {
    7a48:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
    7a4c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    7a4e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    7a50:	429a      	cmp	r2, r3
    7a52:	d23d      	bcs.n	7ad0 <xTaskCreate+0x1ac>
			taskYIELD_IF_USING_PREEMPTION();
    7a54:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    7a58:	4b25      	ldr	r3, [pc, #148]	; (7af0 <xTaskCreate+0x1cc>)
    7a5a:	601a      	str	r2, [r3, #0]
    7a5c:	f3bf 8f4f 	dsb	sy
    7a60:	f3bf 8f6f 	isb	sy
		xReturn = pdPASS;
    7a64:	2001      	movs	r0, #1
    7a66:	e030      	b.n	7aca <xTaskCreate+0x1a6>
				vPortFree(pxStack);
    7a68:	4638      	mov	r0, r7
    7a6a:	4b22      	ldr	r3, [pc, #136]	; (7af4 <xTaskCreate+0x1d0>)
    7a6c:	4798      	blx	r3
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    7a6e:	f04f 30ff 	mov.w	r0, #4294967295
    7a72:	e02a      	b.n	7aca <xTaskCreate+0x1a6>
			pxCurrentTCB = pxNewTCB;
    7a74:	4b1b      	ldr	r3, [pc, #108]	; (7ae4 <xTaskCreate+0x1c0>)
    7a76:	f8c3 4098 	str.w	r4, [r3, #152]	; 0x98
			if (uxCurrentNumberOfTasks == (UBaseType_t)1) {
    7a7a:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
    7a7e:	2b01      	cmp	r3, #1
    7a80:	d1c3      	bne.n	7a0a <xTaskCreate+0xe6>
		vListInitialise(&(pxReadyTasksLists[uxPriority]));
    7a82:	4d18      	ldr	r5, [pc, #96]	; (7ae4 <xTaskCreate+0x1c0>)
    7a84:	f105 0028 	add.w	r0, r5, #40	; 0x28
    7a88:	4e1b      	ldr	r6, [pc, #108]	; (7af8 <xTaskCreate+0x1d4>)
    7a8a:	47b0      	blx	r6
    7a8c:	f105 003c 	add.w	r0, r5, #60	; 0x3c
    7a90:	47b0      	blx	r6
    7a92:	f105 0050 	add.w	r0, r5, #80	; 0x50
    7a96:	47b0      	blx	r6
    7a98:	f105 0064 	add.w	r0, r5, #100	; 0x64
    7a9c:	47b0      	blx	r6
    7a9e:	f105 0078 	add.w	r0, r5, #120	; 0x78
    7aa2:	47b0      	blx	r6
	vListInitialise(&xDelayedTaskList1);
    7aa4:	f105 09a4 	add.w	r9, r5, #164	; 0xa4
    7aa8:	4648      	mov	r0, r9
    7aaa:	47b0      	blx	r6
	vListInitialise(&xDelayedTaskList2);
    7aac:	f105 07b8 	add.w	r7, r5, #184	; 0xb8
    7ab0:	4638      	mov	r0, r7
    7ab2:	47b0      	blx	r6
	vListInitialise(&xPendingReadyList);
    7ab4:	f105 0014 	add.w	r0, r5, #20
    7ab8:	47b0      	blx	r6
		vListInitialise(&xSuspendedTaskList);
    7aba:	4628      	mov	r0, r5
    7abc:	47b0      	blx	r6
	pxDelayedTaskList         = &xDelayedTaskList1;
    7abe:	f8c5 908c 	str.w	r9, [r5, #140]	; 0x8c
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    7ac2:	f8c5 709c 	str.w	r7, [r5, #156]	; 0x9c
    7ac6:	e7a0      	b.n	7a0a <xTaskCreate+0xe6>
		xReturn = pdPASS;
    7ac8:	2001      	movs	r0, #1
}
    7aca:	b003      	add	sp, #12
    7acc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		xReturn = pdPASS;
    7ad0:	2001      	movs	r0, #1
	return xReturn;
    7ad2:	e7fa      	b.n	7aca <xTaskCreate+0x1a6>
    7ad4:	00006ff5 	.word	0x00006ff5
    7ad8:	000096ab 	.word	0x000096ab
    7adc:	00006ced 	.word	0x00006ced
    7ae0:	00006d45 	.word	0x00006d45
    7ae4:	200013d0 	.word	0x200013d0
    7ae8:	00006bfd 	.word	0x00006bfd
    7aec:	00006d89 	.word	0x00006d89
    7af0:	e000ed04 	.word	0xe000ed04
    7af4:	00007059 	.word	0x00007059
    7af8:	00006be1 	.word	0x00006be1
    7afc:	00006bf7 	.word	0x00006bf7

00007b00 <xTaskResumeFromISR>:
	configASSERT(xTaskToResume);
    7b00:	2800      	cmp	r0, #0
    7b02:	d039      	beq.n	7b78 <xTaskResumeFromISR+0x78>
{
    7b04:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    7b08:	4604      	mov	r4, r0
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
    7b0a:	4b24      	ldr	r3, [pc, #144]	; (7b9c <xTaskResumeFromISR+0x9c>)
    7b0c:	4798      	blx	r3
	__asm volatile("	mrs %0, basepri											\n"
    7b0e:	f3ef 8811 	mrs	r8, BASEPRI
    7b12:	f04f 0380 	mov.w	r3, #128	; 0x80
    7b16:	f383 8811 	msr	BASEPRI, r3
    7b1a:	f3bf 8f6f 	isb	sy
    7b1e:	f3bf 8f4f 	dsb	sy
		if (prvTaskIsTaskSuspended(pxTCB) != pdFALSE) {
    7b22:	4620      	mov	r0, r4
    7b24:	4b1e      	ldr	r3, [pc, #120]	; (7ba0 <xTaskResumeFromISR+0xa0>)
    7b26:	4798      	blx	r3
    7b28:	2800      	cmp	r0, #0
    7b2a:	d035      	beq.n	7b98 <xTaskResumeFromISR+0x98>
			if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    7b2c:	4b1d      	ldr	r3, [pc, #116]	; (7ba4 <xTaskResumeFromISR+0xa4>)
    7b2e:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
    7b32:	bb53      	cbnz	r3, 7b8a <xTaskResumeFromISR+0x8a>
				if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
    7b34:	4f1b      	ldr	r7, [pc, #108]	; (7ba4 <xTaskResumeFromISR+0xa4>)
    7b36:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
    7b3a:	6ae5      	ldr	r5, [r4, #44]	; 0x2c
    7b3c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    7b3e:	429d      	cmp	r5, r3
    7b40:	bf34      	ite	cc
    7b42:	2500      	movcc	r5, #0
    7b44:	2501      	movcs	r5, #1
				(void)uxListRemove(&(pxTCB->xStateListItem));
    7b46:	1d26      	adds	r6, r4, #4
    7b48:	4630      	mov	r0, r6
    7b4a:	4b17      	ldr	r3, [pc, #92]	; (7ba8 <xTaskResumeFromISR+0xa8>)
    7b4c:	4798      	blx	r3
				prvAddTaskToReadyList(pxTCB);
    7b4e:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
    7b50:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
    7b54:	4298      	cmp	r0, r3
    7b56:	bf84      	itt	hi
    7b58:	463b      	movhi	r3, r7
    7b5a:	f8c3 00d4 	strhi.w	r0, [r3, #212]	; 0xd4
    7b5e:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    7b62:	4631      	mov	r1, r6
    7b64:	4b11      	ldr	r3, [pc, #68]	; (7bac <xTaskResumeFromISR+0xac>)
    7b66:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    7b6a:	4b11      	ldr	r3, [pc, #68]	; (7bb0 <xTaskResumeFromISR+0xb0>)
    7b6c:	4798      	blx	r3
	__asm volatile("	msr basepri, %0	" ::"r"(ulNewMaskValue) : "memory");
    7b6e:	f388 8811 	msr	BASEPRI, r8
}
    7b72:	4628      	mov	r0, r5
    7b74:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	__asm volatile("	mov %0, %1												\n"
    7b78:	f04f 0380 	mov.w	r3, #128	; 0x80
    7b7c:	f383 8811 	msr	BASEPRI, r3
    7b80:	f3bf 8f6f 	isb	sy
    7b84:	f3bf 8f4f 	dsb	sy
    7b88:	e7fe      	b.n	7b88 <xTaskResumeFromISR+0x88>
				vListInsertEnd(&(xPendingReadyList), &(pxTCB->xEventListItem));
    7b8a:	f104 0118 	add.w	r1, r4, #24
    7b8e:	4809      	ldr	r0, [pc, #36]	; (7bb4 <xTaskResumeFromISR+0xb4>)
    7b90:	4b07      	ldr	r3, [pc, #28]	; (7bb0 <xTaskResumeFromISR+0xb0>)
    7b92:	4798      	blx	r3
	BaseType_t   xYieldRequired = pdFALSE;
    7b94:	2500      	movs	r5, #0
    7b96:	e7ea      	b.n	7b6e <xTaskResumeFromISR+0x6e>
    7b98:	2500      	movs	r5, #0
    7b9a:	e7e8      	b.n	7b6e <xTaskResumeFromISR+0x6e>
    7b9c:	00006f9d 	.word	0x00006f9d
    7ba0:	00007819 	.word	0x00007819
    7ba4:	200013d0 	.word	0x200013d0
    7ba8:	00006c49 	.word	0x00006c49
    7bac:	200013f8 	.word	0x200013f8
    7bb0:	00006bfd 	.word	0x00006bfd
    7bb4:	200013e4 	.word	0x200013e4

00007bb8 <vTaskStartScheduler>:
{
    7bb8:	b510      	push	{r4, lr}
    7bba:	b082      	sub	sp, #8
		xReturn = xTaskCreate(prvIdleTask,
    7bbc:	4b19      	ldr	r3, [pc, #100]	; (7c24 <vTaskStartScheduler+0x6c>)
    7bbe:	9301      	str	r3, [sp, #4]
    7bc0:	2300      	movs	r3, #0
    7bc2:	9300      	str	r3, [sp, #0]
    7bc4:	2240      	movs	r2, #64	; 0x40
    7bc6:	4918      	ldr	r1, [pc, #96]	; (7c28 <vTaskStartScheduler+0x70>)
    7bc8:	4818      	ldr	r0, [pc, #96]	; (7c2c <vTaskStartScheduler+0x74>)
    7bca:	4c19      	ldr	r4, [pc, #100]	; (7c30 <vTaskStartScheduler+0x78>)
    7bcc:	47a0      	blx	r4
		if (xReturn == pdPASS) {
    7bce:	2801      	cmp	r0, #1
    7bd0:	d004      	beq.n	7bdc <vTaskStartScheduler+0x24>
		configASSERT(xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY);
    7bd2:	f1b0 3fff 	cmp.w	r0, #4294967295
    7bd6:	d01b      	beq.n	7c10 <vTaskStartScheduler+0x58>
}
    7bd8:	b002      	add	sp, #8
    7bda:	bd10      	pop	{r4, pc}
			xReturn = xTimerCreateTimerTask();
    7bdc:	4b15      	ldr	r3, [pc, #84]	; (7c34 <vTaskStartScheduler+0x7c>)
    7bde:	4798      	blx	r3
	if (xReturn == pdPASS) {
    7be0:	2801      	cmp	r0, #1
    7be2:	d1f6      	bne.n	7bd2 <vTaskStartScheduler+0x1a>
    7be4:	f04f 0380 	mov.w	r3, #128	; 0x80
    7be8:	f383 8811 	msr	BASEPRI, r3
    7bec:	f3bf 8f6f 	isb	sy
    7bf0:	f3bf 8f4f 	dsb	sy
		xNextTaskUnblockTime = portMAX_DELAY;
    7bf4:	4b10      	ldr	r3, [pc, #64]	; (7c38 <vTaskStartScheduler+0x80>)
    7bf6:	f04f 32ff 	mov.w	r2, #4294967295
    7bfa:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
		xSchedulerRunning    = pdTRUE;
    7bfe:	2201      	movs	r2, #1
    7c00:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc
		xTickCount           = (TickType_t)0U;
    7c04:	2200      	movs	r2, #0
    7c06:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
		if (xPortStartScheduler() != pdFALSE) {
    7c0a:	4b0c      	ldr	r3, [pc, #48]	; (7c3c <vTaskStartScheduler+0x84>)
    7c0c:	4798      	blx	r3
    7c0e:	e7e3      	b.n	7bd8 <vTaskStartScheduler+0x20>
    7c10:	f04f 0380 	mov.w	r3, #128	; 0x80
    7c14:	f383 8811 	msr	BASEPRI, r3
    7c18:	f3bf 8f6f 	isb	sy
    7c1c:	f3bf 8f4f 	dsb	sy
    7c20:	e7fe      	b.n	7c20 <vTaskStartScheduler+0x68>
    7c22:	bf00      	nop
    7c24:	200014ac 	.word	0x200014ac
    7c28:	00009a64 	.word	0x00009a64
    7c2c:	00007855 	.word	0x00007855
    7c30:	00007925 	.word	0x00007925
    7c34:	00008419 	.word	0x00008419
    7c38:	200013d0 	.word	0x200013d0
    7c3c:	00006e79 	.word	0x00006e79

00007c40 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
    7c40:	4a03      	ldr	r2, [pc, #12]	; (7c50 <vTaskSuspendAll+0x10>)
    7c42:	f8d2 30d8 	ldr.w	r3, [r2, #216]	; 0xd8
    7c46:	3301      	adds	r3, #1
    7c48:	f8c2 30d8 	str.w	r3, [r2, #216]	; 0xd8
    7c4c:	4770      	bx	lr
    7c4e:	bf00      	nop
    7c50:	200013d0 	.word	0x200013d0

00007c54 <xTaskGetTickCount>:
		xTicks = xTickCount;
    7c54:	4b01      	ldr	r3, [pc, #4]	; (7c5c <xTaskGetTickCount+0x8>)
    7c56:	f8d3 0094 	ldr.w	r0, [r3, #148]	; 0x94
}
    7c5a:	4770      	bx	lr
    7c5c:	200013d0 	.word	0x200013d0

00007c60 <xTaskIncrementTick>:
{
    7c60:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    7c64:	4b44      	ldr	r3, [pc, #272]	; (7d78 <xTaskIncrementTick+0x118>)
    7c66:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
    7c6a:	2b00      	cmp	r3, #0
    7c6c:	d173      	bne.n	7d56 <xTaskIncrementTick+0xf6>
		const TickType_t xConstTickCount = xTickCount + (TickType_t)1;
    7c6e:	4b42      	ldr	r3, [pc, #264]	; (7d78 <xTaskIncrementTick+0x118>)
    7c70:	f8d3 6094 	ldr.w	r6, [r3, #148]	; 0x94
    7c74:	3601      	adds	r6, #1
		xTickCount = xConstTickCount;
    7c76:	f8c3 6094 	str.w	r6, [r3, #148]	; 0x94
		if (xConstTickCount
    7c7a:	b9e6      	cbnz	r6, 7cb6 <xTaskIncrementTick+0x56>
			taskSWITCH_DELAYED_LISTS();
    7c7c:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
    7c80:	681b      	ldr	r3, [r3, #0]
    7c82:	b143      	cbz	r3, 7c96 <xTaskIncrementTick+0x36>
    7c84:	f04f 0380 	mov.w	r3, #128	; 0x80
    7c88:	f383 8811 	msr	BASEPRI, r3
    7c8c:	f3bf 8f6f 	isb	sy
    7c90:	f3bf 8f4f 	dsb	sy
    7c94:	e7fe      	b.n	7c94 <xTaskIncrementTick+0x34>
    7c96:	4b38      	ldr	r3, [pc, #224]	; (7d78 <xTaskIncrementTick+0x118>)
    7c98:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
    7c9c:	f8d3 109c 	ldr.w	r1, [r3, #156]	; 0x9c
    7ca0:	f8c3 108c 	str.w	r1, [r3, #140]	; 0x8c
    7ca4:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
    7ca8:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
    7cac:	3201      	adds	r2, #1
    7cae:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
    7cb2:	4b32      	ldr	r3, [pc, #200]	; (7d7c <xTaskIncrementTick+0x11c>)
    7cb4:	4798      	blx	r3
		if (xConstTickCount >= xNextTaskUnblockTime) {
    7cb6:	4b30      	ldr	r3, [pc, #192]	; (7d78 <xTaskIncrementTick+0x118>)
    7cb8:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
    7cbc:	429e      	cmp	r6, r3
    7cbe:	d20d      	bcs.n	7cdc <xTaskIncrementTick+0x7c>
	BaseType_t xSwitchRequired = pdFALSE;
    7cc0:	2400      	movs	r4, #0
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[pxCurrentTCB->uxPriority])) > (UBaseType_t)1) {
    7cc2:	4b2d      	ldr	r3, [pc, #180]	; (7d78 <xTaskIncrementTick+0x118>)
    7cc4:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
    7cc8:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    7cca:	eb02 0282 	add.w	r2, r2, r2, lsl #2
    7cce:	eb03 0382 	add.w	r3, r3, r2, lsl #2
    7cd2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
				xSwitchRequired = pdTRUE;
    7cd4:	2b02      	cmp	r3, #2
    7cd6:	bf28      	it	cs
    7cd8:	2401      	movcs	r4, #1
    7cda:	e043      	b.n	7d64 <xTaskIncrementTick+0x104>
    7cdc:	2400      	movs	r4, #0
				if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
    7cde:	4d26      	ldr	r5, [pc, #152]	; (7d78 <xTaskIncrementTick+0x118>)
					(void)uxListRemove(&(pxTCB->xStateListItem));
    7ce0:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 7d84 <xTaskIncrementTick+0x124>
					prvAddTaskToReadyList(pxTCB);
    7ce4:	f105 0a28 	add.w	sl, r5, #40	; 0x28
    7ce8:	e021      	b.n	7d2e <xTaskIncrementTick+0xce>
					    = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    7cea:	f04f 32ff 	mov.w	r2, #4294967295
    7cee:	4b22      	ldr	r3, [pc, #136]	; (7d78 <xTaskIncrementTick+0x118>)
    7cf0:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
					break;
    7cf4:	e7e5      	b.n	7cc2 <xTaskIncrementTick+0x62>
						xNextTaskUnblockTime = xItemValue;
    7cf6:	4a20      	ldr	r2, [pc, #128]	; (7d78 <xTaskIncrementTick+0x118>)
    7cf8:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
						break;
    7cfc:	e7e1      	b.n	7cc2 <xTaskIncrementTick+0x62>
						(void)uxListRemove(&(pxTCB->xEventListItem));
    7cfe:	f107 0018 	add.w	r0, r7, #24
    7d02:	47c0      	blx	r8
					prvAddTaskToReadyList(pxTCB);
    7d04:	6af8      	ldr	r0, [r7, #44]	; 0x2c
    7d06:	f8d5 30d4 	ldr.w	r3, [r5, #212]	; 0xd4
    7d0a:	4298      	cmp	r0, r3
    7d0c:	bf88      	it	hi
    7d0e:	f8c5 00d4 	strhi.w	r0, [r5, #212]	; 0xd4
    7d12:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    7d16:	4649      	mov	r1, r9
    7d18:	eb0a 0080 	add.w	r0, sl, r0, lsl #2
    7d1c:	4b18      	ldr	r3, [pc, #96]	; (7d80 <xTaskIncrementTick+0x120>)
    7d1e:	4798      	blx	r3
						if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
    7d20:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
    7d24:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    7d26:	6adb      	ldr	r3, [r3, #44]	; 0x2c
							xSwitchRequired = pdTRUE;
    7d28:	429a      	cmp	r2, r3
    7d2a:	bf28      	it	cs
    7d2c:	2401      	movcs	r4, #1
				if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
    7d2e:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    7d32:	681b      	ldr	r3, [r3, #0]
    7d34:	2b00      	cmp	r3, #0
    7d36:	d0d8      	beq.n	7cea <xTaskIncrementTick+0x8a>
					pxTCB      = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
    7d38:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    7d3c:	68db      	ldr	r3, [r3, #12]
    7d3e:	68df      	ldr	r7, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE(&(pxTCB->xStateListItem));
    7d40:	687b      	ldr	r3, [r7, #4]
					if (xConstTickCount < xItemValue) {
    7d42:	429e      	cmp	r6, r3
    7d44:	d3d7      	bcc.n	7cf6 <xTaskIncrementTick+0x96>
					(void)uxListRemove(&(pxTCB->xStateListItem));
    7d46:	f107 0904 	add.w	r9, r7, #4
    7d4a:	4648      	mov	r0, r9
    7d4c:	47c0      	blx	r8
					if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL) {
    7d4e:	6abb      	ldr	r3, [r7, #40]	; 0x28
    7d50:	2b00      	cmp	r3, #0
    7d52:	d1d4      	bne.n	7cfe <xTaskIncrementTick+0x9e>
    7d54:	e7d6      	b.n	7d04 <xTaskIncrementTick+0xa4>
		++uxPendedTicks;
    7d56:	4a08      	ldr	r2, [pc, #32]	; (7d78 <xTaskIncrementTick+0x118>)
    7d58:	f8d2 30e4 	ldr.w	r3, [r2, #228]	; 0xe4
    7d5c:	3301      	adds	r3, #1
    7d5e:	f8c2 30e4 	str.w	r3, [r2, #228]	; 0xe4
	BaseType_t xSwitchRequired = pdFALSE;
    7d62:	2400      	movs	r4, #0
		if (xYieldPending != pdFALSE) {
    7d64:	4b04      	ldr	r3, [pc, #16]	; (7d78 <xTaskIncrementTick+0x118>)
    7d66:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
			xSwitchRequired = pdTRUE;
    7d6a:	2b00      	cmp	r3, #0
}
    7d6c:	bf0c      	ite	eq
    7d6e:	4620      	moveq	r0, r4
    7d70:	2001      	movne	r0, #1
    7d72:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    7d76:	bf00      	nop
    7d78:	200013d0 	.word	0x200013d0
    7d7c:	00007879 	.word	0x00007879
    7d80:	00006bfd 	.word	0x00006bfd
    7d84:	00006c49 	.word	0x00006c49

00007d88 <xTaskResumeAll>:
	configASSERT(uxSchedulerSuspended);
    7d88:	4b3a      	ldr	r3, [pc, #232]	; (7e74 <xTaskResumeAll+0xec>)
    7d8a:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
    7d8e:	b943      	cbnz	r3, 7da2 <xTaskResumeAll+0x1a>
    7d90:	f04f 0380 	mov.w	r3, #128	; 0x80
    7d94:	f383 8811 	msr	BASEPRI, r3
    7d98:	f3bf 8f6f 	isb	sy
    7d9c:	f3bf 8f4f 	dsb	sy
    7da0:	e7fe      	b.n	7da0 <xTaskResumeAll+0x18>
{
    7da2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	taskENTER_CRITICAL();
    7da6:	4b34      	ldr	r3, [pc, #208]	; (7e78 <xTaskResumeAll+0xf0>)
    7da8:	4798      	blx	r3
		--uxSchedulerSuspended;
    7daa:	4b32      	ldr	r3, [pc, #200]	; (7e74 <xTaskResumeAll+0xec>)
    7dac:	f8d3 20d8 	ldr.w	r2, [r3, #216]	; 0xd8
    7db0:	3a01      	subs	r2, #1
    7db2:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
		if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    7db6:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
    7dba:	2b00      	cmp	r3, #0
    7dbc:	d155      	bne.n	7e6a <xTaskResumeAll+0xe2>
			if (uxCurrentNumberOfTasks > (UBaseType_t)0U) {
    7dbe:	4b2d      	ldr	r3, [pc, #180]	; (7e74 <xTaskResumeAll+0xec>)
    7dc0:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
    7dc4:	b92b      	cbnz	r3, 7dd2 <xTaskResumeAll+0x4a>
	BaseType_t xAlreadyYielded = pdFALSE;
    7dc6:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
    7dc8:	4b2c      	ldr	r3, [pc, #176]	; (7e7c <xTaskResumeAll+0xf4>)
    7dca:	4798      	blx	r3
}
    7dcc:	4620      	mov	r0, r4
    7dce:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    7dd2:	2500      	movs	r5, #0
				while (listLIST_IS_EMPTY(&xPendingReadyList) == pdFALSE) {
    7dd4:	4c27      	ldr	r4, [pc, #156]	; (7e74 <xTaskResumeAll+0xec>)
					(void)uxListRemove(&(pxTCB->xEventListItem));
    7dd6:	4e2a      	ldr	r6, [pc, #168]	; (7e80 <xTaskResumeAll+0xf8>)
					prvAddTaskToReadyList(pxTCB);
    7dd8:	f104 0828 	add.w	r8, r4, #40	; 0x28
				while (listLIST_IS_EMPTY(&xPendingReadyList) == pdFALSE) {
    7ddc:	6963      	ldr	r3, [r4, #20]
    7dde:	b1fb      	cbz	r3, 7e20 <xTaskResumeAll+0x98>
					pxTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY((&xPendingReadyList));
    7de0:	6a23      	ldr	r3, [r4, #32]
    7de2:	68dd      	ldr	r5, [r3, #12]
					(void)uxListRemove(&(pxTCB->xEventListItem));
    7de4:	f105 0018 	add.w	r0, r5, #24
    7de8:	47b0      	blx	r6
					(void)uxListRemove(&(pxTCB->xStateListItem));
    7dea:	1d2f      	adds	r7, r5, #4
    7dec:	4638      	mov	r0, r7
    7dee:	47b0      	blx	r6
					prvAddTaskToReadyList(pxTCB);
    7df0:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
    7df2:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
    7df6:	4298      	cmp	r0, r3
    7df8:	bf88      	it	hi
    7dfa:	f8c4 00d4 	strhi.w	r0, [r4, #212]	; 0xd4
    7dfe:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    7e02:	4639      	mov	r1, r7
    7e04:	eb08 0080 	add.w	r0, r8, r0, lsl #2
    7e08:	4b1e      	ldr	r3, [pc, #120]	; (7e84 <xTaskResumeAll+0xfc>)
    7e0a:	4798      	blx	r3
					if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
    7e0c:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
    7e10:	6aea      	ldr	r2, [r5, #44]	; 0x2c
    7e12:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    7e14:	429a      	cmp	r2, r3
    7e16:	d3e1      	bcc.n	7ddc <xTaskResumeAll+0x54>
						xYieldPending = pdTRUE;
    7e18:	2301      	movs	r3, #1
    7e1a:	f8c4 30e8 	str.w	r3, [r4, #232]	; 0xe8
    7e1e:	e7dd      	b.n	7ddc <xTaskResumeAll+0x54>
				if (pxTCB != NULL) {
    7e20:	b10d      	cbz	r5, 7e26 <xTaskResumeAll+0x9e>
					prvResetNextTaskUnblockTime();
    7e22:	4b19      	ldr	r3, [pc, #100]	; (7e88 <xTaskResumeAll+0x100>)
    7e24:	4798      	blx	r3
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    7e26:	4b13      	ldr	r3, [pc, #76]	; (7e74 <xTaskResumeAll+0xec>)
    7e28:	f8d3 40e4 	ldr.w	r4, [r3, #228]	; 0xe4
					if (uxPendedCounts > (UBaseType_t)0U) {
    7e2c:	b17c      	cbz	r4, 7e4e <xTaskResumeAll+0xc6>
							if (xTaskIncrementTick() != pdFALSE) {
    7e2e:	4f17      	ldr	r7, [pc, #92]	; (7e8c <xTaskResumeAll+0x104>)
								xYieldPending = pdTRUE;
    7e30:	461e      	mov	r6, r3
    7e32:	2501      	movs	r5, #1
    7e34:	e001      	b.n	7e3a <xTaskResumeAll+0xb2>
						} while (uxPendedCounts > (UBaseType_t)0U);
    7e36:	3c01      	subs	r4, #1
    7e38:	d005      	beq.n	7e46 <xTaskResumeAll+0xbe>
							if (xTaskIncrementTick() != pdFALSE) {
    7e3a:	47b8      	blx	r7
    7e3c:	2800      	cmp	r0, #0
    7e3e:	d0fa      	beq.n	7e36 <xTaskResumeAll+0xae>
								xYieldPending = pdTRUE;
    7e40:	f8c6 50e8 	str.w	r5, [r6, #232]	; 0xe8
    7e44:	e7f7      	b.n	7e36 <xTaskResumeAll+0xae>
						uxPendedTicks = 0;
    7e46:	2200      	movs	r2, #0
    7e48:	4b0a      	ldr	r3, [pc, #40]	; (7e74 <xTaskResumeAll+0xec>)
    7e4a:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
				if (xYieldPending != pdFALSE) {
    7e4e:	4b09      	ldr	r3, [pc, #36]	; (7e74 <xTaskResumeAll+0xec>)
    7e50:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
    7e54:	b15b      	cbz	r3, 7e6e <xTaskResumeAll+0xe6>
					taskYIELD_IF_USING_PREEMPTION();
    7e56:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    7e5a:	4b0d      	ldr	r3, [pc, #52]	; (7e90 <xTaskResumeAll+0x108>)
    7e5c:	601a      	str	r2, [r3, #0]
    7e5e:	f3bf 8f4f 	dsb	sy
    7e62:	f3bf 8f6f 	isb	sy
						xAlreadyYielded = pdTRUE;
    7e66:	2401      	movs	r4, #1
    7e68:	e7ae      	b.n	7dc8 <xTaskResumeAll+0x40>
	BaseType_t xAlreadyYielded = pdFALSE;
    7e6a:	2400      	movs	r4, #0
    7e6c:	e7ac      	b.n	7dc8 <xTaskResumeAll+0x40>
    7e6e:	2400      	movs	r4, #0
    7e70:	e7aa      	b.n	7dc8 <xTaskResumeAll+0x40>
    7e72:	bf00      	nop
    7e74:	200013d0 	.word	0x200013d0
    7e78:	00006d45 	.word	0x00006d45
    7e7c:	00006d89 	.word	0x00006d89
    7e80:	00006c49 	.word	0x00006c49
    7e84:	00006bfd 	.word	0x00006bfd
    7e88:	00007879 	.word	0x00007879
    7e8c:	00007c61 	.word	0x00007c61
    7e90:	e000ed04 	.word	0xe000ed04

00007e94 <vTaskDelayUntil>:
{
    7e94:	b538      	push	{r3, r4, r5, lr}
	configASSERT(pxPreviousWakeTime);
    7e96:	b150      	cbz	r0, 7eae <vTaskDelayUntil+0x1a>
    7e98:	4605      	mov	r5, r0
	configASSERT((xTimeIncrement > 0U));
    7e9a:	b989      	cbnz	r1, 7ec0 <vTaskDelayUntil+0x2c>
    7e9c:	f04f 0380 	mov.w	r3, #128	; 0x80
    7ea0:	f383 8811 	msr	BASEPRI, r3
    7ea4:	f3bf 8f6f 	isb	sy
    7ea8:	f3bf 8f4f 	dsb	sy
    7eac:	e7fe      	b.n	7eac <vTaskDelayUntil+0x18>
    7eae:	f04f 0380 	mov.w	r3, #128	; 0x80
    7eb2:	f383 8811 	msr	BASEPRI, r3
    7eb6:	f3bf 8f6f 	isb	sy
    7eba:	f3bf 8f4f 	dsb	sy
    7ebe:	e7fe      	b.n	7ebe <vTaskDelayUntil+0x2a>
	configASSERT(uxSchedulerSuspended == 0);
    7ec0:	4b1a      	ldr	r3, [pc, #104]	; (7f2c <vTaskDelayUntil+0x98>)
    7ec2:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
    7ec6:	b143      	cbz	r3, 7eda <vTaskDelayUntil+0x46>
    7ec8:	f04f 0380 	mov.w	r3, #128	; 0x80
    7ecc:	f383 8811 	msr	BASEPRI, r3
    7ed0:	f3bf 8f6f 	isb	sy
    7ed4:	f3bf 8f4f 	dsb	sy
    7ed8:	e7fe      	b.n	7ed8 <vTaskDelayUntil+0x44>
    7eda:	460c      	mov	r4, r1
	vTaskSuspendAll();
    7edc:	4b14      	ldr	r3, [pc, #80]	; (7f30 <vTaskDelayUntil+0x9c>)
    7ede:	4798      	blx	r3
		const TickType_t xConstTickCount = xTickCount;
    7ee0:	4b12      	ldr	r3, [pc, #72]	; (7f2c <vTaskDelayUntil+0x98>)
    7ee2:	f8d3 0094 	ldr.w	r0, [r3, #148]	; 0x94
		xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    7ee6:	682a      	ldr	r2, [r5, #0]
    7ee8:	4414      	add	r4, r2
		if (xConstTickCount < *pxPreviousWakeTime) {
    7eea:	4290      	cmp	r0, r2
    7eec:	d214      	bcs.n	7f18 <vTaskDelayUntil+0x84>
			if ((xTimeToWake < *pxPreviousWakeTime) && (xTimeToWake > xConstTickCount)) {
    7eee:	42a2      	cmp	r2, r4
    7ef0:	d916      	bls.n	7f20 <vTaskDelayUntil+0x8c>
		*pxPreviousWakeTime = xTimeToWake;
    7ef2:	602c      	str	r4, [r5, #0]
		if (xShouldDelay != pdFALSE) {
    7ef4:	42a0      	cmp	r0, r4
    7ef6:	d203      	bcs.n	7f00 <vTaskDelayUntil+0x6c>
			prvAddCurrentTaskToDelayedList(xTimeToWake - xConstTickCount, pdFALSE);
    7ef8:	2100      	movs	r1, #0
    7efa:	1a20      	subs	r0, r4, r0
    7efc:	4b0d      	ldr	r3, [pc, #52]	; (7f34 <vTaskDelayUntil+0xa0>)
    7efe:	4798      	blx	r3
	xAlreadyYielded = xTaskResumeAll();
    7f00:	4b0d      	ldr	r3, [pc, #52]	; (7f38 <vTaskDelayUntil+0xa4>)
    7f02:	4798      	blx	r3
	if (xAlreadyYielded == pdFALSE) {
    7f04:	b980      	cbnz	r0, 7f28 <vTaskDelayUntil+0x94>
		portYIELD_WITHIN_API();
    7f06:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    7f0a:	4b0c      	ldr	r3, [pc, #48]	; (7f3c <vTaskDelayUntil+0xa8>)
    7f0c:	601a      	str	r2, [r3, #0]
    7f0e:	f3bf 8f4f 	dsb	sy
    7f12:	f3bf 8f6f 	isb	sy
}
    7f16:	bd38      	pop	{r3, r4, r5, pc}
			if ((xTimeToWake < *pxPreviousWakeTime) || (xTimeToWake > xConstTickCount)) {
    7f18:	42a2      	cmp	r2, r4
    7f1a:	d803      	bhi.n	7f24 <vTaskDelayUntil+0x90>
    7f1c:	42a0      	cmp	r0, r4
    7f1e:	d301      	bcc.n	7f24 <vTaskDelayUntil+0x90>
		*pxPreviousWakeTime = xTimeToWake;
    7f20:	602c      	str	r4, [r5, #0]
    7f22:	e7ed      	b.n	7f00 <vTaskDelayUntil+0x6c>
    7f24:	602c      	str	r4, [r5, #0]
    7f26:	e7e7      	b.n	7ef8 <vTaskDelayUntil+0x64>
    7f28:	bd38      	pop	{r3, r4, r5, pc}
    7f2a:	bf00      	nop
    7f2c:	200013d0 	.word	0x200013d0
    7f30:	00007c41 	.word	0x00007c41
    7f34:	000078a5 	.word	0x000078a5
    7f38:	00007d89 	.word	0x00007d89
    7f3c:	e000ed04 	.word	0xe000ed04

00007f40 <vTaskDelay>:
{
    7f40:	b510      	push	{r4, lr}
	if (xTicksToDelay > (TickType_t)0U) {
    7f42:	b1b0      	cbz	r0, 7f72 <vTaskDelay+0x32>
    7f44:	4604      	mov	r4, r0
		configASSERT(uxSchedulerSuspended == 0);
    7f46:	4b0f      	ldr	r3, [pc, #60]	; (7f84 <vTaskDelay+0x44>)
    7f48:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
    7f4c:	b143      	cbz	r3, 7f60 <vTaskDelay+0x20>
    7f4e:	f04f 0380 	mov.w	r3, #128	; 0x80
    7f52:	f383 8811 	msr	BASEPRI, r3
    7f56:	f3bf 8f6f 	isb	sy
    7f5a:	f3bf 8f4f 	dsb	sy
    7f5e:	e7fe      	b.n	7f5e <vTaskDelay+0x1e>
		vTaskSuspendAll();
    7f60:	4b09      	ldr	r3, [pc, #36]	; (7f88 <vTaskDelay+0x48>)
    7f62:	4798      	blx	r3
			prvAddCurrentTaskToDelayedList(xTicksToDelay, pdFALSE);
    7f64:	2100      	movs	r1, #0
    7f66:	4620      	mov	r0, r4
    7f68:	4b08      	ldr	r3, [pc, #32]	; (7f8c <vTaskDelay+0x4c>)
    7f6a:	4798      	blx	r3
		xAlreadyYielded = xTaskResumeAll();
    7f6c:	4b08      	ldr	r3, [pc, #32]	; (7f90 <vTaskDelay+0x50>)
    7f6e:	4798      	blx	r3
	if (xAlreadyYielded == pdFALSE) {
    7f70:	b938      	cbnz	r0, 7f82 <vTaskDelay+0x42>
		portYIELD_WITHIN_API();
    7f72:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    7f76:	4b07      	ldr	r3, [pc, #28]	; (7f94 <vTaskDelay+0x54>)
    7f78:	601a      	str	r2, [r3, #0]
    7f7a:	f3bf 8f4f 	dsb	sy
    7f7e:	f3bf 8f6f 	isb	sy
    7f82:	bd10      	pop	{r4, pc}
    7f84:	200013d0 	.word	0x200013d0
    7f88:	00007c41 	.word	0x00007c41
    7f8c:	000078a5 	.word	0x000078a5
    7f90:	00007d89 	.word	0x00007d89
    7f94:	e000ed04 	.word	0xe000ed04

00007f98 <vTaskSwitchContext>:
	if (uxSchedulerSuspended != (UBaseType_t)pdFALSE) {
    7f98:	4b25      	ldr	r3, [pc, #148]	; (8030 <vTaskSwitchContext+0x98>)
    7f9a:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
    7f9e:	b9fb      	cbnz	r3, 7fe0 <vTaskSwitchContext+0x48>
		xYieldPending = pdFALSE;
    7fa0:	4a23      	ldr	r2, [pc, #140]	; (8030 <vTaskSwitchContext+0x98>)
    7fa2:	2300      	movs	r3, #0
    7fa4:	f8c2 30e8 	str.w	r3, [r2, #232]	; 0xe8
		taskSELECT_HIGHEST_PRIORITY_TASK();
    7fa8:	f8d2 30d4 	ldr.w	r3, [r2, #212]	; 0xd4
    7fac:	eb03 0183 	add.w	r1, r3, r3, lsl #2
    7fb0:	eb02 0281 	add.w	r2, r2, r1, lsl #2
    7fb4:	6a92      	ldr	r2, [r2, #40]	; 0x28
    7fb6:	b9c2      	cbnz	r2, 7fea <vTaskSwitchContext+0x52>
    7fb8:	b14b      	cbz	r3, 7fce <vTaskSwitchContext+0x36>
    7fba:	491d      	ldr	r1, [pc, #116]	; (8030 <vTaskSwitchContext+0x98>)
    7fbc:	3b01      	subs	r3, #1
    7fbe:	eb03 0283 	add.w	r2, r3, r3, lsl #2
    7fc2:	eb01 0282 	add.w	r2, r1, r2, lsl #2
    7fc6:	6a92      	ldr	r2, [r2, #40]	; 0x28
    7fc8:	b97a      	cbnz	r2, 7fea <vTaskSwitchContext+0x52>
    7fca:	2b00      	cmp	r3, #0
    7fcc:	d1f6      	bne.n	7fbc <vTaskSwitchContext+0x24>
    7fce:	f04f 0380 	mov.w	r3, #128	; 0x80
    7fd2:	f383 8811 	msr	BASEPRI, r3
    7fd6:	f3bf 8f6f 	isb	sy
    7fda:	f3bf 8f4f 	dsb	sy
    7fde:	e7fe      	b.n	7fde <vTaskSwitchContext+0x46>
		xYieldPending = pdTRUE;
    7fe0:	2201      	movs	r2, #1
    7fe2:	4b13      	ldr	r3, [pc, #76]	; (8030 <vTaskSwitchContext+0x98>)
    7fe4:	f8c3 20e8 	str.w	r2, [r3, #232]	; 0xe8
    7fe8:	4770      	bx	lr
{
    7fea:	b410      	push	{r4}
		taskSELECT_HIGHEST_PRIORITY_TASK();
    7fec:	4a10      	ldr	r2, [pc, #64]	; (8030 <vTaskSwitchContext+0x98>)
    7fee:	0099      	lsls	r1, r3, #2
    7ff0:	18c8      	adds	r0, r1, r3
    7ff2:	eb02 0080 	add.w	r0, r2, r0, lsl #2
    7ff6:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
    7ff8:	6864      	ldr	r4, [r4, #4]
    7ffa:	62c4      	str	r4, [r0, #44]	; 0x2c
    7ffc:	4419      	add	r1, r3
    7ffe:	4602      	mov	r2, r0
    8000:	3230      	adds	r2, #48	; 0x30
    8002:	4294      	cmp	r4, r2
    8004:	d00d      	beq.n	8022 <vTaskSwitchContext+0x8a>
    8006:	4a0a      	ldr	r2, [pc, #40]	; (8030 <vTaskSwitchContext+0x98>)
    8008:	eb03 0183 	add.w	r1, r3, r3, lsl #2
    800c:	eb02 0181 	add.w	r1, r2, r1, lsl #2
    8010:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
    8012:	68c9      	ldr	r1, [r1, #12]
    8014:	f8c2 1098 	str.w	r1, [r2, #152]	; 0x98
    8018:	f8c2 30d4 	str.w	r3, [r2, #212]	; 0xd4
}
    801c:	f85d 4b04 	ldr.w	r4, [sp], #4
    8020:	4770      	bx	lr
		taskSELECT_HIGHEST_PRIORITY_TASK();
    8022:	6860      	ldr	r0, [r4, #4]
    8024:	4a02      	ldr	r2, [pc, #8]	; (8030 <vTaskSwitchContext+0x98>)
    8026:	eb02 0281 	add.w	r2, r2, r1, lsl #2
    802a:	62d0      	str	r0, [r2, #44]	; 0x2c
    802c:	e7eb      	b.n	8006 <vTaskSwitchContext+0x6e>
    802e:	bf00      	nop
    8030:	200013d0 	.word	0x200013d0

00008034 <vTaskSuspend>:
{
    8034:	b538      	push	{r3, r4, r5, lr}
    8036:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
    8038:	4b2b      	ldr	r3, [pc, #172]	; (80e8 <vTaskSuspend+0xb4>)
    803a:	4798      	blx	r3
		pxTCB = prvGetTCBFromHandle(xTaskToSuspend);
    803c:	b30c      	cbz	r4, 8082 <vTaskSuspend+0x4e>
		if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0) {
    803e:	1d25      	adds	r5, r4, #4
    8040:	4628      	mov	r0, r5
    8042:	4b2a      	ldr	r3, [pc, #168]	; (80ec <vTaskSuspend+0xb8>)
    8044:	4798      	blx	r3
		if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL) {
    8046:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    8048:	b11b      	cbz	r3, 8052 <vTaskSuspend+0x1e>
			(void)uxListRemove(&(pxTCB->xEventListItem));
    804a:	f104 0018 	add.w	r0, r4, #24
    804e:	4b27      	ldr	r3, [pc, #156]	; (80ec <vTaskSuspend+0xb8>)
    8050:	4798      	blx	r3
		vListInsertEnd(&xSuspendedTaskList, &(pxTCB->xStateListItem));
    8052:	4629      	mov	r1, r5
    8054:	4826      	ldr	r0, [pc, #152]	; (80f0 <vTaskSuspend+0xbc>)
    8056:	4b27      	ldr	r3, [pc, #156]	; (80f4 <vTaskSuspend+0xc0>)
    8058:	4798      	blx	r3
			if (pxTCB->ucNotifyState == taskWAITING_NOTIFICATION) {
    805a:	f894 3050 	ldrb.w	r3, [r4, #80]	; 0x50
    805e:	b2db      	uxtb	r3, r3
    8060:	2b01      	cmp	r3, #1
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    8062:	bf04      	itt	eq
    8064:	2300      	moveq	r3, #0
    8066:	f884 3050 	strbeq.w	r3, [r4, #80]	; 0x50
	taskEXIT_CRITICAL();
    806a:	4b23      	ldr	r3, [pc, #140]	; (80f8 <vTaskSuspend+0xc4>)
    806c:	4798      	blx	r3
	if (xSchedulerRunning != pdFALSE) {
    806e:	4b20      	ldr	r3, [pc, #128]	; (80f0 <vTaskSuspend+0xbc>)
    8070:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
    8074:	b94b      	cbnz	r3, 808a <vTaskSuspend+0x56>
	if (pxTCB == pxCurrentTCB) {
    8076:	4b1e      	ldr	r3, [pc, #120]	; (80f0 <vTaskSuspend+0xbc>)
    8078:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
    807c:	429c      	cmp	r4, r3
    807e:	d00b      	beq.n	8098 <vTaskSuspend+0x64>
    8080:	bd38      	pop	{r3, r4, r5, pc}
		pxTCB = prvGetTCBFromHandle(xTaskToSuspend);
    8082:	4b1b      	ldr	r3, [pc, #108]	; (80f0 <vTaskSuspend+0xbc>)
    8084:	f8d3 4098 	ldr.w	r4, [r3, #152]	; 0x98
    8088:	e7d9      	b.n	803e <vTaskSuspend+0xa>
		taskENTER_CRITICAL();
    808a:	4b17      	ldr	r3, [pc, #92]	; (80e8 <vTaskSuspend+0xb4>)
    808c:	4798      	blx	r3
			prvResetNextTaskUnblockTime();
    808e:	4b1b      	ldr	r3, [pc, #108]	; (80fc <vTaskSuspend+0xc8>)
    8090:	4798      	blx	r3
		taskEXIT_CRITICAL();
    8092:	4b19      	ldr	r3, [pc, #100]	; (80f8 <vTaskSuspend+0xc4>)
    8094:	4798      	blx	r3
    8096:	e7ee      	b.n	8076 <vTaskSuspend+0x42>
		if (xSchedulerRunning != pdFALSE) {
    8098:	4b15      	ldr	r3, [pc, #84]	; (80f0 <vTaskSuspend+0xbc>)
    809a:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
    809e:	b1ab      	cbz	r3, 80cc <vTaskSuspend+0x98>
			configASSERT(uxSchedulerSuspended == 0);
    80a0:	4b13      	ldr	r3, [pc, #76]	; (80f0 <vTaskSuspend+0xbc>)
    80a2:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
    80a6:	b143      	cbz	r3, 80ba <vTaskSuspend+0x86>
    80a8:	f04f 0380 	mov.w	r3, #128	; 0x80
    80ac:	f383 8811 	msr	BASEPRI, r3
    80b0:	f3bf 8f6f 	isb	sy
    80b4:	f3bf 8f4f 	dsb	sy
    80b8:	e7fe      	b.n	80b8 <vTaskSuspend+0x84>
			portYIELD_WITHIN_API();
    80ba:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    80be:	4b10      	ldr	r3, [pc, #64]	; (8100 <vTaskSuspend+0xcc>)
    80c0:	601a      	str	r2, [r3, #0]
    80c2:	f3bf 8f4f 	dsb	sy
    80c6:	f3bf 8f6f 	isb	sy
    80ca:	bd38      	pop	{r3, r4, r5, pc}
			if (listCURRENT_LIST_LENGTH(&xSuspendedTaskList) == uxCurrentNumberOfTasks) {
    80cc:	4b08      	ldr	r3, [pc, #32]	; (80f0 <vTaskSuspend+0xbc>)
    80ce:	681a      	ldr	r2, [r3, #0]
    80d0:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
    80d4:	429a      	cmp	r2, r3
    80d6:	d104      	bne.n	80e2 <vTaskSuspend+0xae>
				pxCurrentTCB = NULL;
    80d8:	2200      	movs	r2, #0
    80da:	4b05      	ldr	r3, [pc, #20]	; (80f0 <vTaskSuspend+0xbc>)
    80dc:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
    80e0:	bd38      	pop	{r3, r4, r5, pc}
				vTaskSwitchContext();
    80e2:	4b08      	ldr	r3, [pc, #32]	; (8104 <vTaskSuspend+0xd0>)
    80e4:	4798      	blx	r3
}
    80e6:	e7cb      	b.n	8080 <vTaskSuspend+0x4c>
    80e8:	00006d45 	.word	0x00006d45
    80ec:	00006c49 	.word	0x00006c49
    80f0:	200013d0 	.word	0x200013d0
    80f4:	00006bfd 	.word	0x00006bfd
    80f8:	00006d89 	.word	0x00006d89
    80fc:	00007879 	.word	0x00007879
    8100:	e000ed04 	.word	0xe000ed04
    8104:	00007f99 	.word	0x00007f99

00008108 <vTaskPlaceOnEventList>:
	configASSERT(pxEventList);
    8108:	b940      	cbnz	r0, 811c <vTaskPlaceOnEventList+0x14>
    810a:	f04f 0380 	mov.w	r3, #128	; 0x80
    810e:	f383 8811 	msr	BASEPRI, r3
    8112:	f3bf 8f6f 	isb	sy
    8116:	f3bf 8f4f 	dsb	sy
    811a:	e7fe      	b.n	811a <vTaskPlaceOnEventList+0x12>
{
    811c:	b510      	push	{r4, lr}
    811e:	460c      	mov	r4, r1
	vListInsert(pxEventList, &(pxCurrentTCB->xEventListItem));
    8120:	4b05      	ldr	r3, [pc, #20]	; (8138 <vTaskPlaceOnEventList+0x30>)
    8122:	f8d3 1098 	ldr.w	r1, [r3, #152]	; 0x98
    8126:	3118      	adds	r1, #24
    8128:	4b04      	ldr	r3, [pc, #16]	; (813c <vTaskPlaceOnEventList+0x34>)
    812a:	4798      	blx	r3
	prvAddCurrentTaskToDelayedList(xTicksToWait, pdTRUE);
    812c:	2101      	movs	r1, #1
    812e:	4620      	mov	r0, r4
    8130:	4b03      	ldr	r3, [pc, #12]	; (8140 <vTaskPlaceOnEventList+0x38>)
    8132:	4798      	blx	r3
    8134:	bd10      	pop	{r4, pc}
    8136:	bf00      	nop
    8138:	200013d0 	.word	0x200013d0
    813c:	00006c15 	.word	0x00006c15
    8140:	000078a5 	.word	0x000078a5

00008144 <vTaskPlaceOnEventListRestricted>:
{
    8144:	b538      	push	{r3, r4, r5, lr}
	configASSERT(pxEventList);
    8146:	b180      	cbz	r0, 816a <vTaskPlaceOnEventListRestricted+0x26>
    8148:	4614      	mov	r4, r2
    814a:	460d      	mov	r5, r1
	vListInsertEnd(pxEventList, &(pxCurrentTCB->xEventListItem));
    814c:	4b0b      	ldr	r3, [pc, #44]	; (817c <vTaskPlaceOnEventListRestricted+0x38>)
    814e:	f8d3 1098 	ldr.w	r1, [r3, #152]	; 0x98
    8152:	3118      	adds	r1, #24
    8154:	4b0a      	ldr	r3, [pc, #40]	; (8180 <vTaskPlaceOnEventListRestricted+0x3c>)
    8156:	4798      	blx	r3
		xTicksToWait = portMAX_DELAY;
    8158:	2c00      	cmp	r4, #0
	prvAddCurrentTaskToDelayedList(xTicksToWait, xWaitIndefinitely);
    815a:	4621      	mov	r1, r4
    815c:	bf0c      	ite	eq
    815e:	4628      	moveq	r0, r5
    8160:	f04f 30ff 	movne.w	r0, #4294967295
    8164:	4b07      	ldr	r3, [pc, #28]	; (8184 <vTaskPlaceOnEventListRestricted+0x40>)
    8166:	4798      	blx	r3
    8168:	bd38      	pop	{r3, r4, r5, pc}
    816a:	f04f 0380 	mov.w	r3, #128	; 0x80
    816e:	f383 8811 	msr	BASEPRI, r3
    8172:	f3bf 8f6f 	isb	sy
    8176:	f3bf 8f4f 	dsb	sy
    817a:	e7fe      	b.n	817a <vTaskPlaceOnEventListRestricted+0x36>
    817c:	200013d0 	.word	0x200013d0
    8180:	00006bfd 	.word	0x00006bfd
    8184:	000078a5 	.word	0x000078a5

00008188 <xTaskRemoveFromEventList>:
{
    8188:	b538      	push	{r3, r4, r5, lr}
	pxUnblockedTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxEventList);
    818a:	68c3      	ldr	r3, [r0, #12]
    818c:	68dc      	ldr	r4, [r3, #12]
	configASSERT(pxUnblockedTCB);
    818e:	2c00      	cmp	r4, #0
    8190:	d02a      	beq.n	81e8 <xTaskRemoveFromEventList+0x60>
	(void)uxListRemove(&(pxUnblockedTCB->xEventListItem));
    8192:	f104 0518 	add.w	r5, r4, #24
    8196:	4628      	mov	r0, r5
    8198:	4b1a      	ldr	r3, [pc, #104]	; (8204 <xTaskRemoveFromEventList+0x7c>)
    819a:	4798      	blx	r3
	if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    819c:	4b1a      	ldr	r3, [pc, #104]	; (8208 <xTaskRemoveFromEventList+0x80>)
    819e:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
    81a2:	bb53      	cbnz	r3, 81fa <xTaskRemoveFromEventList+0x72>
		(void)uxListRemove(&(pxUnblockedTCB->xStateListItem));
    81a4:	1d25      	adds	r5, r4, #4
    81a6:	4628      	mov	r0, r5
    81a8:	4b16      	ldr	r3, [pc, #88]	; (8204 <xTaskRemoveFromEventList+0x7c>)
    81aa:	4798      	blx	r3
		prvAddTaskToReadyList(pxUnblockedTCB);
    81ac:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
    81ae:	4b16      	ldr	r3, [pc, #88]	; (8208 <xTaskRemoveFromEventList+0x80>)
    81b0:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
    81b4:	4298      	cmp	r0, r3
    81b6:	bf84      	itt	hi
    81b8:	4b13      	ldrhi	r3, [pc, #76]	; (8208 <xTaskRemoveFromEventList+0x80>)
    81ba:	f8c3 00d4 	strhi.w	r0, [r3, #212]	; 0xd4
    81be:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    81c2:	4629      	mov	r1, r5
    81c4:	4b11      	ldr	r3, [pc, #68]	; (820c <xTaskRemoveFromEventList+0x84>)
    81c6:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    81ca:	4b11      	ldr	r3, [pc, #68]	; (8210 <xTaskRemoveFromEventList+0x88>)
    81cc:	4798      	blx	r3
	if (pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority) {
    81ce:	4b0e      	ldr	r3, [pc, #56]	; (8208 <xTaskRemoveFromEventList+0x80>)
    81d0:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
    81d4:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    81d6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    81d8:	429a      	cmp	r2, r3
		xYieldPending = pdTRUE;
    81da:	bf83      	ittte	hi
    81dc:	2001      	movhi	r0, #1
    81de:	4b0a      	ldrhi	r3, [pc, #40]	; (8208 <xTaskRemoveFromEventList+0x80>)
    81e0:	f8c3 00e8 	strhi.w	r0, [r3, #232]	; 0xe8
		xReturn = pdFALSE;
    81e4:	2000      	movls	r0, #0
}
    81e6:	bd38      	pop	{r3, r4, r5, pc}
    81e8:	f04f 0380 	mov.w	r3, #128	; 0x80
    81ec:	f383 8811 	msr	BASEPRI, r3
    81f0:	f3bf 8f6f 	isb	sy
    81f4:	f3bf 8f4f 	dsb	sy
    81f8:	e7fe      	b.n	81f8 <xTaskRemoveFromEventList+0x70>
		vListInsertEnd(&(xPendingReadyList), &(pxUnblockedTCB->xEventListItem));
    81fa:	4629      	mov	r1, r5
    81fc:	4805      	ldr	r0, [pc, #20]	; (8214 <xTaskRemoveFromEventList+0x8c>)
    81fe:	4b04      	ldr	r3, [pc, #16]	; (8210 <xTaskRemoveFromEventList+0x88>)
    8200:	4798      	blx	r3
    8202:	e7e4      	b.n	81ce <xTaskRemoveFromEventList+0x46>
    8204:	00006c49 	.word	0x00006c49
    8208:	200013d0 	.word	0x200013d0
    820c:	200013f8 	.word	0x200013f8
    8210:	00006bfd 	.word	0x00006bfd
    8214:	200013e4 	.word	0x200013e4

00008218 <vTaskInternalSetTimeOutState>:
	pxTimeOut->xOverflowCount  = xNumOfOverflows;
    8218:	4b03      	ldr	r3, [pc, #12]	; (8228 <vTaskInternalSetTimeOutState+0x10>)
    821a:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
    821e:	6002      	str	r2, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
    8220:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
    8224:	6043      	str	r3, [r0, #4]
    8226:	4770      	bx	lr
    8228:	200013d0 	.word	0x200013d0

0000822c <xTaskCheckForTimeOut>:
	configASSERT(pxTimeOut);
    822c:	b1f8      	cbz	r0, 826e <xTaskCheckForTimeOut+0x42>
{
    822e:	b570      	push	{r4, r5, r6, lr}
    8230:	4605      	mov	r5, r0
	configASSERT(pxTicksToWait);
    8232:	b329      	cbz	r1, 8280 <xTaskCheckForTimeOut+0x54>
    8234:	460c      	mov	r4, r1
	taskENTER_CRITICAL();
    8236:	4b1c      	ldr	r3, [pc, #112]	; (82a8 <xTaskCheckForTimeOut+0x7c>)
    8238:	4798      	blx	r3
		const TickType_t xConstTickCount = xTickCount;
    823a:	4b1c      	ldr	r3, [pc, #112]	; (82ac <xTaskCheckForTimeOut+0x80>)
    823c:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
		const TickType_t xElapsedTime    = xConstTickCount - pxTimeOut->xTimeOnEntering;
    8240:	6869      	ldr	r1, [r5, #4]
		    if (*pxTicksToWait == portMAX_DELAY) {
    8242:	6823      	ldr	r3, [r4, #0]
    8244:	f1b3 3fff 	cmp.w	r3, #4294967295
    8248:	d02a      	beq.n	82a0 <xTaskCheckForTimeOut+0x74>
		    if ((xNumOfOverflows != pxTimeOut->xOverflowCount)
    824a:	4818      	ldr	r0, [pc, #96]	; (82ac <xTaskCheckForTimeOut+0x80>)
    824c:	f8d0 00e0 	ldr.w	r0, [r0, #224]	; 0xe0
    8250:	682e      	ldr	r6, [r5, #0]
    8252:	4286      	cmp	r6, r0
    8254:	d001      	beq.n	825a <xTaskCheckForTimeOut+0x2e>
		        && (xConstTickCount >= pxTimeOut->xTimeOnEntering)) /*lint !e525 Indentation preferred as is to make
    8256:	428a      	cmp	r2, r1
    8258:	d224      	bcs.n	82a4 <xTaskCheckForTimeOut+0x78>
		const TickType_t xElapsedTime    = xConstTickCount - pxTimeOut->xTimeOnEntering;
    825a:	1a52      	subs	r2, r2, r1
		} else if (xElapsedTime < *pxTicksToWait) /*lint !e961 Explicit casting is only redundant with some compilers,
    825c:	429a      	cmp	r2, r3
    825e:	d318      	bcc.n	8292 <xTaskCheckForTimeOut+0x66>
			*pxTicksToWait = 0;
    8260:	2300      	movs	r3, #0
    8262:	6023      	str	r3, [r4, #0]
			xReturn        = pdTRUE;
    8264:	2401      	movs	r4, #1
	taskEXIT_CRITICAL();
    8266:	4b12      	ldr	r3, [pc, #72]	; (82b0 <xTaskCheckForTimeOut+0x84>)
    8268:	4798      	blx	r3
}
    826a:	4620      	mov	r0, r4
    826c:	bd70      	pop	{r4, r5, r6, pc}
    826e:	f04f 0380 	mov.w	r3, #128	; 0x80
    8272:	f383 8811 	msr	BASEPRI, r3
    8276:	f3bf 8f6f 	isb	sy
    827a:	f3bf 8f4f 	dsb	sy
    827e:	e7fe      	b.n	827e <xTaskCheckForTimeOut+0x52>
    8280:	f04f 0380 	mov.w	r3, #128	; 0x80
    8284:	f383 8811 	msr	BASEPRI, r3
    8288:	f3bf 8f6f 	isb	sy
    828c:	f3bf 8f4f 	dsb	sy
    8290:	e7fe      	b.n	8290 <xTaskCheckForTimeOut+0x64>
			*pxTicksToWait -= xElapsedTime;
    8292:	1a9b      	subs	r3, r3, r2
    8294:	6023      	str	r3, [r4, #0]
			vTaskInternalSetTimeOutState(pxTimeOut);
    8296:	4628      	mov	r0, r5
    8298:	4b06      	ldr	r3, [pc, #24]	; (82b4 <xTaskCheckForTimeOut+0x88>)
    829a:	4798      	blx	r3
			xReturn = pdFALSE;
    829c:	2400      	movs	r4, #0
    829e:	e7e2      	b.n	8266 <xTaskCheckForTimeOut+0x3a>
			xReturn = pdFALSE;
    82a0:	2400      	movs	r4, #0
    82a2:	e7e0      	b.n	8266 <xTaskCheckForTimeOut+0x3a>
			xReturn = pdTRUE;
    82a4:	2401      	movs	r4, #1
    82a6:	e7de      	b.n	8266 <xTaskCheckForTimeOut+0x3a>
    82a8:	00006d45 	.word	0x00006d45
    82ac:	200013d0 	.word	0x200013d0
    82b0:	00006d89 	.word	0x00006d89
    82b4:	00008219 	.word	0x00008219

000082b8 <vTaskMissedYield>:
	xYieldPending = pdTRUE;
    82b8:	2201      	movs	r2, #1
    82ba:	4b02      	ldr	r3, [pc, #8]	; (82c4 <vTaskMissedYield+0xc>)
    82bc:	f8c3 20e8 	str.w	r2, [r3, #232]	; 0xe8
    82c0:	4770      	bx	lr
    82c2:	bf00      	nop
    82c4:	200013d0 	.word	0x200013d0

000082c8 <xTaskGetSchedulerState>:
	if (xSchedulerRunning == pdFALSE) {
    82c8:	4b06      	ldr	r3, [pc, #24]	; (82e4 <xTaskGetSchedulerState+0x1c>)
    82ca:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
    82ce:	b13b      	cbz	r3, 82e0 <xTaskGetSchedulerState+0x18>
		if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    82d0:	4b04      	ldr	r3, [pc, #16]	; (82e4 <xTaskGetSchedulerState+0x1c>)
    82d2:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
			xReturn = taskSCHEDULER_SUSPENDED;
    82d6:	2b00      	cmp	r3, #0
    82d8:	bf0c      	ite	eq
    82da:	2002      	moveq	r0, #2
    82dc:	2000      	movne	r0, #0
    82de:	4770      	bx	lr
		xReturn = taskSCHEDULER_NOT_STARTED;
    82e0:	2001      	movs	r0, #1
}
    82e2:	4770      	bx	lr
    82e4:	200013d0 	.word	0x200013d0

000082e8 <xTaskPriorityDisinherit>:
	if (pxMutexHolder != NULL) {
    82e8:	2800      	cmp	r0, #0
    82ea:	d03c      	beq.n	8366 <xTaskPriorityDisinherit+0x7e>
{
    82ec:	b538      	push	{r3, r4, r5, lr}
    82ee:	4604      	mov	r4, r0
		configASSERT(pxTCB == pxCurrentTCB);
    82f0:	4a20      	ldr	r2, [pc, #128]	; (8374 <xTaskPriorityDisinherit+0x8c>)
    82f2:	f8d2 2098 	ldr.w	r2, [r2, #152]	; 0x98
    82f6:	4290      	cmp	r0, r2
    82f8:	d008      	beq.n	830c <xTaskPriorityDisinherit+0x24>
    82fa:	f04f 0380 	mov.w	r3, #128	; 0x80
    82fe:	f383 8811 	msr	BASEPRI, r3
    8302:	f3bf 8f6f 	isb	sy
    8306:	f3bf 8f4f 	dsb	sy
    830a:	e7fe      	b.n	830a <xTaskPriorityDisinherit+0x22>
		configASSERT(pxTCB->uxMutexesHeld);
    830c:	6c82      	ldr	r2, [r0, #72]	; 0x48
    830e:	b942      	cbnz	r2, 8322 <xTaskPriorityDisinherit+0x3a>
    8310:	f04f 0380 	mov.w	r3, #128	; 0x80
    8314:	f383 8811 	msr	BASEPRI, r3
    8318:	f3bf 8f6f 	isb	sy
    831c:	f3bf 8f4f 	dsb	sy
    8320:	e7fe      	b.n	8320 <xTaskPriorityDisinherit+0x38>
		(pxTCB->uxMutexesHeld)--;
    8322:	3a01      	subs	r2, #1
    8324:	6482      	str	r2, [r0, #72]	; 0x48
		if (pxTCB->uxPriority != pxTCB->uxBasePriority) {
    8326:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
    8328:	6c61      	ldr	r1, [r4, #68]	; 0x44
    832a:	4288      	cmp	r0, r1
    832c:	d01d      	beq.n	836a <xTaskPriorityDisinherit+0x82>
			if (pxTCB->uxMutexesHeld == (UBaseType_t)0) {
    832e:	b9f2      	cbnz	r2, 836e <xTaskPriorityDisinherit+0x86>
				if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0) {
    8330:	1d25      	adds	r5, r4, #4
    8332:	4628      	mov	r0, r5
    8334:	4b10      	ldr	r3, [pc, #64]	; (8378 <xTaskPriorityDisinherit+0x90>)
    8336:	4798      	blx	r3
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    8338:	6c60      	ldr	r0, [r4, #68]	; 0x44
    833a:	62e0      	str	r0, [r4, #44]	; 0x2c
				listSET_LIST_ITEM_VALUE(
    833c:	f1c0 0305 	rsb	r3, r0, #5
    8340:	61a3      	str	r3, [r4, #24]
				prvAddTaskToReadyList(pxTCB);
    8342:	4b0c      	ldr	r3, [pc, #48]	; (8374 <xTaskPriorityDisinherit+0x8c>)
    8344:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
    8348:	4298      	cmp	r0, r3
    834a:	bf84      	itt	hi
    834c:	4b09      	ldrhi	r3, [pc, #36]	; (8374 <xTaskPriorityDisinherit+0x8c>)
    834e:	f8c3 00d4 	strhi.w	r0, [r3, #212]	; 0xd4
    8352:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    8356:	4629      	mov	r1, r5
    8358:	4b08      	ldr	r3, [pc, #32]	; (837c <xTaskPriorityDisinherit+0x94>)
    835a:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    835e:	4b08      	ldr	r3, [pc, #32]	; (8380 <xTaskPriorityDisinherit+0x98>)
    8360:	4798      	blx	r3
				xReturn = pdTRUE;
    8362:	2001      	movs	r0, #1
    8364:	bd38      	pop	{r3, r4, r5, pc}
	BaseType_t   xReturn = pdFALSE;
    8366:	2000      	movs	r0, #0
    8368:	4770      	bx	lr
    836a:	2000      	movs	r0, #0
    836c:	bd38      	pop	{r3, r4, r5, pc}
    836e:	2000      	movs	r0, #0
}
    8370:	bd38      	pop	{r3, r4, r5, pc}
    8372:	bf00      	nop
    8374:	200013d0 	.word	0x200013d0
    8378:	00006c49 	.word	0x00006c49
    837c:	200013f8 	.word	0x200013f8
    8380:	00006bfd 	.word	0x00006bfd

00008384 <prvInsertTimerInActiveList>:
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList(Timer_t *const pxTimer, const TickType_t xNextExpiryTime,
                                             const TickType_t xTimeNow, const TickType_t xCommandTime)
{
    8384:	b508      	push	{r3, lr}
	BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE(&(pxTimer->xTimerListItem), xNextExpiryTime);
    8386:	6041      	str	r1, [r0, #4]
	listSET_LIST_ITEM_OWNER(&(pxTimer->xTimerListItem), pxTimer);
    8388:	6100      	str	r0, [r0, #16]

	if (xNextExpiryTime <= xTimeNow) {
    838a:	4291      	cmp	r1, r2
    838c:	d80c      	bhi.n	83a8 <prvInsertTimerInActiveList+0x24>
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if (((TickType_t)(xTimeNow - xCommandTime))
    838e:	1ad2      	subs	r2, r2, r3
    8390:	6983      	ldr	r3, [r0, #24]
    8392:	429a      	cmp	r2, r3
    8394:	d301      	bcc.n	839a <prvInsertTimerInActiveList+0x16>
		    >= pxTimer->xTimerPeriodInTicks) /*lint !e961 MISRA exception as the casts are only redundant for some
		                                        ports. */
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
    8396:	2001      	movs	r0, #1
    8398:	bd08      	pop	{r3, pc}
		} else {
			vListInsert(pxOverflowTimerList, &(pxTimer->xTimerListItem));
    839a:	1d01      	adds	r1, r0, #4
    839c:	4b09      	ldr	r3, [pc, #36]	; (83c4 <prvInsertTimerInActiveList+0x40>)
    839e:	6818      	ldr	r0, [r3, #0]
    83a0:	4b09      	ldr	r3, [pc, #36]	; (83c8 <prvInsertTimerInActiveList+0x44>)
    83a2:	4798      	blx	r3
	BaseType_t xProcessTimerNow = pdFALSE;
    83a4:	2000      	movs	r0, #0
    83a6:	bd08      	pop	{r3, pc}
		}
	} else {
		if ((xTimeNow < xCommandTime) && (xNextExpiryTime >= xCommandTime)) {
    83a8:	429a      	cmp	r2, r3
    83aa:	d201      	bcs.n	83b0 <prvInsertTimerInActiveList+0x2c>
    83ac:	4299      	cmp	r1, r3
    83ae:	d206      	bcs.n	83be <prvInsertTimerInActiveList+0x3a>
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
		} else {
			vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
    83b0:	1d01      	adds	r1, r0, #4
    83b2:	4b04      	ldr	r3, [pc, #16]	; (83c4 <prvInsertTimerInActiveList+0x40>)
    83b4:	6858      	ldr	r0, [r3, #4]
    83b6:	4b04      	ldr	r3, [pc, #16]	; (83c8 <prvInsertTimerInActiveList+0x44>)
    83b8:	4798      	blx	r3
	BaseType_t xProcessTimerNow = pdFALSE;
    83ba:	2000      	movs	r0, #0
    83bc:	bd08      	pop	{r3, pc}
			xProcessTimerNow = pdTRUE;
    83be:	2001      	movs	r0, #1
		}
	}

	return xProcessTimerNow;
}
    83c0:	bd08      	pop	{r3, pc}
    83c2:	bf00      	nop
    83c4:	200014bc 	.word	0x200014bc
    83c8:	00006c15 	.word	0x00006c15

000083cc <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue(void)
{
    83cc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
    83ce:	4b0d      	ldr	r3, [pc, #52]	; (8404 <prvCheckForValidListAndQueue+0x38>)
    83d0:	4798      	blx	r3
	{
		if (xTimerQueue == NULL) {
    83d2:	4b0d      	ldr	r3, [pc, #52]	; (8408 <prvCheckForValidListAndQueue+0x3c>)
    83d4:	689b      	ldr	r3, [r3, #8]
    83d6:	b113      	cbz	r3, 83de <prvCheckForValidListAndQueue+0x12>
#endif /* configQUEUE_REGISTRY_SIZE */
		} else {
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    83d8:	4b0c      	ldr	r3, [pc, #48]	; (840c <prvCheckForValidListAndQueue+0x40>)
    83da:	4798      	blx	r3
    83dc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			vListInitialise(&xActiveTimerList1);
    83de:	4c0a      	ldr	r4, [pc, #40]	; (8408 <prvCheckForValidListAndQueue+0x3c>)
    83e0:	f104 060c 	add.w	r6, r4, #12
    83e4:	4630      	mov	r0, r6
    83e6:	4f0a      	ldr	r7, [pc, #40]	; (8410 <prvCheckForValidListAndQueue+0x44>)
    83e8:	47b8      	blx	r7
			vListInitialise(&xActiveTimerList2);
    83ea:	f104 0520 	add.w	r5, r4, #32
    83ee:	4628      	mov	r0, r5
    83f0:	47b8      	blx	r7
			pxCurrentTimerList  = &xActiveTimerList1;
    83f2:	6066      	str	r6, [r4, #4]
			pxOverflowTimerList = &xActiveTimerList2;
    83f4:	6025      	str	r5, [r4, #0]
				xTimerQueue = xQueueCreate((UBaseType_t)configTIMER_QUEUE_LENGTH, sizeof(DaemonTaskMessage_t));
    83f6:	2200      	movs	r2, #0
    83f8:	210c      	movs	r1, #12
    83fa:	2002      	movs	r0, #2
    83fc:	4b05      	ldr	r3, [pc, #20]	; (8414 <prvCheckForValidListAndQueue+0x48>)
    83fe:	4798      	blx	r3
    8400:	60a0      	str	r0, [r4, #8]
    8402:	e7e9      	b.n	83d8 <prvCheckForValidListAndQueue+0xc>
    8404:	00006d45 	.word	0x00006d45
    8408:	200014bc 	.word	0x200014bc
    840c:	00006d89 	.word	0x00006d89
    8410:	00006be1 	.word	0x00006be1
    8414:	000072f5 	.word	0x000072f5

00008418 <xTimerCreateTimerTask>:
{
    8418:	b510      	push	{r4, lr}
    841a:	b082      	sub	sp, #8
	prvCheckForValidListAndQueue();
    841c:	4b0d      	ldr	r3, [pc, #52]	; (8454 <xTimerCreateTimerTask+0x3c>)
    841e:	4798      	blx	r3
	if (xTimerQueue != NULL) {
    8420:	4b0d      	ldr	r3, [pc, #52]	; (8458 <xTimerCreateTimerTask+0x40>)
    8422:	689b      	ldr	r3, [r3, #8]
    8424:	b163      	cbz	r3, 8440 <xTimerCreateTimerTask+0x28>
			xReturn = xTaskCreate(prvTimerTask,
    8426:	4b0d      	ldr	r3, [pc, #52]	; (845c <xTimerCreateTimerTask+0x44>)
    8428:	9301      	str	r3, [sp, #4]
    842a:	2302      	movs	r3, #2
    842c:	9300      	str	r3, [sp, #0]
    842e:	2300      	movs	r3, #0
    8430:	2240      	movs	r2, #64	; 0x40
    8432:	490b      	ldr	r1, [pc, #44]	; (8460 <xTimerCreateTimerTask+0x48>)
    8434:	480b      	ldr	r0, [pc, #44]	; (8464 <xTimerCreateTimerTask+0x4c>)
    8436:	4c0c      	ldr	r4, [pc, #48]	; (8468 <xTimerCreateTimerTask+0x50>)
    8438:	47a0      	blx	r4
	configASSERT(xReturn);
    843a:	b108      	cbz	r0, 8440 <xTimerCreateTimerTask+0x28>
}
    843c:	b002      	add	sp, #8
    843e:	bd10      	pop	{r4, pc}
    8440:	f04f 0380 	mov.w	r3, #128	; 0x80
    8444:	f383 8811 	msr	BASEPRI, r3
    8448:	f3bf 8f6f 	isb	sy
    844c:	f3bf 8f4f 	dsb	sy
    8450:	e7fe      	b.n	8450 <xTimerCreateTimerTask+0x38>
    8452:	bf00      	nop
    8454:	000083cd 	.word	0x000083cd
    8458:	200014bc 	.word	0x200014bc
    845c:	200014f0 	.word	0x200014f0
    8460:	00009a7c 	.word	0x00009a7c
    8464:	00008585 	.word	0x00008585
    8468:	00007925 	.word	0x00007925

0000846c <xTimerGenericCommand>:
	configASSERT(xTimer);
    846c:	b1d8      	cbz	r0, 84a6 <xTimerGenericCommand+0x3a>
{
    846e:	b530      	push	{r4, r5, lr}
    8470:	b085      	sub	sp, #20
    8472:	4615      	mov	r5, r2
    8474:	4604      	mov	r4, r0
	if (xTimerQueue != NULL) {
    8476:	4a14      	ldr	r2, [pc, #80]	; (84c8 <xTimerGenericCommand+0x5c>)
    8478:	6890      	ldr	r0, [r2, #8]
    847a:	b310      	cbz	r0, 84c2 <xTimerGenericCommand+0x56>
    847c:	461a      	mov	r2, r3
		xMessage.xMessageID                       = xCommandID;
    847e:	9101      	str	r1, [sp, #4]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    8480:	9502      	str	r5, [sp, #8]
		xMessage.u.xTimerParameters.pxTimer       = (Timer_t *)xTimer;
    8482:	9403      	str	r4, [sp, #12]
		if (xCommandID < tmrFIRST_FROM_ISR_COMMAND) {
    8484:	2905      	cmp	r1, #5
    8486:	dc17      	bgt.n	84b8 <xTimerGenericCommand+0x4c>
			if (xTaskGetSchedulerState() == taskSCHEDULER_RUNNING) {
    8488:	4b10      	ldr	r3, [pc, #64]	; (84cc <xTimerGenericCommand+0x60>)
    848a:	4798      	blx	r3
    848c:	2802      	cmp	r0, #2
				xReturn = xQueueSendToBack(xTimerQueue, &xMessage, xTicksToWait);
    848e:	f04f 0300 	mov.w	r3, #0
    8492:	bf0c      	ite	eq
    8494:	9a08      	ldreq	r2, [sp, #32]
				xReturn = xQueueSendToBack(xTimerQueue, &xMessage, tmrNO_DELAY);
    8496:	461a      	movne	r2, r3
    8498:	a901      	add	r1, sp, #4
    849a:	480b      	ldr	r0, [pc, #44]	; (84c8 <xTimerGenericCommand+0x5c>)
    849c:	6880      	ldr	r0, [r0, #8]
    849e:	4c0c      	ldr	r4, [pc, #48]	; (84d0 <xTimerGenericCommand+0x64>)
    84a0:	47a0      	blx	r4
}
    84a2:	b005      	add	sp, #20
    84a4:	bd30      	pop	{r4, r5, pc}
    84a6:	f04f 0380 	mov.w	r3, #128	; 0x80
    84aa:	f383 8811 	msr	BASEPRI, r3
    84ae:	f3bf 8f6f 	isb	sy
    84b2:	f3bf 8f4f 	dsb	sy
    84b6:	e7fe      	b.n	84b6 <xTimerGenericCommand+0x4a>
			xReturn = xQueueSendToBackFromISR(xTimerQueue, &xMessage, pxHigherPriorityTaskWoken);
    84b8:	2300      	movs	r3, #0
    84ba:	a901      	add	r1, sp, #4
    84bc:	4c05      	ldr	r4, [pc, #20]	; (84d4 <xTimerGenericCommand+0x68>)
    84be:	47a0      	blx	r4
    84c0:	e7ef      	b.n	84a2 <xTimerGenericCommand+0x36>
	BaseType_t          xReturn = pdFAIL;
    84c2:	2000      	movs	r0, #0
	return xReturn;
    84c4:	e7ed      	b.n	84a2 <xTimerGenericCommand+0x36>
    84c6:	bf00      	nop
    84c8:	200014bc 	.word	0x200014bc
    84cc:	000082c9 	.word	0x000082c9
    84d0:	0000734d 	.word	0x0000734d
    84d4:	00007529 	.word	0x00007529

000084d8 <prvSampleTimeNow>:
{
    84d8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    84dc:	b082      	sub	sp, #8
    84de:	4680      	mov	r8, r0
	xTimeNow = xTaskGetTickCount();
    84e0:	4b23      	ldr	r3, [pc, #140]	; (8570 <prvSampleTimeNow+0x98>)
    84e2:	4798      	blx	r3
    84e4:	4607      	mov	r7, r0
	if (xTimeNow < xLastTime) {
    84e6:	4b23      	ldr	r3, [pc, #140]	; (8574 <prvSampleTimeNow+0x9c>)
    84e8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    84ea:	4298      	cmp	r0, r3
    84ec:	d319      	bcc.n	8522 <prvSampleTimeNow+0x4a>
		*pxTimerListsWereSwitched = pdFALSE;
    84ee:	2300      	movs	r3, #0
    84f0:	f8c8 3000 	str.w	r3, [r8]
	xLastTime = xTimeNow;
    84f4:	4b1f      	ldr	r3, [pc, #124]	; (8574 <prvSampleTimeNow+0x9c>)
    84f6:	639f      	str	r7, [r3, #56]	; 0x38
}
    84f8:	4638      	mov	r0, r7
    84fa:	b002      	add	sp, #8
    84fc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				    = xTimerGenericCommand(pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY);
    8500:	2100      	movs	r1, #0
    8502:	9100      	str	r1, [sp, #0]
    8504:	460b      	mov	r3, r1
    8506:	4652      	mov	r2, sl
    8508:	4620      	mov	r0, r4
    850a:	4c1b      	ldr	r4, [pc, #108]	; (8578 <prvSampleTimeNow+0xa0>)
    850c:	47a0      	blx	r4
				configASSERT(xResult);
    850e:	b950      	cbnz	r0, 8526 <prvSampleTimeNow+0x4e>
    8510:	f04f 0380 	mov.w	r3, #128	; 0x80
    8514:	f383 8811 	msr	BASEPRI, r3
    8518:	f3bf 8f6f 	isb	sy
    851c:	f3bf 8f4f 	dsb	sy
    8520:	e7fe      	b.n	8520 <prvSampleTimeNow+0x48>
	while (listLIST_IS_EMPTY(pxCurrentTimerList) == pdFALSE) {
    8522:	4d14      	ldr	r5, [pc, #80]	; (8574 <prvSampleTimeNow+0x9c>)
		(void)uxListRemove(&(pxTimer->xTimerListItem));
    8524:	4e15      	ldr	r6, [pc, #84]	; (857c <prvSampleTimeNow+0xa4>)
	while (listLIST_IS_EMPTY(pxCurrentTimerList) == pdFALSE) {
    8526:	686b      	ldr	r3, [r5, #4]
    8528:	681a      	ldr	r2, [r3, #0]
    852a:	b1c2      	cbz	r2, 855e <prvSampleTimeNow+0x86>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxCurrentTimerList);
    852c:	68db      	ldr	r3, [r3, #12]
    852e:	f8d3 a000 	ldr.w	sl, [r3]
		pxTimer = (Timer_t *)listGET_OWNER_OF_HEAD_ENTRY(pxCurrentTimerList);
    8532:	68dc      	ldr	r4, [r3, #12]
		(void)uxListRemove(&(pxTimer->xTimerListItem));
    8534:	f104 0904 	add.w	r9, r4, #4
    8538:	4648      	mov	r0, r9
    853a:	47b0      	blx	r6
		pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
    853c:	6a63      	ldr	r3, [r4, #36]	; 0x24
    853e:	4620      	mov	r0, r4
    8540:	4798      	blx	r3
		if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
    8542:	69e3      	ldr	r3, [r4, #28]
    8544:	2b01      	cmp	r3, #1
    8546:	d1ee      	bne.n	8526 <prvSampleTimeNow+0x4e>
			xReloadTime = (xNextExpireTime + pxTimer->xTimerPeriodInTicks);
    8548:	69a3      	ldr	r3, [r4, #24]
    854a:	4453      	add	r3, sl
			if (xReloadTime > xNextExpireTime) {
    854c:	459a      	cmp	sl, r3
    854e:	d2d7      	bcs.n	8500 <prvSampleTimeNow+0x28>
				listSET_LIST_ITEM_VALUE(&(pxTimer->xTimerListItem), xReloadTime);
    8550:	6063      	str	r3, [r4, #4]
				listSET_LIST_ITEM_OWNER(&(pxTimer->xTimerListItem), pxTimer);
    8552:	6124      	str	r4, [r4, #16]
				vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
    8554:	4649      	mov	r1, r9
    8556:	6868      	ldr	r0, [r5, #4]
    8558:	4b09      	ldr	r3, [pc, #36]	; (8580 <prvSampleTimeNow+0xa8>)
    855a:	4798      	blx	r3
    855c:	e7e3      	b.n	8526 <prvSampleTimeNow+0x4e>
	pxCurrentTimerList  = pxOverflowTimerList;
    855e:	4a05      	ldr	r2, [pc, #20]	; (8574 <prvSampleTimeNow+0x9c>)
    8560:	6811      	ldr	r1, [r2, #0]
    8562:	6051      	str	r1, [r2, #4]
	pxOverflowTimerList = pxTemp;
    8564:	6013      	str	r3, [r2, #0]
		*pxTimerListsWereSwitched = pdTRUE;
    8566:	2301      	movs	r3, #1
    8568:	f8c8 3000 	str.w	r3, [r8]
    856c:	e7c2      	b.n	84f4 <prvSampleTimeNow+0x1c>
    856e:	bf00      	nop
    8570:	00007c55 	.word	0x00007c55
    8574:	200014bc 	.word	0x200014bc
    8578:	0000846d 	.word	0x0000846d
    857c:	00006c49 	.word	0x00006c49
    8580:	00006c15 	.word	0x00006c15

00008584 <prvTimerTask>:
{
    8584:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    8588:	b086      	sub	sp, #24
	*pxListWasEmpty = listLIST_IS_EMPTY(pxCurrentTimerList);
    858a:	4c65      	ldr	r4, [pc, #404]	; (8720 <prvTimerTask+0x19c>)
			(void)xTaskResumeAll();
    858c:	4f65      	ldr	r7, [pc, #404]	; (8724 <prvTimerTask+0x1a0>)
					portYIELD_WITHIN_API();
    858e:	f8df 91b4 	ldr.w	r9, [pc, #436]	; 8744 <prvTimerTask+0x1c0>
	(void)uxListRemove(&(pxTimer->xTimerListItem));
    8592:	f8df 81b4 	ldr.w	r8, [pc, #436]	; 8748 <prvTimerTask+0x1c4>
	*pxListWasEmpty = listLIST_IS_EMPTY(pxCurrentTimerList);
    8596:	6863      	ldr	r3, [r4, #4]
    8598:	681a      	ldr	r2, [r3, #0]
	if (*pxListWasEmpty == pdFALSE) {
    859a:	b172      	cbz	r2, 85ba <prvTimerTask+0x36>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxCurrentTimerList);
    859c:	68db      	ldr	r3, [r3, #12]
    859e:	681d      	ldr	r5, [r3, #0]
	vTaskSuspendAll();
    85a0:	4b61      	ldr	r3, [pc, #388]	; (8728 <prvTimerTask+0x1a4>)
    85a2:	4798      	blx	r3
		xTimeNow = prvSampleTimeNow(&xTimerListsWereSwitched);
    85a4:	a803      	add	r0, sp, #12
    85a6:	4b61      	ldr	r3, [pc, #388]	; (872c <prvTimerTask+0x1a8>)
    85a8:	4798      	blx	r3
    85aa:	4606      	mov	r6, r0
		if (xTimerListsWereSwitched == pdFALSE) {
    85ac:	9b03      	ldr	r3, [sp, #12]
    85ae:	2b00      	cmp	r3, #0
    85b0:	d179      	bne.n	86a6 <prvTimerTask+0x122>
			if ((xListWasEmpty == pdFALSE) && (xNextExpireTime <= xTimeNow)) {
    85b2:	42a8      	cmp	r0, r5
    85b4:	d24a      	bcs.n	864c <prvTimerTask+0xc8>
    85b6:	2200      	movs	r2, #0
    85b8:	e00e      	b.n	85d8 <prvTimerTask+0x54>
	vTaskSuspendAll();
    85ba:	4b5b      	ldr	r3, [pc, #364]	; (8728 <prvTimerTask+0x1a4>)
    85bc:	4798      	blx	r3
		xTimeNow = prvSampleTimeNow(&xTimerListsWereSwitched);
    85be:	a803      	add	r0, sp, #12
    85c0:	4b5a      	ldr	r3, [pc, #360]	; (872c <prvTimerTask+0x1a8>)
    85c2:	4798      	blx	r3
    85c4:	4606      	mov	r6, r0
		if (xTimerListsWereSwitched == pdFALSE) {
    85c6:	9b03      	ldr	r3, [sp, #12]
    85c8:	2b00      	cmp	r3, #0
    85ca:	d16c      	bne.n	86a6 <prvTimerTask+0x122>
					xListWasEmpty = listLIST_IS_EMPTY(pxOverflowTimerList);
    85cc:	6823      	ldr	r3, [r4, #0]
    85ce:	681a      	ldr	r2, [r3, #0]
    85d0:	fab2 f282 	clz	r2, r2
    85d4:	0952      	lsrs	r2, r2, #5
    85d6:	2500      	movs	r5, #0
				vQueueWaitForMessageRestricted(xTimerQueue, (xNextExpireTime - xTimeNow), xListWasEmpty);
    85d8:	1ba9      	subs	r1, r5, r6
    85da:	68a0      	ldr	r0, [r4, #8]
    85dc:	4b54      	ldr	r3, [pc, #336]	; (8730 <prvTimerTask+0x1ac>)
    85de:	4798      	blx	r3
				if (xTaskResumeAll() == pdFALSE) {
    85e0:	47b8      	blx	r7
    85e2:	b938      	cbnz	r0, 85f4 <prvTimerTask+0x70>
					portYIELD_WITHIN_API();
    85e4:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    85e8:	f8c9 3000 	str.w	r3, [r9]
    85ec:	f3bf 8f4f 	dsb	sy
    85f0:	f3bf 8f6f 	isb	sy
	while (xQueueReceive(xTimerQueue, &xMessage, tmrNO_DELAY)
    85f4:	4d4f      	ldr	r5, [pc, #316]	; (8734 <prvTimerTask+0x1b0>)
    85f6:	2200      	movs	r2, #0
    85f8:	a903      	add	r1, sp, #12
    85fa:	68a0      	ldr	r0, [r4, #8]
    85fc:	47a8      	blx	r5
    85fe:	2800      	cmp	r0, #0
    8600:	d0c9      	beq.n	8596 <prvTimerTask+0x12>
		if (xMessage.xMessageID >= (BaseType_t)0) {
    8602:	9b03      	ldr	r3, [sp, #12]
    8604:	2b00      	cmp	r3, #0
    8606:	dbf6      	blt.n	85f6 <prvTimerTask+0x72>
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    8608:	9e05      	ldr	r6, [sp, #20]
			if (listIS_CONTAINED_WITHIN(NULL, &(pxTimer->xTimerListItem))
    860a:	6973      	ldr	r3, [r6, #20]
    860c:	b10b      	cbz	r3, 8612 <prvTimerTask+0x8e>
				(void)uxListRemove(&(pxTimer->xTimerListItem));
    860e:	1d30      	adds	r0, r6, #4
    8610:	47c0      	blx	r8
			xTimeNow = prvSampleTimeNow(&xTimerListsWereSwitched);
    8612:	a802      	add	r0, sp, #8
    8614:	4b45      	ldr	r3, [pc, #276]	; (872c <prvTimerTask+0x1a8>)
    8616:	4798      	blx	r3
			switch (xMessage.xMessageID) {
    8618:	9b03      	ldr	r3, [sp, #12]
    861a:	2b09      	cmp	r3, #9
    861c:	d8eb      	bhi.n	85f6 <prvTimerTask+0x72>
    861e:	a201      	add	r2, pc, #4	; (adr r2, 8624 <prvTimerTask+0xa0>)
    8620:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    8624:	000086ab 	.word	0x000086ab
    8628:	000086ab 	.word	0x000086ab
    862c:	000086ab 	.word	0x000086ab
    8630:	000085f7 	.word	0x000085f7
    8634:	000086f3 	.word	0x000086f3
    8638:	00008719 	.word	0x00008719
    863c:	000086ab 	.word	0x000086ab
    8640:	000086ab 	.word	0x000086ab
    8644:	000085f7 	.word	0x000085f7
    8648:	000086f3 	.word	0x000086f3
				(void)xTaskResumeAll();
    864c:	47b8      	blx	r7
	Timer_t *const pxTimer = (Timer_t *)listGET_OWNER_OF_HEAD_ENTRY(pxCurrentTimerList);
    864e:	6863      	ldr	r3, [r4, #4]
    8650:	68db      	ldr	r3, [r3, #12]
    8652:	f8d3 a00c 	ldr.w	sl, [r3, #12]
	(void)uxListRemove(&(pxTimer->xTimerListItem));
    8656:	f10a 0004 	add.w	r0, sl, #4
    865a:	47c0      	blx	r8
	if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
    865c:	f8da 301c 	ldr.w	r3, [sl, #28]
    8660:	2b01      	cmp	r3, #1
    8662:	d004      	beq.n	866e <prvTimerTask+0xea>
	pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
    8664:	f8da 3024 	ldr.w	r3, [sl, #36]	; 0x24
    8668:	4650      	mov	r0, sl
    866a:	4798      	blx	r3
    866c:	e7c2      	b.n	85f4 <prvTimerTask+0x70>
		if (prvInsertTimerInActiveList(
    866e:	f8da 1018 	ldr.w	r1, [sl, #24]
    8672:	462b      	mov	r3, r5
    8674:	4632      	mov	r2, r6
    8676:	4429      	add	r1, r5
    8678:	4650      	mov	r0, sl
    867a:	4e2f      	ldr	r6, [pc, #188]	; (8738 <prvTimerTask+0x1b4>)
    867c:	47b0      	blx	r6
    867e:	2800      	cmp	r0, #0
    8680:	d0f0      	beq.n	8664 <prvTimerTask+0xe0>
			xResult = xTimerGenericCommand(pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY);
    8682:	2100      	movs	r1, #0
    8684:	9100      	str	r1, [sp, #0]
    8686:	460b      	mov	r3, r1
    8688:	462a      	mov	r2, r5
    868a:	4650      	mov	r0, sl
    868c:	4d2b      	ldr	r5, [pc, #172]	; (873c <prvTimerTask+0x1b8>)
    868e:	47a8      	blx	r5
			configASSERT(xResult);
    8690:	2800      	cmp	r0, #0
    8692:	d1e7      	bne.n	8664 <prvTimerTask+0xe0>
    8694:	f04f 0380 	mov.w	r3, #128	; 0x80
    8698:	f383 8811 	msr	BASEPRI, r3
    869c:	f3bf 8f6f 	isb	sy
    86a0:	f3bf 8f4f 	dsb	sy
    86a4:	e7fe      	b.n	86a4 <prvTimerTask+0x120>
			(void)xTaskResumeAll();
    86a6:	47b8      	blx	r7
    86a8:	e7a4      	b.n	85f4 <prvTimerTask+0x70>
				                               xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks,
    86aa:	9d04      	ldr	r5, [sp, #16]
				if (prvInsertTimerInActiveList(pxTimer,
    86ac:	69b1      	ldr	r1, [r6, #24]
    86ae:	462b      	mov	r3, r5
    86b0:	4602      	mov	r2, r0
    86b2:	4429      	add	r1, r5
    86b4:	4630      	mov	r0, r6
    86b6:	4d20      	ldr	r5, [pc, #128]	; (8738 <prvTimerTask+0x1b4>)
    86b8:	47a8      	blx	r5
    86ba:	2800      	cmp	r0, #0
    86bc:	d09a      	beq.n	85f4 <prvTimerTask+0x70>
					pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
    86be:	6a73      	ldr	r3, [r6, #36]	; 0x24
    86c0:	4630      	mov	r0, r6
    86c2:	4798      	blx	r3
					if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
    86c4:	69f3      	ldr	r3, [r6, #28]
    86c6:	2b01      	cmp	r3, #1
    86c8:	d194      	bne.n	85f4 <prvTimerTask+0x70>
						xResult = xTimerGenericCommand(pxTimer,
    86ca:	69b2      	ldr	r2, [r6, #24]
    86cc:	2100      	movs	r1, #0
    86ce:	9100      	str	r1, [sp, #0]
    86d0:	460b      	mov	r3, r1
    86d2:	9804      	ldr	r0, [sp, #16]
    86d4:	4402      	add	r2, r0
    86d6:	4630      	mov	r0, r6
    86d8:	4d18      	ldr	r5, [pc, #96]	; (873c <prvTimerTask+0x1b8>)
    86da:	47a8      	blx	r5
						configASSERT(xResult);
    86dc:	2800      	cmp	r0, #0
    86de:	d189      	bne.n	85f4 <prvTimerTask+0x70>
    86e0:	f04f 0380 	mov.w	r3, #128	; 0x80
    86e4:	f383 8811 	msr	BASEPRI, r3
    86e8:	f3bf 8f6f 	isb	sy
    86ec:	f3bf 8f4f 	dsb	sy
    86f0:	e7fe      	b.n	86f0 <prvTimerTask+0x16c>
				pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    86f2:	9904      	ldr	r1, [sp, #16]
    86f4:	61b1      	str	r1, [r6, #24]
				configASSERT((pxTimer->xTimerPeriodInTicks > 0));
    86f6:	b131      	cbz	r1, 8706 <prvTimerTask+0x182>
				(void)prvInsertTimerInActiveList(
    86f8:	4603      	mov	r3, r0
    86fa:	4602      	mov	r2, r0
    86fc:	4401      	add	r1, r0
    86fe:	4630      	mov	r0, r6
    8700:	4d0d      	ldr	r5, [pc, #52]	; (8738 <prvTimerTask+0x1b4>)
    8702:	47a8      	blx	r5
    8704:	e776      	b.n	85f4 <prvTimerTask+0x70>
    8706:	f04f 0380 	mov.w	r3, #128	; 0x80
    870a:	f383 8811 	msr	BASEPRI, r3
    870e:	f3bf 8f6f 	isb	sy
    8712:	f3bf 8f4f 	dsb	sy
    8716:	e7fe      	b.n	8716 <prvTimerTask+0x192>
				vPortFree(pxTimer);
    8718:	4630      	mov	r0, r6
    871a:	4b09      	ldr	r3, [pc, #36]	; (8740 <prvTimerTask+0x1bc>)
    871c:	4798      	blx	r3
    871e:	e769      	b.n	85f4 <prvTimerTask+0x70>
    8720:	200014bc 	.word	0x200014bc
    8724:	00007d89 	.word	0x00007d89
    8728:	00007c41 	.word	0x00007c41
    872c:	000084d9 	.word	0x000084d9
    8730:	000077b9 	.word	0x000077b9
    8734:	00007631 	.word	0x00007631
    8738:	00008385 	.word	0x00008385
    873c:	0000846d 	.word	0x0000846d
    8740:	00007059 	.word	0x00007059
    8744:	e000ed04 	.word	0xe000ed04
    8748:	00006c49 	.word	0x00006c49

0000874c <cdcdf_acm_req>:
 * \param[in] ep Endpoint address.
 * \param[in] req Pointer to the request.
 * \return Operation status.
 */
static int32_t cdcdf_acm_req(uint8_t ep, struct usb_req *req, enum usb_ctrl_stage stage)
{
    874c:	b5f0      	push	{r4, r5, r6, r7, lr}
    874e:	b083      	sub	sp, #12
	if (0x01 != ((req->bmRequestType >> 5) & 0x03)) { // class request
    8750:	780b      	ldrb	r3, [r1, #0]
    8752:	f3c3 1441 	ubfx	r4, r3, #5, #2
    8756:	2c01      	cmp	r4, #1
    8758:	d15e      	bne.n	8818 <cdcdf_acm_req+0xcc>
		return ERR_NOT_FOUND;
	}
	if ((req->wIndex == _cdcdf_acm_funcd.func_iface[0]) || (req->wIndex == _cdcdf_acm_funcd.func_iface[1])) {
    875a:	888c      	ldrh	r4, [r1, #4]
    875c:	4d35      	ldr	r5, [pc, #212]	; (8834 <cdcdf_acm_req+0xe8>)
    875e:	782d      	ldrb	r5, [r5, #0]
    8760:	42a5      	cmp	r5, r4
    8762:	d003      	beq.n	876c <cdcdf_acm_req+0x20>
    8764:	4d33      	ldr	r5, [pc, #204]	; (8834 <cdcdf_acm_req+0xe8>)
    8766:	786d      	ldrb	r5, [r5, #1]
    8768:	42a5      	cmp	r5, r4
    876a:	d158      	bne.n	881e <cdcdf_acm_req+0xd2>
    876c:	4616      	mov	r6, r2
    876e:	460c      	mov	r4, r1
    8770:	4605      	mov	r5, r0
		if (req->bmRequestType & USB_EP_DIR_IN) {
    8772:	f013 0f80 	tst.w	r3, #128	; 0x80
    8776:	d10c      	bne.n	8792 <cdcdf_acm_req+0x46>
	uint16_t                   len      = req->wLength;
    8778:	88cf      	ldrh	r7, [r1, #6]
	uint8_t *                  ctrl_buf = usbdc_get_ctrl_buffer();
    877a:	4b2f      	ldr	r3, [pc, #188]	; (8838 <cdcdf_acm_req+0xec>)
    877c:	4798      	blx	r3
    877e:	4601      	mov	r1, r0
	switch (req->bRequest) {
    8780:	7863      	ldrb	r3, [r4, #1]
    8782:	2b20      	cmp	r3, #32
    8784:	d013      	beq.n	87ae <cdcdf_acm_req+0x62>
    8786:	2b22      	cmp	r3, #34	; 0x22
    8788:	d032      	beq.n	87f0 <cdcdf_acm_req+0xa4>
		return ERR_INVALID_ARG;
    878a:	f06f 000c 	mvn.w	r0, #12
			return cdcdf_acm_set_req(ep, req, stage);
		}
	} else {
		return ERR_NOT_FOUND;
	}
}
    878e:	b003      	add	sp, #12
    8790:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (USB_DATA_STAGE == stage) {
    8792:	2a01      	cmp	r2, #1
    8794:	d046      	beq.n	8824 <cdcdf_acm_req+0xd8>
	switch (req->bRequest) {
    8796:	784b      	ldrb	r3, [r1, #1]
    8798:	2b21      	cmp	r3, #33	; 0x21
    879a:	d145      	bne.n	8828 <cdcdf_acm_req+0xdc>
		if (sizeof(struct usb_cdc_line_coding) != len) {
    879c:	88cb      	ldrh	r3, [r1, #6]
    879e:	2b07      	cmp	r3, #7
    87a0:	d145      	bne.n	882e <cdcdf_acm_req+0xe2>
		return usbdc_xfer(ep, (uint8_t *)&usbd_cdc_line_coding, len, false);
    87a2:	2300      	movs	r3, #0
    87a4:	2207      	movs	r2, #7
    87a6:	4925      	ldr	r1, [pc, #148]	; (883c <cdcdf_acm_req+0xf0>)
    87a8:	4c25      	ldr	r4, [pc, #148]	; (8840 <cdcdf_acm_req+0xf4>)
    87aa:	47a0      	blx	r4
    87ac:	e7ef      	b.n	878e <cdcdf_acm_req+0x42>
		if (sizeof(struct usb_cdc_line_coding) != len) {
    87ae:	2f07      	cmp	r7, #7
    87b0:	d12b      	bne.n	880a <cdcdf_acm_req+0xbe>
		if (USB_SETUP_STAGE == stage) {
    87b2:	b1be      	cbz	r6, 87e4 <cdcdf_acm_req+0x98>
			memcpy(&line_coding_tmp, ctrl_buf, sizeof(struct usb_cdc_line_coding));
    87b4:	6800      	ldr	r0, [r0, #0]
    87b6:	9000      	str	r0, [sp, #0]
    87b8:	888a      	ldrh	r2, [r1, #4]
    87ba:	798b      	ldrb	r3, [r1, #6]
    87bc:	f8ad 2004 	strh.w	r2, [sp, #4]
    87c0:	f88d 3006 	strb.w	r3, [sp, #6]
			if ((NULL == cdcdf_acm_set_line_coding) || (true == cdcdf_acm_set_line_coding(&line_coding_tmp))) {
    87c4:	4b1b      	ldr	r3, [pc, #108]	; (8834 <cdcdf_acm_req+0xe8>)
    87c6:	691b      	ldr	r3, [r3, #16]
    87c8:	b113      	cbz	r3, 87d0 <cdcdf_acm_req+0x84>
    87ca:	4668      	mov	r0, sp
    87cc:	4798      	blx	r3
    87ce:	b1f8      	cbz	r0, 8810 <cdcdf_acm_req+0xc4>
				usbd_cdc_line_coding = line_coding_tmp;
    87d0:	4b18      	ldr	r3, [pc, #96]	; (8834 <cdcdf_acm_req+0xe8>)
    87d2:	aa02      	add	r2, sp, #8
    87d4:	e912 0003 	ldmdb	r2, {r0, r1}
    87d8:	6098      	str	r0, [r3, #8]
    87da:	8199      	strh	r1, [r3, #12]
    87dc:	0c09      	lsrs	r1, r1, #16
    87de:	7399      	strb	r1, [r3, #14]
			return ERR_NONE;
    87e0:	2000      	movs	r0, #0
    87e2:	e7d4      	b.n	878e <cdcdf_acm_req+0x42>
			return usbdc_xfer(ep, ctrl_buf, len, false);
    87e4:	2300      	movs	r3, #0
    87e6:	2207      	movs	r2, #7
    87e8:	4628      	mov	r0, r5
    87ea:	4c15      	ldr	r4, [pc, #84]	; (8840 <cdcdf_acm_req+0xf4>)
    87ec:	47a0      	blx	r4
    87ee:	e7ce      	b.n	878e <cdcdf_acm_req+0x42>
		usbdc_xfer(0, NULL, 0, 0);
    87f0:	2300      	movs	r3, #0
    87f2:	461a      	mov	r2, r3
    87f4:	4619      	mov	r1, r3
    87f6:	4618      	mov	r0, r3
    87f8:	4d11      	ldr	r5, [pc, #68]	; (8840 <cdcdf_acm_req+0xf4>)
    87fa:	47a8      	blx	r5
		if (NULL != cdcdf_acm_notify_state) {
    87fc:	4b0d      	ldr	r3, [pc, #52]	; (8834 <cdcdf_acm_req+0xe8>)
    87fe:	695b      	ldr	r3, [r3, #20]
    8800:	b143      	cbz	r3, 8814 <cdcdf_acm_req+0xc8>
			cdcdf_acm_notify_state(req->wValue);
    8802:	8860      	ldrh	r0, [r4, #2]
    8804:	4798      	blx	r3
		return ERR_NONE;
    8806:	2000      	movs	r0, #0
    8808:	e7c1      	b.n	878e <cdcdf_acm_req+0x42>
			return ERR_INVALID_DATA;
    880a:	f04f 30ff 	mov.w	r0, #4294967295
    880e:	e7be      	b.n	878e <cdcdf_acm_req+0x42>
			return ERR_NONE;
    8810:	2000      	movs	r0, #0
    8812:	e7bc      	b.n	878e <cdcdf_acm_req+0x42>
		return ERR_NONE;
    8814:	2000      	movs	r0, #0
			return cdcdf_acm_set_req(ep, req, stage);
    8816:	e7ba      	b.n	878e <cdcdf_acm_req+0x42>
		return ERR_NOT_FOUND;
    8818:	f06f 0009 	mvn.w	r0, #9
    881c:	e7b7      	b.n	878e <cdcdf_acm_req+0x42>
		return ERR_NOT_FOUND;
    881e:	f06f 0009 	mvn.w	r0, #9
    8822:	e7b4      	b.n	878e <cdcdf_acm_req+0x42>
		return ERR_NONE;
    8824:	2000      	movs	r0, #0
    8826:	e7b2      	b.n	878e <cdcdf_acm_req+0x42>
		return ERR_INVALID_ARG;
    8828:	f06f 000c 	mvn.w	r0, #12
    882c:	e7af      	b.n	878e <cdcdf_acm_req+0x42>
			return ERR_INVALID_DATA;
    882e:	f04f 30ff 	mov.w	r0, #4294967295
    8832:	e7ac      	b.n	878e <cdcdf_acm_req+0x42>
    8834:	200014f8 	.word	0x200014f8
    8838:	000090ad 	.word	0x000090ad
    883c:	20001500 	.word	0x20001500
    8840:	00008b89 	.word	0x00008b89

00008844 <cdcdf_acm_ctrl>:
{
    8844:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8848:	b083      	sub	sp, #12
    884a:	4616      	mov	r6, r2
	switch (ctrl) {
    884c:	2901      	cmp	r1, #1
    884e:	d066      	beq.n	891e <cdcdf_acm_ctrl+0xda>
    8850:	b141      	cbz	r1, 8864 <cdcdf_acm_ctrl+0x20>
		return ERR_INVALID_ARG;
    8852:	2902      	cmp	r1, #2
    8854:	bf0c      	ite	eq
    8856:	f06f 001a 	mvneq.w	r0, #26
    885a:	f06f 000c 	mvnne.w	r0, #12
}
    885e:	b003      	add	sp, #12
    8860:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	struct cdcdf_acm_func_data *func_data = (struct cdcdf_acm_func_data *)(drv->func_data);
    8864:	f8d0 a008 	ldr.w	sl, [r0, #8]
	ifc = desc->sod;
    8868:	6810      	ldr	r0, [r2, #0]
		if (NULL == ifc) {
    886a:	2800      	cmp	r0, #0
    886c:	f000 8085 	beq.w	897a <cdcdf_acm_ctrl+0x136>
    8870:	f10a 3bff 	add.w	fp, sl, #4294967295
    8874:	f10a 0301 	add.w	r3, sl, #1
    8878:	9300      	str	r3, [sp, #0]
			if (usb_d_ep_init(ep_desc.bEndpointAddress, ep_desc.bmAttributes, ep_desc.wMaxPacketSize)) {
    887a:	4f46      	ldr	r7, [pc, #280]	; (8994 <cdcdf_acm_ctrl+0x150>)
				usb_d_ep_enable(func_data->func_ep_out);
    887c:	f8df 9124 	ldr.w	r9, [pc, #292]	; 89a4 <cdcdf_acm_ctrl+0x160>
			ep        = usb_find_ep_desc(usb_desc_next(desc->sod), desc->eod);
    8880:	f8df 8124 	ldr.w	r8, [pc, #292]	; 89a8 <cdcdf_acm_ctrl+0x164>
		ifc_desc.bInterfaceNumber = ifc[2];
    8884:	7882      	ldrb	r2, [r0, #2]
		if ((CDC_CLASS_COMM == ifc_desc.bInterfaceClass) || (CDC_CLASS_DATA == ifc_desc.bInterfaceClass)) {
    8886:	7943      	ldrb	r3, [r0, #5]
    8888:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
    888c:	2b02      	cmp	r3, #2
    888e:	d002      	beq.n	8896 <cdcdf_acm_ctrl+0x52>
			return ERR_NOT_FOUND;
    8890:	f06f 0009 	mvn.w	r0, #9
    8894:	e7e3      	b.n	885e <cdcdf_acm_ctrl+0x1a>
    8896:	f10b 0b01 	add.w	fp, fp, #1
			if (func_data->func_iface[i] == ifc_desc.bInterfaceNumber) { // Initialized
    889a:	f89b 3000 	ldrb.w	r3, [fp]
    889e:	429a      	cmp	r2, r3
    88a0:	d06e      	beq.n	8980 <cdcdf_acm_ctrl+0x13c>
			} else if (func_data->func_iface[i] != 0xFF) { // Occupied
    88a2:	2bff      	cmp	r3, #255	; 0xff
    88a4:	d16f      	bne.n	8986 <cdcdf_acm_ctrl+0x142>
				func_data->func_iface[i] = ifc_desc.bInterfaceNumber;
    88a6:	f88b 2000 	strb.w	r2, [fp]
		ep = usb_find_desc(ifc, desc->eod, USB_DT_ENDPOINT);
    88aa:	2205      	movs	r2, #5
    88ac:	6871      	ldr	r1, [r6, #4]
    88ae:	4b3a      	ldr	r3, [pc, #232]	; (8998 <cdcdf_acm_ctrl+0x154>)
    88b0:	4798      	blx	r3
		while (NULL != ep) {
    88b2:	4604      	mov	r4, r0
    88b4:	b1f8      	cbz	r0, 88f6 <cdcdf_acm_ctrl+0xb2>
    88b6:	f8cd b004 	str.w	fp, [sp, #4]
			ep_desc.bEndpointAddress = ep[2];
    88ba:	78a5      	ldrb	r5, [r4, #2]
 *  \param[in] ptr Byte pointer to the address to get data
 *  \return a 16-bit word
 */
static inline uint16_t usb_get_u16(const uint8_t *ptr)
{
	return (ptr[0] + (ptr[1] << 8));
    88bc:	7963      	ldrb	r3, [r4, #5]
    88be:	7922      	ldrb	r2, [r4, #4]
    88c0:	eb02 2203 	add.w	r2, r2, r3, lsl #8
			if (usb_d_ep_init(ep_desc.bEndpointAddress, ep_desc.bmAttributes, ep_desc.wMaxPacketSize)) {
    88c4:	b292      	uxth	r2, r2
    88c6:	78e1      	ldrb	r1, [r4, #3]
    88c8:	4628      	mov	r0, r5
    88ca:	47b8      	blx	r7
    88cc:	2800      	cmp	r0, #0
    88ce:	d15d      	bne.n	898c <cdcdf_acm_ctrl+0x148>
			if (ep_desc.bEndpointAddress & USB_EP_DIR_IN) {
    88d0:	f015 0f80 	tst.w	r5, #128	; 0x80
				func_data->func_ep_in[i] = ep_desc.bEndpointAddress;
    88d4:	bf14      	ite	ne
    88d6:	f88b 5002 	strbne.w	r5, [fp, #2]
				func_data->func_ep_out = ep_desc.bEndpointAddress;
    88da:	f88a 5004 	strbeq.w	r5, [sl, #4]
				usb_d_ep_enable(func_data->func_ep_out);
    88de:	4628      	mov	r0, r5
    88e0:	47c8      	blx	r9
			desc->sod = ep;
    88e2:	6034      	str	r4, [r6, #0]
 *  \param[in] desc Byte pointer to the descriptor start address
 *  \return Byte pointer to the next descriptor
 */
static inline uint8_t *usb_desc_next(uint8_t *desc)
{
	return (desc + usb_desc_len(desc));
    88e4:	7820      	ldrb	r0, [r4, #0]
			ep        = usb_find_ep_desc(usb_desc_next(desc->sod), desc->eod);
    88e6:	6871      	ldr	r1, [r6, #4]
    88e8:	4420      	add	r0, r4
    88ea:	47c0      	blx	r8
		while (NULL != ep) {
    88ec:	4604      	mov	r4, r0
    88ee:	2800      	cmp	r0, #0
    88f0:	d1e3      	bne.n	88ba <cdcdf_acm_ctrl+0x76>
    88f2:	f8dd b004 	ldr.w	fp, [sp, #4]
		ifc = usb_find_desc(usb_desc_next(desc->sod), desc->eod, USB_DT_INTERFACE);
    88f6:	6833      	ldr	r3, [r6, #0]
    88f8:	7818      	ldrb	r0, [r3, #0]
    88fa:	2204      	movs	r2, #4
    88fc:	6871      	ldr	r1, [r6, #4]
    88fe:	4418      	add	r0, r3
    8900:	4b25      	ldr	r3, [pc, #148]	; (8998 <cdcdf_acm_ctrl+0x154>)
    8902:	4798      	blx	r3
	for (i = 0; i < 2; i++) {
    8904:	9b00      	ldr	r3, [sp, #0]
    8906:	459b      	cmp	fp, r3
    8908:	d004      	beq.n	8914 <cdcdf_acm_ctrl+0xd0>
		if (NULL == ifc) {
    890a:	2800      	cmp	r0, #0
    890c:	d1ba      	bne.n	8884 <cdcdf_acm_ctrl+0x40>
			return ERR_NOT_FOUND;
    890e:	f06f 0009 	mvn.w	r0, #9
    8912:	e7a4      	b.n	885e <cdcdf_acm_ctrl+0x1a>
	_cdcdf_acm_funcd.enabled = true;
    8914:	2201      	movs	r2, #1
    8916:	4b21      	ldr	r3, [pc, #132]	; (899c <cdcdf_acm_ctrl+0x158>)
    8918:	715a      	strb	r2, [r3, #5]
	return ERR_NONE;
    891a:	2000      	movs	r0, #0
    891c:	e79f      	b.n	885e <cdcdf_acm_ctrl+0x1a>
	struct cdcdf_acm_func_data *func_data = (struct cdcdf_acm_func_data *)(drv->func_data);
    891e:	6884      	ldr	r4, [r0, #8]
	if (desc) {
    8920:	b142      	cbz	r2, 8934 <cdcdf_acm_ctrl+0xf0>
		ifc_desc.bInterfaceClass = desc->sod[5];
    8922:	6813      	ldr	r3, [r2, #0]
		if ((ifc_desc.bInterfaceClass != CDC_CLASS_COMM) && (ifc_desc.bInterfaceClass != CDC_CLASS_DATA)) {
    8924:	795b      	ldrb	r3, [r3, #5]
    8926:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
    892a:	2b02      	cmp	r3, #2
    892c:	d002      	beq.n	8934 <cdcdf_acm_ctrl+0xf0>
			return ERR_NOT_FOUND;
    892e:	f06f 0009 	mvn.w	r0, #9
    8932:	e794      	b.n	885e <cdcdf_acm_ctrl+0x1a>
		if (func_data->func_iface[i] == 0xFF) {
    8934:	7823      	ldrb	r3, [r4, #0]
    8936:	2bff      	cmp	r3, #255	; 0xff
    8938:	d008      	beq.n	894c <cdcdf_acm_ctrl+0x108>
			func_data->func_iface[i] = 0xFF;
    893a:	23ff      	movs	r3, #255	; 0xff
    893c:	7023      	strb	r3, [r4, #0]
			if (func_data->func_ep_in[i] != 0xFF) {
    893e:	78a0      	ldrb	r0, [r4, #2]
    8940:	4298      	cmp	r0, r3
    8942:	d003      	beq.n	894c <cdcdf_acm_ctrl+0x108>
				usb_d_ep_deinit(func_data->func_ep_in[i]);
    8944:	4b16      	ldr	r3, [pc, #88]	; (89a0 <cdcdf_acm_ctrl+0x15c>)
    8946:	4798      	blx	r3
				func_data->func_ep_in[i] = 0xFF;
    8948:	23ff      	movs	r3, #255	; 0xff
    894a:	70a3      	strb	r3, [r4, #2]
		if (func_data->func_iface[i] == 0xFF) {
    894c:	7863      	ldrb	r3, [r4, #1]
    894e:	2bff      	cmp	r3, #255	; 0xff
    8950:	d008      	beq.n	8964 <cdcdf_acm_ctrl+0x120>
			func_data->func_iface[i] = 0xFF;
    8952:	23ff      	movs	r3, #255	; 0xff
    8954:	7063      	strb	r3, [r4, #1]
			if (func_data->func_ep_in[i] != 0xFF) {
    8956:	78e0      	ldrb	r0, [r4, #3]
    8958:	4298      	cmp	r0, r3
    895a:	d003      	beq.n	8964 <cdcdf_acm_ctrl+0x120>
				usb_d_ep_deinit(func_data->func_ep_in[i]);
    895c:	4b10      	ldr	r3, [pc, #64]	; (89a0 <cdcdf_acm_ctrl+0x15c>)
    895e:	4798      	blx	r3
				func_data->func_ep_in[i] = 0xFF;
    8960:	23ff      	movs	r3, #255	; 0xff
    8962:	70e3      	strb	r3, [r4, #3]
	if (func_data->func_ep_out != 0xFF) {
    8964:	7920      	ldrb	r0, [r4, #4]
    8966:	28ff      	cmp	r0, #255	; 0xff
    8968:	d003      	beq.n	8972 <cdcdf_acm_ctrl+0x12e>
		usb_d_ep_deinit(func_data->func_ep_out);
    896a:	4b0d      	ldr	r3, [pc, #52]	; (89a0 <cdcdf_acm_ctrl+0x15c>)
    896c:	4798      	blx	r3
		func_data->func_ep_out = 0xFF;
    896e:	23ff      	movs	r3, #255	; 0xff
    8970:	7123      	strb	r3, [r4, #4]
	_cdcdf_acm_funcd.enabled = false;
    8972:	2000      	movs	r0, #0
    8974:	4b09      	ldr	r3, [pc, #36]	; (899c <cdcdf_acm_ctrl+0x158>)
    8976:	7158      	strb	r0, [r3, #5]
    8978:	e771      	b.n	885e <cdcdf_acm_ctrl+0x1a>
			return ERR_NOT_FOUND;
    897a:	f06f 0009 	mvn.w	r0, #9
    897e:	e76e      	b.n	885e <cdcdf_acm_ctrl+0x1a>
				return ERR_ALREADY_INITIALIZED;
    8980:	f06f 0011 	mvn.w	r0, #17
    8984:	e76b      	b.n	885e <cdcdf_acm_ctrl+0x1a>
				return ERR_NO_RESOURCE;
    8986:	f06f 001b 	mvn.w	r0, #27
    898a:	e768      	b.n	885e <cdcdf_acm_ctrl+0x1a>
				return ERR_NOT_INITIALIZED;
    898c:	f06f 0013 	mvn.w	r0, #19
    8990:	e765      	b.n	885e <cdcdf_acm_ctrl+0x1a>
    8992:	bf00      	nop
    8994:	00002f51 	.word	0x00002f51
    8998:	000090cd 	.word	0x000090cd
    899c:	200014f8 	.word	0x200014f8
    89a0:	00002fb9 	.word	0x00002fb9
    89a4:	00002fe5 	.word	0x00002fe5
    89a8:	00009107 	.word	0x00009107

000089ac <cdcdf_acm_init>:

/**
 * \brief Initialize the USB CDC ACM Function Driver
 */
int32_t cdcdf_acm_init(void)
{
    89ac:	b508      	push	{r3, lr}
	if (usbdc_get_state() > USBD_S_POWER) {
    89ae:	4b0a      	ldr	r3, [pc, #40]	; (89d8 <cdcdf_acm_init+0x2c>)
    89b0:	4798      	blx	r3
    89b2:	2801      	cmp	r0, #1
    89b4:	d80c      	bhi.n	89d0 <cdcdf_acm_init+0x24>
		return ERR_DENIED;
	}

	_cdcdf_acm.ctrl      = cdcdf_acm_ctrl;
    89b6:	4809      	ldr	r0, [pc, #36]	; (89dc <cdcdf_acm_init+0x30>)
    89b8:	4b09      	ldr	r3, [pc, #36]	; (89e0 <cdcdf_acm_init+0x34>)
    89ba:	61c3      	str	r3, [r0, #28]
	_cdcdf_acm.func_data = &_cdcdf_acm_funcd;
    89bc:	6200      	str	r0, [r0, #32]

	usbdc_register_function(&_cdcdf_acm);
    89be:	3018      	adds	r0, #24
    89c0:	4b08      	ldr	r3, [pc, #32]	; (89e4 <cdcdf_acm_init+0x38>)
    89c2:	4798      	blx	r3
	usbdc_register_handler(USBDC_HDL_REQ, &cdcdf_acm_req_h);
    89c4:	4908      	ldr	r1, [pc, #32]	; (89e8 <cdcdf_acm_init+0x3c>)
    89c6:	2001      	movs	r0, #1
    89c8:	4b08      	ldr	r3, [pc, #32]	; (89ec <cdcdf_acm_init+0x40>)
    89ca:	4798      	blx	r3
	return ERR_NONE;
    89cc:	2000      	movs	r0, #0
    89ce:	bd08      	pop	{r3, pc}
		return ERR_DENIED;
    89d0:	f06f 0010 	mvn.w	r0, #16
}
    89d4:	bd08      	pop	{r3, pc}
    89d6:	bf00      	nop
    89d8:	000090b9 	.word	0x000090b9
    89dc:	200014f8 	.word	0x200014f8
    89e0:	00008845 	.word	0x00008845
    89e4:	00009059 	.word	0x00009059
    89e8:	20000034 	.word	0x20000034
    89ec:	00008fc5 	.word	0x00008fc5

000089f0 <usbdc_unconfig>:

/**
 * \brief Unconfig, close all interfaces
 */
static void usbdc_unconfig(void)
{
    89f0:	b570      	push	{r4, r5, r6, lr}
	struct usbdf_driver *func = (struct usbdf_driver *)usbdc.func_list.head;
    89f2:	4b07      	ldr	r3, [pc, #28]	; (8a10 <usbdc_unconfig+0x20>)
    89f4:	691c      	ldr	r4, [r3, #16]
	while (NULL != func) {
    89f6:	b14c      	cbz	r4, 8a0c <usbdc_unconfig+0x1c>
		func->ctrl(func, USBDF_DISABLE, NULL);
    89f8:	2600      	movs	r6, #0
    89fa:	2501      	movs	r5, #1
    89fc:	6863      	ldr	r3, [r4, #4]
    89fe:	4632      	mov	r2, r6
    8a00:	4629      	mov	r1, r5
    8a02:	4620      	mov	r0, r4
    8a04:	4798      	blx	r3
		func = func->next;
    8a06:	6824      	ldr	r4, [r4, #0]
	while (NULL != func) {
    8a08:	2c00      	cmp	r4, #0
    8a0a:	d1f7      	bne.n	89fc <usbdc_unconfig+0xc>
    8a0c:	bd70      	pop	{r4, r5, r6, pc}
    8a0e:	bf00      	nop
    8a10:	2000151c 	.word	0x2000151c

00008a14 <usbdc_change_notify>:
	}
}

/** Invoke all registered Change notification callbacks. */
static void usbdc_change_notify(enum usbdc_change_type change, uint32_t value)
{
    8a14:	b570      	push	{r4, r5, r6, lr}
    8a16:	4606      	mov	r6, r0
    8a18:	460d      	mov	r5, r1
	struct usbdc_change_handler *cg = (struct usbdc_change_handler *)usbdc.handlers.change_list.head;
    8a1a:	4b07      	ldr	r3, [pc, #28]	; (8a38 <usbdc_change_notify+0x24>)
    8a1c:	68dc      	ldr	r4, [r3, #12]

	while (cg != NULL) {
    8a1e:	b91c      	cbnz	r4, 8a28 <usbdc_change_notify+0x14>
    8a20:	bd70      	pop	{r4, r5, r6, pc}
		if (NULL != cg->cb) {
			cg->cb(change, value);
		}
		cg = cg->next;
    8a22:	6824      	ldr	r4, [r4, #0]
	while (cg != NULL) {
    8a24:	2c00      	cmp	r4, #0
    8a26:	d0fb      	beq.n	8a20 <usbdc_change_notify+0xc>
		if (NULL != cg->cb) {
    8a28:	6863      	ldr	r3, [r4, #4]
    8a2a:	2b00      	cmp	r3, #0
    8a2c:	d0f9      	beq.n	8a22 <usbdc_change_notify+0xe>
			cg->cb(change, value);
    8a2e:	4629      	mov	r1, r5
    8a30:	4630      	mov	r0, r6
    8a32:	4798      	blx	r3
    8a34:	e7f5      	b.n	8a22 <usbdc_change_notify+0xe>
    8a36:	bf00      	nop
    8a38:	2000151c 	.word	0x2000151c

00008a3c <usbdc_request_handler>:
	}
}

/** Invoke all registered request callbacks until request handled. */
static int32_t usbdc_request_handler(uint8_t ep, struct usb_req *req, enum usb_ctrl_stage stage)
{
    8a3c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    8a3e:	4607      	mov	r7, r0
    8a40:	460e      	mov	r6, r1
    8a42:	4615      	mov	r5, r2
	struct usbdc_req_handler *h = (struct usbdc_req_handler *)usbdc.handlers.req_list.head;
    8a44:	4b0c      	ldr	r3, [pc, #48]	; (8a78 <usbdc_request_handler+0x3c>)
    8a46:	689c      	ldr	r4, [r3, #8]
	int32_t                   rc;

	while (h != NULL) {
    8a48:	b91c      	cbnz	r4, 8a52 <usbdc_request_handler+0x16>
				return -1;
			}
		}
		h = h->next;
	}
	return false;
    8a4a:	2000      	movs	r0, #0
    8a4c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		h = h->next;
    8a4e:	6824      	ldr	r4, [r4, #0]
	while (h != NULL) {
    8a50:	b16c      	cbz	r4, 8a6e <usbdc_request_handler+0x32>
		if (NULL != h->cb) {
    8a52:	6863      	ldr	r3, [r4, #4]
    8a54:	2b00      	cmp	r3, #0
    8a56:	d0fa      	beq.n	8a4e <usbdc_request_handler+0x12>
			rc = h->cb(ep, req, stage);
    8a58:	462a      	mov	r2, r5
    8a5a:	4631      	mov	r1, r6
    8a5c:	4638      	mov	r0, r7
    8a5e:	4798      	blx	r3
			if (0 == rc) {
    8a60:	b138      	cbz	r0, 8a72 <usbdc_request_handler+0x36>
			} else if (ERR_NOT_FOUND != rc) {
    8a62:	f110 0f0a 	cmn.w	r0, #10
    8a66:	d0f2      	beq.n	8a4e <usbdc_request_handler+0x12>
				return -1;
    8a68:	f04f 30ff 	mov.w	r0, #4294967295
}
    8a6c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return false;
    8a6e:	2000      	movs	r0, #0
    8a70:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				return true;
    8a72:	2001      	movs	r0, #1
    8a74:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    8a76:	bf00      	nop
    8a78:	2000151c 	.word	0x2000151c

00008a7c <usbd_sof_cb>:

/**
 * \brief Callback invoked on USB device SOF
 */
static void usbd_sof_cb(void)
{
    8a7c:	b510      	push	{r4, lr}
	struct usbdc_sof_handler *sof = (struct usbdc_sof_handler *)usbdc.handlers.sof_list.head;
    8a7e:	4b06      	ldr	r3, [pc, #24]	; (8a98 <usbd_sof_cb+0x1c>)
    8a80:	685c      	ldr	r4, [r3, #4]
	while (sof != NULL) {
    8a82:	b91c      	cbnz	r4, 8a8c <usbd_sof_cb+0x10>
    8a84:	bd10      	pop	{r4, pc}
		sof = sof->next;
    8a86:	6824      	ldr	r4, [r4, #0]
	while (sof != NULL) {
    8a88:	2c00      	cmp	r4, #0
    8a8a:	d0fb      	beq.n	8a84 <usbd_sof_cb+0x8>
		if (NULL != sof->cb) {
    8a8c:	6863      	ldr	r3, [r4, #4]
    8a8e:	2b00      	cmp	r3, #0
    8a90:	d0f9      	beq.n	8a86 <usbd_sof_cb+0xa>
			sof->cb();
    8a92:	4798      	blx	r3
    8a94:	e7f7      	b.n	8a86 <usbd_sof_cb+0xa>
    8a96:	bf00      	nop
    8a98:	2000151c 	.word	0x2000151c

00008a9c <usbdc_cb_ctl_done>:
 * \return Data has error or not.
 * \retval true There is data error, protocol error.
 * \retval false There is no data error.
 */
static bool usbdc_cb_ctl_done(const uint8_t ep, const enum usb_xfer_code code, struct usb_req *req)
{
    8a9c:	b510      	push	{r4, lr}
    8a9e:	4614      	mov	r4, r2
	(void)ep;

	switch (code) {
    8aa0:	b119      	cbz	r1, 8aaa <usbdc_cb_ctl_done+0xe>
    8aa2:	2901      	cmp	r1, #1
    8aa4:	d026      	beq.n	8af4 <usbdc_cb_ctl_done+0x58>
		return usbdc_ctrl_data_end(req);
	default:
		break;
	}
	return false;
}
    8aa6:	2000      	movs	r0, #0
    8aa8:	bd10      	pop	{r4, pc}
	if (req->bmRequestType != USB_REQT_TYPE_STANDARD) {
    8aaa:	7813      	ldrb	r3, [r2, #0]
    8aac:	2b00      	cmp	r3, #0
    8aae:	d1fa      	bne.n	8aa6 <usbdc_cb_ctl_done+0xa>
	switch (req->bRequest) {
    8ab0:	7853      	ldrb	r3, [r2, #1]
    8ab2:	2b05      	cmp	r3, #5
    8ab4:	d00f      	beq.n	8ad6 <usbdc_cb_ctl_done+0x3a>
    8ab6:	2b09      	cmp	r3, #9
    8ab8:	d1f5      	bne.n	8aa6 <usbdc_cb_ctl_done+0xa>
		usbdc.cfg_value = req->wValue;
    8aba:	8852      	ldrh	r2, [r2, #2]
    8abc:	4b10      	ldr	r3, [pc, #64]	; (8b00 <usbdc_cb_ctl_done+0x64>)
    8abe:	76da      	strb	r2, [r3, #27]
		usbdc.state     = req->wValue ? USBD_S_CONFIG : USBD_S_ADDRESS;
    8ac0:	8863      	ldrh	r3, [r4, #2]
    8ac2:	2b00      	cmp	r3, #0
    8ac4:	bf14      	ite	ne
    8ac6:	2104      	movne	r1, #4
    8ac8:	2103      	moveq	r1, #3
    8aca:	4b0d      	ldr	r3, [pc, #52]	; (8b00 <usbdc_cb_ctl_done+0x64>)
    8acc:	7699      	strb	r1, [r3, #26]
		usbdc_change_notify(USBDC_C_STATE, usbdc.state);
    8ace:	2001      	movs	r0, #1
    8ad0:	4b0c      	ldr	r3, [pc, #48]	; (8b04 <usbdc_cb_ctl_done+0x68>)
    8ad2:	4798      	blx	r3
    8ad4:	e7e7      	b.n	8aa6 <usbdc_cb_ctl_done+0xa>
		usbdc_set_address(req->wValue);
    8ad6:	8850      	ldrh	r0, [r2, #2]
	usb_d_set_address(addr);
    8ad8:	b2c0      	uxtb	r0, r0
    8ada:	4b0b      	ldr	r3, [pc, #44]	; (8b08 <usbdc_cb_ctl_done+0x6c>)
    8adc:	4798      	blx	r3
		usbdc.state = req->wValue ? USBD_S_ADDRESS : USBD_S_DEFAULT;
    8ade:	8863      	ldrh	r3, [r4, #2]
    8ae0:	2b00      	cmp	r3, #0
    8ae2:	bf14      	ite	ne
    8ae4:	2103      	movne	r1, #3
    8ae6:	2102      	moveq	r1, #2
    8ae8:	4b05      	ldr	r3, [pc, #20]	; (8b00 <usbdc_cb_ctl_done+0x64>)
    8aea:	7699      	strb	r1, [r3, #26]
		usbdc_change_notify(USBDC_C_STATE, usbdc.state);
    8aec:	2001      	movs	r0, #1
    8aee:	4b05      	ldr	r3, [pc, #20]	; (8b04 <usbdc_cb_ctl_done+0x68>)
    8af0:	4798      	blx	r3
    8af2:	e7d8      	b.n	8aa6 <usbdc_cb_ctl_done+0xa>
	usbdc_request_handler(0, req, USB_DATA_STAGE);
    8af4:	2201      	movs	r2, #1
    8af6:	4621      	mov	r1, r4
    8af8:	2000      	movs	r0, #0
    8afa:	4b04      	ldr	r3, [pc, #16]	; (8b0c <usbdc_cb_ctl_done+0x70>)
    8afc:	4798      	blx	r3
		return usbdc_ctrl_data_end(req);
    8afe:	e7d2      	b.n	8aa6 <usbdc_cb_ctl_done+0xa>
    8b00:	2000151c 	.word	0x2000151c
    8b04:	00008a15 	.word	0x00008a15
    8b08:	00002f45 	.word	0x00002f45
    8b0c:	00008a3d 	.word	0x00008a3d

00008b10 <usbdc_reset>:

/**
 * \brief USB Device Core Reset
 */
void usbdc_reset(void)
{
    8b10:	b570      	push	{r4, r5, r6, lr}
	usbdc_unconfig();
    8b12:	4b0d      	ldr	r3, [pc, #52]	; (8b48 <usbdc_reset+0x38>)
    8b14:	4798      	blx	r3

	usbdc.state       = USBD_S_DEFAULT;
    8b16:	4d0d      	ldr	r5, [pc, #52]	; (8b4c <usbdc_reset+0x3c>)
    8b18:	2602      	movs	r6, #2
    8b1a:	76ae      	strb	r6, [r5, #26]
	usbdc.cfg_value   = 0;
    8b1c:	2400      	movs	r4, #0
    8b1e:	76ec      	strb	r4, [r5, #27]
	usbdc.ifc_alt_map = 0;
    8b20:	776c      	strb	r4, [r5, #29]

	// Setup EP0
	usb_d_ep_deinit(0);
    8b22:	4620      	mov	r0, r4
    8b24:	4b0a      	ldr	r3, [pc, #40]	; (8b50 <usbdc_reset+0x40>)
    8b26:	4798      	blx	r3
	usb_d_ep0_init(usbdc.ctrl_size);
    8b28:	7f28      	ldrb	r0, [r5, #28]
    8b2a:	4b0a      	ldr	r3, [pc, #40]	; (8b54 <usbdc_reset+0x44>)
    8b2c:	4798      	blx	r3
	usb_d_ep_register_callback(0, USB_D_EP_CB_SETUP, (FUNC_PTR)usbdc_cb_ctl_req);
    8b2e:	4a0a      	ldr	r2, [pc, #40]	; (8b58 <usbdc_reset+0x48>)
    8b30:	4621      	mov	r1, r4
    8b32:	4620      	mov	r0, r4
    8b34:	4d09      	ldr	r5, [pc, #36]	; (8b5c <usbdc_reset+0x4c>)
    8b36:	47a8      	blx	r5
	usb_d_ep_register_callback(0, USB_D_EP_CB_XFER, (FUNC_PTR)usbdc_cb_ctl_done);
    8b38:	4a09      	ldr	r2, [pc, #36]	; (8b60 <usbdc_reset+0x50>)
    8b3a:	4631      	mov	r1, r6
    8b3c:	4620      	mov	r0, r4
    8b3e:	47a8      	blx	r5
	usb_d_ep_enable(0);
    8b40:	4620      	mov	r0, r4
    8b42:	4b08      	ldr	r3, [pc, #32]	; (8b64 <usbdc_reset+0x54>)
    8b44:	4798      	blx	r3
    8b46:	bd70      	pop	{r4, r5, r6, pc}
    8b48:	000089f1 	.word	0x000089f1
    8b4c:	2000151c 	.word	0x2000151c
    8b50:	00002fb9 	.word	0x00002fb9
    8b54:	00002fa5 	.word	0x00002fa5
    8b58:	00008ba9 	.word	0x00008ba9
    8b5c:	000031b9 	.word	0x000031b9
    8b60:	00008a9d 	.word	0x00008a9d
    8b64:	00002fe5 	.word	0x00002fe5

00008b68 <usbd_event_cb>:
 * \brief Callback invoked on USB device events
 * \param[in] ev Event code.
 * \param[in] param Event parameter for event handling.
 */
static void usbd_event_cb(const enum usb_event ev, const uint32_t param)
{
    8b68:	b508      	push	{r3, lr}
	(void)param;

	switch (ev) {
    8b6a:	b110      	cbz	r0, 8b72 <usbd_event_cb+0xa>
    8b6c:	2801      	cmp	r0, #1
    8b6e:	d004      	beq.n	8b7a <usbd_event_cb+0x12>
    8b70:	bd08      	pop	{r3, pc}
	case USB_EV_VBUS:
		usbdc_change_notify(USBDC_C_CONN, param);
    8b72:	2000      	movs	r0, #0
    8b74:	4b02      	ldr	r3, [pc, #8]	; (8b80 <usbd_event_cb+0x18>)
    8b76:	4798      	blx	r3
		break;
    8b78:	bd08      	pop	{r3, pc}

	case USB_EV_RESET:
		usbdc_reset();
    8b7a:	4b02      	ldr	r3, [pc, #8]	; (8b84 <usbd_event_cb+0x1c>)
    8b7c:	4798      	blx	r3
    8b7e:	bd08      	pop	{r3, pc}
    8b80:	00008a15 	.word	0x00008a15
    8b84:	00008b11 	.word	0x00008b11

00008b88 <usbdc_xfer>:

/**
 * \brief Issue USB device transfer
 */
int32_t usbdc_xfer(uint8_t ep, uint8_t *buf, uint32_t size, bool zlp)
{
    8b88:	b500      	push	{lr}
    8b8a:	b085      	sub	sp, #20
	struct usb_d_transfer xfer = {(uint8_t *)buf, size, ep, zlp};
    8b8c:	9101      	str	r1, [sp, #4]
    8b8e:	9202      	str	r2, [sp, #8]
    8b90:	f88d 000c 	strb.w	r0, [sp, #12]
    8b94:	f88d 300d 	strb.w	r3, [sp, #13]
	return usb_d_ep_transfer(&xfer);
    8b98:	a801      	add	r0, sp, #4
    8b9a:	4b02      	ldr	r3, [pc, #8]	; (8ba4 <usbdc_xfer+0x1c>)
    8b9c:	4798      	blx	r3
}
    8b9e:	b005      	add	sp, #20
    8ba0:	f85d fb04 	ldr.w	pc, [sp], #4
    8ba4:	00003031 	.word	0x00003031

00008ba8 <usbdc_cb_ctl_req>:
{
    8ba8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    8bac:	b083      	sub	sp, #12
    8bae:	4605      	mov	r5, r0
    8bb0:	460c      	mov	r4, r1
	switch (usbdc_request_handler(ep, req, USB_SETUP_STAGE)) {
    8bb2:	2200      	movs	r2, #0
    8bb4:	4b9b      	ldr	r3, [pc, #620]	; (8e24 <usbdc_cb_ctl_req+0x27c>)
    8bb6:	4798      	blx	r3
    8bb8:	f1b0 3fff 	cmp.w	r0, #4294967295
    8bbc:	d00b      	beq.n	8bd6 <usbdc_cb_ctl_req+0x2e>
    8bbe:	2801      	cmp	r0, #1
    8bc0:	f000 81e3 	beq.w	8f8a <usbdc_cb_ctl_req+0x3e2>
	switch (req->bmRequestType & (USB_REQT_TYPE_MASK | USB_REQT_DIR_IN)) {
    8bc4:	7823      	ldrb	r3, [r4, #0]
    8bc6:	f013 02e0 	ands.w	r2, r3, #224	; 0xe0
    8bca:	d008      	beq.n	8bde <usbdc_cb_ctl_req+0x36>
    8bcc:	2a80      	cmp	r2, #128	; 0x80
    8bce:	f000 80f4 	beq.w	8dba <usbdc_cb_ctl_req+0x212>
		return false;
    8bd2:	2000      	movs	r0, #0
    8bd4:	e000      	b.n	8bd8 <usbdc_cb_ctl_req+0x30>
		return false;
    8bd6:	2000      	movs	r0, #0
}
    8bd8:	b003      	add	sp, #12
    8bda:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	switch (req->bRequest) {
    8bde:	7862      	ldrb	r2, [r4, #1]
    8be0:	3a01      	subs	r2, #1
    8be2:	2a0a      	cmp	r2, #10
    8be4:	f200 81d3 	bhi.w	8f8e <usbdc_cb_ctl_req+0x3e6>
    8be8:	e8df f012 	tbh	[pc, r2, lsl #1]
    8bec:	01d10060 	.word	0x01d10060
    8bf0:	01d10076 	.word	0x01d10076
    8bf4:	01d1000b 	.word	0x01d1000b
    8bf8:	01d101d1 	.word	0x01d101d1
    8bfc:	01d10015 	.word	0x01d10015
    8c00:	008c      	.short	0x008c
		return (ERR_NONE == usbdc_xfer(ep, NULL, 0, true));
    8c02:	2301      	movs	r3, #1
    8c04:	2200      	movs	r2, #0
    8c06:	4611      	mov	r1, r2
    8c08:	4628      	mov	r0, r5
    8c0a:	4c87      	ldr	r4, [pc, #540]	; (8e28 <usbdc_cb_ctl_req+0x280>)
    8c0c:	47a0      	blx	r4
    8c0e:	fab0 f080 	clz	r0, r0
    8c12:	0940      	lsrs	r0, r0, #5
    8c14:	e7e0      	b.n	8bd8 <usbdc_cb_ctl_req+0x30>
		if (!usbdc_set_config(req->wValue)) {
    8c16:	8862      	ldrh	r2, [r4, #2]
    8c18:	b2d2      	uxtb	r2, r2
	if (cfg_value == 0) {
    8c1a:	b1ca      	cbz	r2, 8c50 <usbdc_cb_ctl_req+0xa8>
		cfg_desc = usb_find_cfg_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, cfg_value);
    8c1c:	4b83      	ldr	r3, [pc, #524]	; (8e2c <usbdc_cb_ctl_req+0x284>)
    8c1e:	681b      	ldr	r3, [r3, #0]
    8c20:	6859      	ldr	r1, [r3, #4]
    8c22:	6818      	ldr	r0, [r3, #0]
    8c24:	4b82      	ldr	r3, [pc, #520]	; (8e30 <usbdc_cb_ctl_req+0x288>)
    8c26:	4798      	blx	r3
	if (NULL == cfg_desc) {
    8c28:	2800      	cmp	r0, #0
    8c2a:	f000 81be 	beq.w	8faa <usbdc_cb_ctl_req+0x402>
	return (ptr[0] + (ptr[1] << 8));
    8c2e:	78c2      	ldrb	r2, [r0, #3]
    8c30:	7881      	ldrb	r1, [r0, #2]
    8c32:	eb01 2102 	add.w	r1, r1, r2, lsl #8
	desc.eod  = cfg_desc + total_len;
    8c36:	fa10 f181 	uxtah	r1, r0, r1
    8c3a:	9101      	str	r1, [sp, #4]
	desc.sod  = usb_find_desc(cfg_desc, desc.eod, USB_DT_INTERFACE);
    8c3c:	2204      	movs	r2, #4
    8c3e:	4b7d      	ldr	r3, [pc, #500]	; (8e34 <usbdc_cb_ctl_req+0x28c>)
    8c40:	4798      	blx	r3
    8c42:	9000      	str	r0, [sp, #0]
	while (NULL != desc.sod) {
    8c44:	b130      	cbz	r0, 8c54 <usbdc_cb_ctl_req+0xac>
    8c46:	24ff      	movs	r4, #255	; 0xff
			func       = (struct usbdf_driver *)usbdc.func_list.head;
    8c48:	f8df 81e0 	ldr.w	r8, [pc, #480]	; 8e2c <usbdc_cb_ctl_req+0x284>
		desc.sod = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE);
    8c4c:	4f79      	ldr	r7, [pc, #484]	; (8e34 <usbdc_cb_ctl_req+0x28c>)
    8c4e:	e018      	b.n	8c82 <usbdc_cb_ctl_req+0xda>
		usbdc_unconfig();
    8c50:	4b79      	ldr	r3, [pc, #484]	; (8e38 <usbdc_cb_ctl_req+0x290>)
    8c52:	4798      	blx	r3
		return (ERR_NONE == usbdc_xfer(ep, NULL, 0, true));
    8c54:	2301      	movs	r3, #1
    8c56:	2200      	movs	r2, #0
    8c58:	4611      	mov	r1, r2
    8c5a:	4628      	mov	r0, r5
    8c5c:	4c72      	ldr	r4, [pc, #456]	; (8e28 <usbdc_cb_ctl_req+0x280>)
    8c5e:	47a0      	blx	r4
    8c60:	fab0 f080 	clz	r0, r0
    8c64:	0940      	lsrs	r0, r0, #5
    8c66:	e7b7      	b.n	8bd8 <usbdc_cb_ctl_req+0x30>
			last_iface = desc.sod[2];
    8c68:	464c      	mov	r4, r9
    8c6a:	e000      	b.n	8c6e <usbdc_cb_ctl_req+0xc6>
    8c6c:	464c      	mov	r4, r9
		desc.sod = usb_desc_next(desc.sod);
    8c6e:	9800      	ldr	r0, [sp, #0]
	return (desc + usb_desc_len(desc));
    8c70:	7803      	ldrb	r3, [r0, #0]
    8c72:	4418      	add	r0, r3
    8c74:	9000      	str	r0, [sp, #0]
		desc.sod = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE);
    8c76:	2204      	movs	r2, #4
    8c78:	9901      	ldr	r1, [sp, #4]
    8c7a:	47b8      	blx	r7
    8c7c:	9000      	str	r0, [sp, #0]
	while (NULL != desc.sod) {
    8c7e:	2800      	cmp	r0, #0
    8c80:	d0e8      	beq.n	8c54 <usbdc_cb_ctl_req+0xac>
		if (last_iface != desc.sod[2] /* bInterfaceNumber */) {
    8c82:	f890 9002 	ldrb.w	r9, [r0, #2]
    8c86:	45a1      	cmp	r9, r4
    8c88:	d0f1      	beq.n	8c6e <usbdc_cb_ctl_req+0xc6>
			func       = (struct usbdf_driver *)usbdc.func_list.head;
    8c8a:	f8d8 4010 	ldr.w	r4, [r8, #16]
			while (NULL != func) {
    8c8e:	2c00      	cmp	r4, #0
    8c90:	d0ea      	beq.n	8c68 <usbdc_cb_ctl_req+0xc0>
				if (func->ctrl(func, USBDF_ENABLE, &desc)) {
    8c92:	2600      	movs	r6, #0
    8c94:	6863      	ldr	r3, [r4, #4]
    8c96:	466a      	mov	r2, sp
    8c98:	4631      	mov	r1, r6
    8c9a:	4620      	mov	r0, r4
    8c9c:	4798      	blx	r3
    8c9e:	2800      	cmp	r0, #0
    8ca0:	d0e4      	beq.n	8c6c <usbdc_cb_ctl_req+0xc4>
					func = func->next;
    8ca2:	6824      	ldr	r4, [r4, #0]
			while (NULL != func) {
    8ca4:	2c00      	cmp	r4, #0
    8ca6:	d1f5      	bne.n	8c94 <usbdc_cb_ctl_req+0xec>
			last_iface = desc.sod[2];
    8ca8:	464c      	mov	r4, r9
    8caa:	e7e0      	b.n	8c6e <usbdc_cb_ctl_req+0xc6>
	switch (req->bmRequestType & USB_REQT_RECIP_MASK) {
    8cac:	f003 031f 	and.w	r3, r3, #31
    8cb0:	2b02      	cmp	r3, #2
    8cb2:	f040 816e 	bne.w	8f92 <usbdc_cb_ctl_req+0x3ea>
		if (req->wLength != 0) {
    8cb6:	88e3      	ldrh	r3, [r4, #6]
    8cb8:	b10b      	cbz	r3, 8cbe <usbdc_cb_ctl_req+0x116>
			return false;
    8cba:	2000      	movs	r0, #0
    8cbc:	e78c      	b.n	8bd8 <usbdc_cb_ctl_req+0x30>
		usb_d_ep_halt(req->wIndex & 0xFF, USB_EP_HALT_CLR);
    8cbe:	88a0      	ldrh	r0, [r4, #4]
    8cc0:	2100      	movs	r1, #0
    8cc2:	b2c0      	uxtb	r0, r0
    8cc4:	4b5d      	ldr	r3, [pc, #372]	; (8e3c <usbdc_cb_ctl_req+0x294>)
    8cc6:	4798      	blx	r3
		usbdc_xfer(ep, NULL, 0, true);
    8cc8:	2301      	movs	r3, #1
    8cca:	2200      	movs	r2, #0
    8ccc:	4611      	mov	r1, r2
    8cce:	4628      	mov	r0, r5
    8cd0:	4c55      	ldr	r4, [pc, #340]	; (8e28 <usbdc_cb_ctl_req+0x280>)
    8cd2:	47a0      	blx	r4
		return true;
    8cd4:	2001      	movs	r0, #1
    8cd6:	e77f      	b.n	8bd8 <usbdc_cb_ctl_req+0x30>
	switch (req->bmRequestType & USB_REQT_RECIP_MASK) {
    8cd8:	f003 031f 	and.w	r3, r3, #31
    8cdc:	2b02      	cmp	r3, #2
    8cde:	f040 815a 	bne.w	8f96 <usbdc_cb_ctl_req+0x3ee>
		if (req->wLength != 0) {
    8ce2:	88e3      	ldrh	r3, [r4, #6]
    8ce4:	b10b      	cbz	r3, 8cea <usbdc_cb_ctl_req+0x142>
			return false;
    8ce6:	2000      	movs	r0, #0
    8ce8:	e776      	b.n	8bd8 <usbdc_cb_ctl_req+0x30>
		usb_d_ep_halt(req->wIndex & 0xFF, USB_EP_HALT_SET);
    8cea:	88a0      	ldrh	r0, [r4, #4]
    8cec:	2101      	movs	r1, #1
    8cee:	b2c0      	uxtb	r0, r0
    8cf0:	4b52      	ldr	r3, [pc, #328]	; (8e3c <usbdc_cb_ctl_req+0x294>)
    8cf2:	4798      	blx	r3
		usbdc_xfer(ep, NULL, 0, true);
    8cf4:	2301      	movs	r3, #1
    8cf6:	2200      	movs	r2, #0
    8cf8:	4611      	mov	r1, r2
    8cfa:	4628      	mov	r0, r5
    8cfc:	4c4a      	ldr	r4, [pc, #296]	; (8e28 <usbdc_cb_ctl_req+0x280>)
    8cfe:	47a0      	blx	r4
		return true;
    8d00:	2001      	movs	r0, #1
    8d02:	e769      	b.n	8bd8 <usbdc_cb_ctl_req+0x30>
		return usbdc_set_interface(req->wValue, req->wIndex);
    8d04:	8866      	ldrh	r6, [r4, #2]
    8d06:	88a4      	ldrh	r4, [r4, #4]
		ifc = usb_find_cfg_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, usbdc.cfg_value);
    8d08:	4a48      	ldr	r2, [pc, #288]	; (8e2c <usbdc_cb_ctl_req+0x284>)
    8d0a:	6813      	ldr	r3, [r2, #0]
    8d0c:	7ed2      	ldrb	r2, [r2, #27]
    8d0e:	6859      	ldr	r1, [r3, #4]
    8d10:	6818      	ldr	r0, [r3, #0]
    8d12:	4b47      	ldr	r3, [pc, #284]	; (8e30 <usbdc_cb_ctl_req+0x288>)
    8d14:	4798      	blx	r3
	if (NULL == ifc) {
    8d16:	2800      	cmp	r0, #0
    8d18:	d045      	beq.n	8da6 <usbdc_cb_ctl_req+0x1fe>
	desc.sod = ifc;
    8d1a:	9000      	str	r0, [sp, #0]
	return (ptr[0] + (ptr[1] << 8));
    8d1c:	78c2      	ldrb	r2, [r0, #3]
    8d1e:	7881      	ldrb	r1, [r0, #2]
    8d20:	eb01 2102 	add.w	r1, r1, r2, lsl #8
	desc.eod = ifc + usb_cfg_desc_total_len(ifc);
    8d24:	fa10 f181 	uxtah	r1, r0, r1
    8d28:	9101      	str	r1, [sp, #4]
	if (NULL == (ifc = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE))) {
    8d2a:	2204      	movs	r2, #4
    8d2c:	4b41      	ldr	r3, [pc, #260]	; (8e34 <usbdc_cb_ctl_req+0x28c>)
    8d2e:	4798      	blx	r3
    8d30:	4603      	mov	r3, r0
    8d32:	2800      	cmp	r0, #0
    8d34:	d039      	beq.n	8daa <usbdc_cb_ctl_req+0x202>
		ifc      = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE);
    8d36:	2704      	movs	r7, #4
    8d38:	4d3e      	ldr	r5, [pc, #248]	; (8e34 <usbdc_cb_ctl_req+0x28c>)
    8d3a:	e008      	b.n	8d4e <usbdc_cb_ctl_req+0x1a6>
		desc.sod = usb_desc_next(desc.sod);
    8d3c:	9800      	ldr	r0, [sp, #0]
	return (desc + usb_desc_len(desc));
    8d3e:	7803      	ldrb	r3, [r0, #0]
    8d40:	4418      	add	r0, r3
    8d42:	9000      	str	r0, [sp, #0]
		ifc      = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE);
    8d44:	463a      	mov	r2, r7
    8d46:	9901      	ldr	r1, [sp, #4]
    8d48:	47a8      	blx	r5
		if (NULL == ifc) {
    8d4a:	4603      	mov	r3, r0
    8d4c:	b378      	cbz	r0, 8dae <usbdc_cb_ctl_req+0x206>
	while (ifc[2] != ifc_id || ifc[3] != alt_set) {
    8d4e:	789a      	ldrb	r2, [r3, #2]
    8d50:	42a2      	cmp	r2, r4
    8d52:	d1f3      	bne.n	8d3c <usbdc_cb_ctl_req+0x194>
    8d54:	78da      	ldrb	r2, [r3, #3]
    8d56:	42b2      	cmp	r2, r6
    8d58:	d1f0      	bne.n	8d3c <usbdc_cb_ctl_req+0x194>
	desc.sod = ifc;
    8d5a:	9300      	str	r3, [sp, #0]
	func     = (struct usbdf_driver *)usbdc.func_list.head;
    8d5c:	4b33      	ldr	r3, [pc, #204]	; (8e2c <usbdc_cb_ctl_req+0x284>)
    8d5e:	691d      	ldr	r5, [r3, #16]
	while (NULL != func) {
    8d60:	b33d      	cbz	r5, 8db2 <usbdc_cb_ctl_req+0x20a>
		if (func->ctrl(func, USBDF_DISABLE, &desc)) {
    8d62:	2701      	movs	r7, #1
    8d64:	686b      	ldr	r3, [r5, #4]
    8d66:	466a      	mov	r2, sp
    8d68:	4639      	mov	r1, r7
    8d6a:	4628      	mov	r0, r5
    8d6c:	4798      	blx	r3
    8d6e:	b120      	cbz	r0, 8d7a <usbdc_cb_ctl_req+0x1d2>
			func = func->next;
    8d70:	682d      	ldr	r5, [r5, #0]
	while (NULL != func) {
    8d72:	2d00      	cmp	r5, #0
    8d74:	d1f6      	bne.n	8d64 <usbdc_cb_ctl_req+0x1bc>
	return false;
    8d76:	2000      	movs	r0, #0
    8d78:	e72e      	b.n	8bd8 <usbdc_cb_ctl_req+0x30>
		} else if (ERR_NONE == func->ctrl(func, USBDF_ENABLE, &desc)) {
    8d7a:	686b      	ldr	r3, [r5, #4]
    8d7c:	466a      	mov	r2, sp
    8d7e:	2100      	movs	r1, #0
    8d80:	4628      	mov	r0, r5
    8d82:	4798      	blx	r3
    8d84:	b9b8      	cbnz	r0, 8db6 <usbdc_cb_ctl_req+0x20e>
			if (alt_set) {
    8d86:	b136      	cbz	r6, 8d96 <usbdc_cb_ctl_req+0x1ee>
				usbdc.ifc_alt_map |= 1 << ifc_id;
    8d88:	4a28      	ldr	r2, [pc, #160]	; (8e2c <usbdc_cb_ctl_req+0x284>)
    8d8a:	2301      	movs	r3, #1
    8d8c:	fa03 f404 	lsl.w	r4, r3, r4
    8d90:	7f53      	ldrb	r3, [r2, #29]
    8d92:	4323      	orrs	r3, r4
    8d94:	7753      	strb	r3, [r2, #29]
			usbdc_xfer(0, NULL, 0, 0);
    8d96:	2300      	movs	r3, #0
    8d98:	461a      	mov	r2, r3
    8d9a:	4619      	mov	r1, r3
    8d9c:	4618      	mov	r0, r3
    8d9e:	4c22      	ldr	r4, [pc, #136]	; (8e28 <usbdc_cb_ctl_req+0x280>)
    8da0:	47a0      	blx	r4
			return true;
    8da2:	2001      	movs	r0, #1
    8da4:	e718      	b.n	8bd8 <usbdc_cb_ctl_req+0x30>
		return false;
    8da6:	2000      	movs	r0, #0
    8da8:	e716      	b.n	8bd8 <usbdc_cb_ctl_req+0x30>
		return false;
    8daa:	2000      	movs	r0, #0
    8dac:	e714      	b.n	8bd8 <usbdc_cb_ctl_req+0x30>
			return false;
    8dae:	2000      	movs	r0, #0
    8db0:	e712      	b.n	8bd8 <usbdc_cb_ctl_req+0x30>
	return false;
    8db2:	2000      	movs	r0, #0
    8db4:	e710      	b.n	8bd8 <usbdc_cb_ctl_req+0x30>
			return false;
    8db6:	2000      	movs	r0, #0
    8db8:	e70e      	b.n	8bd8 <usbdc_cb_ctl_req+0x30>
	switch (req->bRequest) {
    8dba:	7862      	ldrb	r2, [r4, #1]
    8dbc:	2a0a      	cmp	r2, #10
    8dbe:	f200 80ec 	bhi.w	8f9a <usbdc_cb_ctl_req+0x3f2>
    8dc2:	e8df f012 	tbh	[pc, r2, lsl #1]
    8dc6:	008e      	.short	0x008e
    8dc8:	00ea00ea 	.word	0x00ea00ea
    8dcc:	00ea00ea 	.word	0x00ea00ea
    8dd0:	000b00ea 	.word	0x000b00ea
    8dd4:	008200ea 	.word	0x008200ea
    8dd8:	00b200ea 	.word	0x00b200ea
	uint8_t type = (uint8_t)(req->wValue >> 8);
    8ddc:	8862      	ldrh	r2, [r4, #2]
	switch (type) {
    8dde:	0a13      	lsrs	r3, r2, #8
    8de0:	2b02      	cmp	r3, #2
    8de2:	d02d      	beq.n	8e40 <usbdc_cb_ctl_req+0x298>
    8de4:	2b03      	cmp	r3, #3
    8de6:	d050      	beq.n	8e8a <usbdc_cb_ctl_req+0x2e2>
    8de8:	2b01      	cmp	r3, #1
    8dea:	d001      	beq.n	8df0 <usbdc_cb_ctl_req+0x248>
	return false;
    8dec:	2000      	movs	r0, #0
    8dee:	e6f3      	b.n	8bd8 <usbdc_cb_ctl_req+0x30>
	uint16_t length   = req->wLength;
    8df0:	88e2      	ldrh	r2, [r4, #6]
    8df2:	2a12      	cmp	r2, #18
    8df4:	bf28      	it	cs
    8df6:	2212      	movcs	r2, #18
    8df8:	4614      	mov	r4, r2
		dev_desc = usb_find_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, USB_DT_DEVICE);
    8dfa:	4b0c      	ldr	r3, [pc, #48]	; (8e2c <usbdc_cb_ctl_req+0x284>)
    8dfc:	681b      	ldr	r3, [r3, #0]
    8dfe:	2201      	movs	r2, #1
    8e00:	6859      	ldr	r1, [r3, #4]
    8e02:	6818      	ldr	r0, [r3, #0]
    8e04:	4b0b      	ldr	r3, [pc, #44]	; (8e34 <usbdc_cb_ctl_req+0x28c>)
    8e06:	4798      	blx	r3
	if (!dev_desc) {
    8e08:	4601      	mov	r1, r0
    8e0a:	2800      	cmp	r0, #0
    8e0c:	f000 80c7 	beq.w	8f9e <usbdc_cb_ctl_req+0x3f6>
	if (ERR_NONE != usbdc_xfer(ep, dev_desc, length, false)) {
    8e10:	2300      	movs	r3, #0
    8e12:	4622      	mov	r2, r4
    8e14:	4628      	mov	r0, r5
    8e16:	4c04      	ldr	r4, [pc, #16]	; (8e28 <usbdc_cb_ctl_req+0x280>)
    8e18:	47a0      	blx	r4
    8e1a:	fab0 f080 	clz	r0, r0
    8e1e:	0940      	lsrs	r0, r0, #5
    8e20:	e6da      	b.n	8bd8 <usbdc_cb_ctl_req+0x30>
    8e22:	bf00      	nop
    8e24:	00008a3d 	.word	0x00008a3d
    8e28:	00008b89 	.word	0x00008b89
    8e2c:	2000151c 	.word	0x2000151c
    8e30:	0000914d 	.word	0x0000914d
    8e34:	000090cd 	.word	0x000090cd
    8e38:	000089f1 	.word	0x000089f1
    8e3c:	00003151 	.word	0x00003151
	uint16_t length   = req->wLength;
    8e40:	88e4      	ldrh	r4, [r4, #6]
	bool     need_zlp = !(length & (usbdc.ctrl_size - 1));
    8e42:	4b5b      	ldr	r3, [pc, #364]	; (8fb0 <usbdc_cb_ctl_req+0x408>)
    8e44:	7f1e      	ldrb	r6, [r3, #28]
		cfg_desc = usb_find_cfg_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, index + 1);
    8e46:	681b      	ldr	r3, [r3, #0]
    8e48:	3201      	adds	r2, #1
    8e4a:	b2d2      	uxtb	r2, r2
    8e4c:	6859      	ldr	r1, [r3, #4]
    8e4e:	6818      	ldr	r0, [r3, #0]
    8e50:	4b58      	ldr	r3, [pc, #352]	; (8fb4 <usbdc_cb_ctl_req+0x40c>)
    8e52:	4798      	blx	r3
	if (NULL == cfg_desc) {
    8e54:	4601      	mov	r1, r0
    8e56:	2800      	cmp	r0, #0
    8e58:	f000 80a3 	beq.w	8fa2 <usbdc_cb_ctl_req+0x3fa>
	return (ptr[0] + (ptr[1] << 8));
    8e5c:	78c3      	ldrb	r3, [r0, #3]
    8e5e:	7882      	ldrb	r2, [r0, #2]
    8e60:	eb02 2203 	add.w	r2, r2, r3, lsl #8
    8e64:	b292      	uxth	r2, r2
	if (length <= total_len) {
    8e66:	4294      	cmp	r4, r2
    8e68:	d90d      	bls.n	8e86 <usbdc_cb_ctl_req+0x2de>
	bool     need_zlp = !(length & (usbdc.ctrl_size - 1));
    8e6a:	3e01      	subs	r6, #1
    8e6c:	4226      	tst	r6, r4
    8e6e:	bf0c      	ite	eq
    8e70:	2301      	moveq	r3, #1
    8e72:	2300      	movne	r3, #0
		length = total_len;
    8e74:	4614      	mov	r4, r2
	if (ERR_NONE != usbdc_xfer(ep, cfg_desc, length, need_zlp)) {
    8e76:	4622      	mov	r2, r4
    8e78:	4628      	mov	r0, r5
    8e7a:	4c4f      	ldr	r4, [pc, #316]	; (8fb8 <usbdc_cb_ctl_req+0x410>)
    8e7c:	47a0      	blx	r4
    8e7e:	fab0 f080 	clz	r0, r0
    8e82:	0940      	lsrs	r0, r0, #5
    8e84:	e6a8      	b.n	8bd8 <usbdc_cb_ctl_req+0x30>
		need_zlp = false;
    8e86:	2300      	movs	r3, #0
    8e88:	e7f5      	b.n	8e76 <usbdc_cb_ctl_req+0x2ce>
	uint16_t length   = req->wLength;
    8e8a:	88e4      	ldrh	r4, [r4, #6]
	bool     need_zlp = !(length & (usbdc.ctrl_size - 1));
    8e8c:	4b48      	ldr	r3, [pc, #288]	; (8fb0 <usbdc_cb_ctl_req+0x408>)
    8e8e:	7f1e      	ldrb	r6, [r3, #28]
	str_desc = usb_find_str_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, index);
    8e90:	681b      	ldr	r3, [r3, #0]
    8e92:	b2d2      	uxtb	r2, r2
    8e94:	6859      	ldr	r1, [r3, #4]
    8e96:	6818      	ldr	r0, [r3, #0]
    8e98:	4b48      	ldr	r3, [pc, #288]	; (8fbc <usbdc_cb_ctl_req+0x414>)
    8e9a:	4798      	blx	r3
	if (NULL == str_desc) {
    8e9c:	4601      	mov	r1, r0
    8e9e:	2800      	cmp	r0, #0
    8ea0:	f000 8081 	beq.w	8fa6 <usbdc_cb_ctl_req+0x3fe>
	if (length <= str_desc[0]) {
    8ea4:	7802      	ldrb	r2, [r0, #0]
    8ea6:	4294      	cmp	r4, r2
    8ea8:	d90d      	bls.n	8ec6 <usbdc_cb_ctl_req+0x31e>
	bool     need_zlp = !(length & (usbdc.ctrl_size - 1));
    8eaa:	3e01      	subs	r6, #1
    8eac:	4226      	tst	r6, r4
    8eae:	bf0c      	ite	eq
    8eb0:	2301      	moveq	r3, #1
    8eb2:	2300      	movne	r3, #0
		length = str_desc[0];
    8eb4:	4614      	mov	r4, r2
	if (ERR_NONE != usbdc_xfer(ep, str_desc, length, need_zlp)) {
    8eb6:	4622      	mov	r2, r4
    8eb8:	4628      	mov	r0, r5
    8eba:	4c3f      	ldr	r4, [pc, #252]	; (8fb8 <usbdc_cb_ctl_req+0x410>)
    8ebc:	47a0      	blx	r4
    8ebe:	fab0 f080 	clz	r0, r0
    8ec2:	0940      	lsrs	r0, r0, #5
    8ec4:	e688      	b.n	8bd8 <usbdc_cb_ctl_req+0x30>
		need_zlp = false;
    8ec6:	2300      	movs	r3, #0
    8ec8:	e7f5      	b.n	8eb6 <usbdc_cb_ctl_req+0x30e>
		*(uint8_t *)usbdc.ctrl_buf = usbdc.cfg_value;
    8eca:	4939      	ldr	r1, [pc, #228]	; (8fb0 <usbdc_cb_ctl_req+0x408>)
    8ecc:	694b      	ldr	r3, [r1, #20]
    8ece:	7eca      	ldrb	r2, [r1, #27]
    8ed0:	701a      	strb	r2, [r3, #0]
		usbdc_xfer(ep, usbdc.ctrl_buf, 1, false);
    8ed2:	2300      	movs	r3, #0
    8ed4:	2201      	movs	r2, #1
    8ed6:	6949      	ldr	r1, [r1, #20]
    8ed8:	4628      	mov	r0, r5
    8eda:	4c37      	ldr	r4, [pc, #220]	; (8fb8 <usbdc_cb_ctl_req+0x410>)
    8edc:	47a0      	blx	r4
		return true;
    8ede:	2001      	movs	r0, #1
    8ee0:	e67a      	b.n	8bd8 <usbdc_cb_ctl_req+0x30>
	switch (req->bmRequestType & USB_REQT_RECIP_MASK) {
    8ee2:	f003 031f 	and.w	r3, r3, #31
    8ee6:	2b01      	cmp	r3, #1
    8ee8:	d903      	bls.n	8ef2 <usbdc_cb_ctl_req+0x34a>
    8eea:	2b02      	cmp	r3, #2
    8eec:	d010      	beq.n	8f10 <usbdc_cb_ctl_req+0x368>
		return false;
    8eee:	2000      	movs	r0, #0
    8ef0:	e672      	b.n	8bd8 <usbdc_cb_ctl_req+0x30>
		st = 0;
    8ef2:	2300      	movs	r3, #0
    8ef4:	9300      	str	r3, [sp, #0]
	memcpy(usbdc.ctrl_buf, &st, 2);
    8ef6:	492e      	ldr	r1, [pc, #184]	; (8fb0 <usbdc_cb_ctl_req+0x408>)
    8ef8:	694b      	ldr	r3, [r1, #20]
    8efa:	f8bd 2000 	ldrh.w	r2, [sp]
    8efe:	801a      	strh	r2, [r3, #0]
	usbdc_xfer(ep, usbdc.ctrl_buf, 2, false);
    8f00:	2300      	movs	r3, #0
    8f02:	2202      	movs	r2, #2
    8f04:	6949      	ldr	r1, [r1, #20]
    8f06:	4628      	mov	r0, r5
    8f08:	4c2b      	ldr	r4, [pc, #172]	; (8fb8 <usbdc_cb_ctl_req+0x410>)
    8f0a:	47a0      	blx	r4
	return true;
    8f0c:	2001      	movs	r0, #1
    8f0e:	e663      	b.n	8bd8 <usbdc_cb_ctl_req+0x30>
		st = usb_d_ep_halt(req->wIndex & 0xFF, USB_EP_HALT_GET);
    8f10:	88a0      	ldrh	r0, [r4, #4]
    8f12:	2102      	movs	r1, #2
    8f14:	b2c0      	uxtb	r0, r0
    8f16:	4b2a      	ldr	r3, [pc, #168]	; (8fc0 <usbdc_cb_ctl_req+0x418>)
    8f18:	4798      	blx	r3
		if (st < 0) {
    8f1a:	2800      	cmp	r0, #0
    8f1c:	db03      	blt.n	8f26 <usbdc_cb_ctl_req+0x37e>
		st = st & 0x1;
    8f1e:	f000 0001 	and.w	r0, r0, #1
    8f22:	9000      	str	r0, [sp, #0]
    8f24:	e7e7      	b.n	8ef6 <usbdc_cb_ctl_req+0x34e>
			return false;
    8f26:	2000      	movs	r0, #0
    8f28:	e656      	b.n	8bd8 <usbdc_cb_ctl_req+0x30>
	if (!(usbdc.ifc_alt_map & (1 << req->wIndex))) {
    8f2a:	4b21      	ldr	r3, [pc, #132]	; (8fb0 <usbdc_cb_ctl_req+0x408>)
    8f2c:	7f5b      	ldrb	r3, [r3, #29]
    8f2e:	88a2      	ldrh	r2, [r4, #4]
    8f30:	4113      	asrs	r3, r2
    8f32:	f013 0f01 	tst.w	r3, #1
    8f36:	d012      	beq.n	8f5e <usbdc_cb_ctl_req+0x3b6>
	struct usbdf_driver *func = (struct usbdf_driver *)usbdc.func_list.head;
    8f38:	4b1d      	ldr	r3, [pc, #116]	; (8fb0 <usbdc_cb_ctl_req+0x408>)
    8f3a:	691d      	ldr	r5, [r3, #16]
	return false;
    8f3c:	2000      	movs	r0, #0
	while (NULL != func) {
    8f3e:	2d00      	cmp	r5, #0
    8f40:	f43f ae4a 	beq.w	8bd8 <usbdc_cb_ctl_req+0x30>
		if (0 > (rc = func->ctrl(func, USBDF_GET_IFACE, req))) {
    8f44:	2602      	movs	r6, #2
    8f46:	686b      	ldr	r3, [r5, #4]
    8f48:	4622      	mov	r2, r4
    8f4a:	4631      	mov	r1, r6
    8f4c:	4628      	mov	r0, r5
    8f4e:	4798      	blx	r3
    8f50:	2800      	cmp	r0, #0
    8f52:	da0f      	bge.n	8f74 <usbdc_cb_ctl_req+0x3cc>
			func = func->next;
    8f54:	682d      	ldr	r5, [r5, #0]
	while (NULL != func) {
    8f56:	2d00      	cmp	r5, #0
    8f58:	d1f5      	bne.n	8f46 <usbdc_cb_ctl_req+0x39e>
	return false;
    8f5a:	2000      	movs	r0, #0
    8f5c:	e63c      	b.n	8bd8 <usbdc_cb_ctl_req+0x30>
		usbdc.ctrl_buf[0] = 0;
    8f5e:	4914      	ldr	r1, [pc, #80]	; (8fb0 <usbdc_cb_ctl_req+0x408>)
    8f60:	694b      	ldr	r3, [r1, #20]
    8f62:	2000      	movs	r0, #0
    8f64:	7018      	strb	r0, [r3, #0]
		usbdc_xfer(0, usbdc.ctrl_buf, 1, false);
    8f66:	4603      	mov	r3, r0
    8f68:	2201      	movs	r2, #1
    8f6a:	6949      	ldr	r1, [r1, #20]
    8f6c:	4c12      	ldr	r4, [pc, #72]	; (8fb8 <usbdc_cb_ctl_req+0x410>)
    8f6e:	47a0      	blx	r4
		return true;
    8f70:	2001      	movs	r0, #1
    8f72:	e631      	b.n	8bd8 <usbdc_cb_ctl_req+0x30>
			usbdc.ctrl_buf[0] = (uint8_t)rc;
    8f74:	490e      	ldr	r1, [pc, #56]	; (8fb0 <usbdc_cb_ctl_req+0x408>)
    8f76:	694b      	ldr	r3, [r1, #20]
    8f78:	7018      	strb	r0, [r3, #0]
			usbdc_xfer(0, usbdc.ctrl_buf, 1, false);
    8f7a:	2300      	movs	r3, #0
    8f7c:	2201      	movs	r2, #1
    8f7e:	6949      	ldr	r1, [r1, #20]
    8f80:	4618      	mov	r0, r3
    8f82:	4c0d      	ldr	r4, [pc, #52]	; (8fb8 <usbdc_cb_ctl_req+0x410>)
    8f84:	47a0      	blx	r4
			return true;
    8f86:	2001      	movs	r0, #1
    8f88:	e626      	b.n	8bd8 <usbdc_cb_ctl_req+0x30>
		return true;
    8f8a:	2001      	movs	r0, #1
    8f8c:	e624      	b.n	8bd8 <usbdc_cb_ctl_req+0x30>
		return false;
    8f8e:	2000      	movs	r0, #0
    8f90:	e622      	b.n	8bd8 <usbdc_cb_ctl_req+0x30>
		return false;
    8f92:	2000      	movs	r0, #0
    8f94:	e620      	b.n	8bd8 <usbdc_cb_ctl_req+0x30>
		return false;
    8f96:	2000      	movs	r0, #0
    8f98:	e61e      	b.n	8bd8 <usbdc_cb_ctl_req+0x30>
		return false;
    8f9a:	2000      	movs	r0, #0
    8f9c:	e61c      	b.n	8bd8 <usbdc_cb_ctl_req+0x30>
		return false;
    8f9e:	2000      	movs	r0, #0
    8fa0:	e61a      	b.n	8bd8 <usbdc_cb_ctl_req+0x30>
		return false;
    8fa2:	2000      	movs	r0, #0
    8fa4:	e618      	b.n	8bd8 <usbdc_cb_ctl_req+0x30>
		return false;
    8fa6:	2000      	movs	r0, #0
    8fa8:	e616      	b.n	8bd8 <usbdc_cb_ctl_req+0x30>
			return false;
    8faa:	2000      	movs	r0, #0
    8fac:	e614      	b.n	8bd8 <usbdc_cb_ctl_req+0x30>
    8fae:	bf00      	nop
    8fb0:	2000151c 	.word	0x2000151c
    8fb4:	0000914d 	.word	0x0000914d
    8fb8:	00008b89 	.word	0x00008b89
    8fbc:	000091b5 	.word	0x000091b5
    8fc0:	00003151 	.word	0x00003151

00008fc4 <usbdc_register_handler>:

/**
 * \brief Register the handler
 */
void usbdc_register_handler(enum usbdc_handler_type type, const struct usbdc_handler *h)
{
    8fc4:	b508      	push	{r3, lr}
	switch (type) {
    8fc6:	2801      	cmp	r0, #1
    8fc8:	d007      	beq.n	8fda <usbdc_register_handler+0x16>
    8fca:	b110      	cbz	r0, 8fd2 <usbdc_register_handler+0xe>
    8fcc:	2802      	cmp	r0, #2
    8fce:	d008      	beq.n	8fe2 <usbdc_register_handler+0x1e>
    8fd0:	bd08      	pop	{r3, pc}
	case USBDC_HDL_SOF:
		list_insert_at_end(&usbdc.handlers.sof_list, (void *)h);
    8fd2:	4806      	ldr	r0, [pc, #24]	; (8fec <usbdc_register_handler+0x28>)
    8fd4:	4b06      	ldr	r3, [pc, #24]	; (8ff0 <usbdc_register_handler+0x2c>)
    8fd6:	4798      	blx	r3
		break;
    8fd8:	bd08      	pop	{r3, pc}
	case USBDC_HDL_REQ:
		list_insert_at_end(&usbdc.handlers.req_list, (void *)h);
    8fda:	4806      	ldr	r0, [pc, #24]	; (8ff4 <usbdc_register_handler+0x30>)
    8fdc:	4b04      	ldr	r3, [pc, #16]	; (8ff0 <usbdc_register_handler+0x2c>)
    8fde:	4798      	blx	r3
		break;
    8fe0:	bd08      	pop	{r3, pc}
	case USBDC_HDL_CHANGE:
		list_insert_at_end(&usbdc.handlers.change_list, (void *)h);
    8fe2:	4805      	ldr	r0, [pc, #20]	; (8ff8 <usbdc_register_handler+0x34>)
    8fe4:	4b02      	ldr	r3, [pc, #8]	; (8ff0 <usbdc_register_handler+0x2c>)
    8fe6:	4798      	blx	r3
    8fe8:	bd08      	pop	{r3, pc}
    8fea:	bf00      	nop
    8fec:	20001520 	.word	0x20001520
    8ff0:	0000322d 	.word	0x0000322d
    8ff4:	20001524 	.word	0x20001524
    8ff8:	20001528 	.word	0x20001528

00008ffc <usbdc_init>:

/**
 * \brief Initialize the USB device core driver
 */
int32_t usbdc_init(uint8_t *ctrl_buf)
{
    8ffc:	b538      	push	{r3, r4, r5, lr}
	ASSERT(ctrl_buf);
    8ffe:	4605      	mov	r5, r0
    9000:	f240 325f 	movw	r2, #863	; 0x35f
    9004:	490c      	ldr	r1, [pc, #48]	; (9038 <usbdc_init+0x3c>)
    9006:	3000      	adds	r0, #0
    9008:	bf18      	it	ne
    900a:	2001      	movne	r0, #1
    900c:	4b0b      	ldr	r3, [pc, #44]	; (903c <usbdc_init+0x40>)
    900e:	4798      	blx	r3

	int32_t rc;

	rc = usb_d_init();
    9010:	4b0b      	ldr	r3, [pc, #44]	; (9040 <usbdc_init+0x44>)
    9012:	4798      	blx	r3
	if (rc < 0) {
    9014:	2800      	cmp	r0, #0
    9016:	db0e      	blt.n	9036 <usbdc_init+0x3a>
		return rc;
	}

	memset(&usbdc, 0, sizeof(usbdc));
    9018:	4c0a      	ldr	r4, [pc, #40]	; (9044 <usbdc_init+0x48>)
    901a:	2220      	movs	r2, #32
    901c:	2100      	movs	r1, #0
    901e:	4620      	mov	r0, r4
    9020:	4b09      	ldr	r3, [pc, #36]	; (9048 <usbdc_init+0x4c>)
    9022:	4798      	blx	r3
	usbdc.ctrl_buf = ctrl_buf;
    9024:	6165      	str	r5, [r4, #20]
	usb_d_register_callback(USB_D_CB_SOF, (FUNC_PTR)usbd_sof_cb);
    9026:	4909      	ldr	r1, [pc, #36]	; (904c <usbdc_init+0x50>)
    9028:	2000      	movs	r0, #0
    902a:	4c09      	ldr	r4, [pc, #36]	; (9050 <usbdc_init+0x54>)
    902c:	47a0      	blx	r4
	usb_d_register_callback(USB_D_CB_EVENT, (FUNC_PTR)usbd_event_cb);
    902e:	4909      	ldr	r1, [pc, #36]	; (9054 <usbdc_init+0x58>)
    9030:	2001      	movs	r0, #1
    9032:	47a0      	blx	r4

	return 0;
    9034:	2000      	movs	r0, #0
}
    9036:	bd38      	pop	{r3, r4, r5, pc}
    9038:	00009a84 	.word	0x00009a84
    903c:	00003205 	.word	0x00003205
    9040:	00002eb9 	.word	0x00002eb9
    9044:	2000151c 	.word	0x2000151c
    9048:	000096ab 	.word	0x000096ab
    904c:	00008a7d 	.word	0x00008a7d
    9050:	00002f21 	.word	0x00002f21
    9054:	00008b69 	.word	0x00008b69

00009058 <usbdc_register_function>:
 * \brief Register/unregister function support of a USB device function
 *
 * Must be invoked when USB device is stopped.
 */
void usbdc_register_function(struct usbdf_driver *func)
{
    9058:	b508      	push	{r3, lr}
	list_insert_at_end(&usbdc.func_list, func);
    905a:	4601      	mov	r1, r0
    905c:	4801      	ldr	r0, [pc, #4]	; (9064 <usbdc_register_function+0xc>)
    905e:	4b02      	ldr	r3, [pc, #8]	; (9068 <usbdc_register_function+0x10>)
    9060:	4798      	blx	r3
    9062:	bd08      	pop	{r3, pc}
    9064:	2000152c 	.word	0x2000152c
    9068:	0000322d 	.word	0x0000322d

0000906c <usbdc_start>:

/**
 * \brief Start the USB device driver with specific descriptors set
 */
int32_t usbdc_start(struct usbd_descriptors *desces)
{
    906c:	b508      	push	{r3, lr}
	if (usbdc.state >= USBD_S_POWER) {
    906e:	4b0a      	ldr	r3, [pc, #40]	; (9098 <usbdc_start+0x2c>)
    9070:	7e9b      	ldrb	r3, [r3, #26]
    9072:	b95b      	cbnz	r3, 908c <usbdc_start+0x20>
		return ERR_BUSY;
	}

	if (desces) {
    9074:	b168      	cbz	r0, 9092 <usbdc_start+0x26>
		usbdc.desces.ls_fs = desces;
    9076:	4b08      	ldr	r3, [pc, #32]	; (9098 <usbdc_start+0x2c>)
    9078:	6018      	str	r0, [r3, #0]
#endif
	} else {
		return ERR_BAD_DATA;
	}

	usbdc.ctrl_size = desces->sod[7];
    907a:	6802      	ldr	r2, [r0, #0]
    907c:	79d2      	ldrb	r2, [r2, #7]
    907e:	771a      	strb	r2, [r3, #28]
	usbdc.state     = USBD_S_POWER;
    9080:	2201      	movs	r2, #1
    9082:	769a      	strb	r2, [r3, #26]
	usb_d_enable();
    9084:	4b05      	ldr	r3, [pc, #20]	; (909c <usbdc_start+0x30>)
    9086:	4798      	blx	r3
	return ERR_NONE;
    9088:	2000      	movs	r0, #0
    908a:	bd08      	pop	{r3, pc}
		return ERR_BUSY;
    908c:	f06f 0003 	mvn.w	r0, #3
    9090:	bd08      	pop	{r3, pc}
		return ERR_BAD_DATA;
    9092:	f06f 0008 	mvn.w	r0, #8
}
    9096:	bd08      	pop	{r3, pc}
    9098:	2000151c 	.word	0x2000151c
    909c:	00002f2d 	.word	0x00002f2d

000090a0 <usbdc_attach>:

/**
 * \brief Attach the USB device to host
 */
void usbdc_attach(void)
{
    90a0:	b508      	push	{r3, lr}
	usb_d_attach();
    90a2:	4b01      	ldr	r3, [pc, #4]	; (90a8 <usbdc_attach+0x8>)
    90a4:	4798      	blx	r3
    90a6:	bd08      	pop	{r3, pc}
    90a8:	00002f39 	.word	0x00002f39

000090ac <usbdc_get_ctrl_buffer>:
 * \brief Return USB Device endpoint0 buffer
 */
uint8_t *usbdc_get_ctrl_buffer(void)
{
	return usbdc.ctrl_buf;
}
    90ac:	4b01      	ldr	r3, [pc, #4]	; (90b4 <usbdc_get_ctrl_buffer+0x8>)
    90ae:	6958      	ldr	r0, [r3, #20]
    90b0:	4770      	bx	lr
    90b2:	bf00      	nop
    90b4:	2000151c 	.word	0x2000151c

000090b8 <usbdc_get_state>:
/**
 * \brief Return current USB state
 */
uint8_t usbdc_get_state(void)
{
	if (usbdc.state & USBD_S_SUSPEND) {
    90b8:	4b03      	ldr	r3, [pc, #12]	; (90c8 <usbdc_get_state+0x10>)
    90ba:	7e98      	ldrb	r0, [r3, #26]
    90bc:	f000 0310 	and.w	r3, r0, #16
		return USBD_S_SUSPEND;
    90c0:	2b00      	cmp	r3, #0
	}
	return usbdc.state;
}
    90c2:	bf18      	it	ne
    90c4:	2010      	movne	r0, #16
    90c6:	4770      	bx	lr
    90c8:	2000151c 	.word	0x2000151c

000090cc <usb_find_desc>:

uint8_t *usb_find_desc(uint8_t *desc, uint8_t *eof, uint8_t type)
{
	_param_error_check(desc && eof && (desc < eof));

	while (desc < eof) {
    90cc:	4288      	cmp	r0, r1
    90ce:	d214      	bcs.n	90fa <usb_find_desc+0x2e>
	return desc[0];
    90d0:	7803      	ldrb	r3, [r0, #0]
		_desc_len_check();
    90d2:	2b01      	cmp	r3, #1
    90d4:	d913      	bls.n	90fe <usb_find_desc+0x32>
{
    90d6:	b410      	push	{r4}
		if (type == usb_desc_type(desc)) {
    90d8:	7844      	ldrb	r4, [r0, #1]
    90da:	4294      	cmp	r4, r2
    90dc:	d00a      	beq.n	90f4 <usb_find_desc+0x28>
	return (desc + usb_desc_len(desc));
    90de:	4418      	add	r0, r3
	while (desc < eof) {
    90e0:	4281      	cmp	r1, r0
    90e2:	d906      	bls.n	90f2 <usb_find_desc+0x26>
	return desc[0];
    90e4:	7803      	ldrb	r3, [r0, #0]
		_desc_len_check();
    90e6:	2b01      	cmp	r3, #1
    90e8:	d90b      	bls.n	9102 <usb_find_desc+0x36>
	return desc[1];
    90ea:	7844      	ldrb	r4, [r0, #1]
		if (type == usb_desc_type(desc)) {
    90ec:	4294      	cmp	r4, r2
    90ee:	d1f6      	bne.n	90de <usb_find_desc+0x12>
    90f0:	e000      	b.n	90f4 <usb_find_desc+0x28>
			return desc;
		}
		desc = usb_desc_next(desc);
	}
	return NULL;
    90f2:	2000      	movs	r0, #0
}
    90f4:	f85d 4b04 	ldr.w	r4, [sp], #4
    90f8:	4770      	bx	lr
	return NULL;
    90fa:	2000      	movs	r0, #0
    90fc:	4770      	bx	lr
		_desc_len_check();
    90fe:	2000      	movs	r0, #0
    9100:	4770      	bx	lr
    9102:	2000      	movs	r0, #0
    9104:	e7f6      	b.n	90f4 <usb_find_desc+0x28>

00009106 <usb_find_ep_desc>:

uint8_t *usb_find_ep_desc(uint8_t *desc, uint8_t *eof)
{
	_param_error_check(desc && eof && (desc < eof));

	while (desc < eof) {
    9106:	4288      	cmp	r0, r1
    9108:	d216      	bcs.n	9138 <usb_find_ep_desc+0x32>
	return desc[0];
    910a:	7803      	ldrb	r3, [r0, #0]
		_desc_len_check();
    910c:	2b01      	cmp	r3, #1
    910e:	d915      	bls.n	913c <usb_find_ep_desc+0x36>
	return desc[1];
    9110:	7842      	ldrb	r2, [r0, #1]
		if (USB_DT_INTERFACE == usb_desc_type(desc)) {
    9112:	2a04      	cmp	r2, #4
    9114:	d014      	beq.n	9140 <usb_find_ep_desc+0x3a>
			break;
		}
		if (USB_DT_ENDPOINT == usb_desc_type(desc)) {
    9116:	2a05      	cmp	r2, #5
    9118:	d00b      	beq.n	9132 <usb_find_ep_desc+0x2c>
	return (desc + usb_desc_len(desc));
    911a:	4418      	add	r0, r3
	while (desc < eof) {
    911c:	4281      	cmp	r1, r0
    911e:	d909      	bls.n	9134 <usb_find_ep_desc+0x2e>
	return desc[0];
    9120:	7803      	ldrb	r3, [r0, #0]
		_desc_len_check();
    9122:	2b01      	cmp	r3, #1
    9124:	d90e      	bls.n	9144 <usb_find_ep_desc+0x3e>
	return desc[1];
    9126:	7842      	ldrb	r2, [r0, #1]
		if (USB_DT_INTERFACE == usb_desc_type(desc)) {
    9128:	2a04      	cmp	r2, #4
    912a:	d00d      	beq.n	9148 <usb_find_ep_desc+0x42>
		if (USB_DT_ENDPOINT == usb_desc_type(desc)) {
    912c:	2a05      	cmp	r2, #5
    912e:	d1f4      	bne.n	911a <usb_find_ep_desc+0x14>
    9130:	e00b      	b.n	914a <usb_find_ep_desc+0x44>
    9132:	4770      	bx	lr
			return desc;
		}
		desc = usb_desc_next(desc);
	}
	return NULL;
    9134:	2000      	movs	r0, #0
    9136:	4770      	bx	lr
    9138:	2000      	movs	r0, #0
    913a:	4770      	bx	lr
		_desc_len_check();
    913c:	2000      	movs	r0, #0
    913e:	4770      	bx	lr
	return NULL;
    9140:	2000      	movs	r0, #0
    9142:	4770      	bx	lr
		_desc_len_check();
    9144:	2000      	movs	r0, #0
    9146:	4770      	bx	lr
	return NULL;
    9148:	2000      	movs	r0, #0
}
    914a:	4770      	bx	lr

0000914c <usb_find_cfg_desc>:

uint8_t *usb_find_cfg_desc(uint8_t *desc, uint8_t *eof, uint8_t cfg_value)
{
    914c:	b538      	push	{r3, r4, r5, lr}
    914e:	460c      	mov	r4, r1
    9150:	4615      	mov	r5, r2
	_param_error_check(desc && eof && (desc < eof));

	desc = usb_find_desc(desc, eof, USB_DT_CONFIG);
    9152:	2202      	movs	r2, #2
    9154:	4b16      	ldr	r3, [pc, #88]	; (91b0 <usb_find_cfg_desc+0x64>)
    9156:	4798      	blx	r3
	if (!desc) {
    9158:	4603      	mov	r3, r0
    915a:	b1e8      	cbz	r0, 9198 <usb_find_cfg_desc+0x4c>
		return NULL;
	}
	while (desc < eof) {
    915c:	4284      	cmp	r4, r0
    915e:	d91d      	bls.n	919c <usb_find_cfg_desc+0x50>
		_desc_len_check();
    9160:	7802      	ldrb	r2, [r0, #0]
    9162:	2a01      	cmp	r2, #1
    9164:	d91c      	bls.n	91a0 <usb_find_cfg_desc+0x54>
		if (desc[1] != USB_DT_CONFIG) {
    9166:	7842      	ldrb	r2, [r0, #1]
    9168:	2a02      	cmp	r2, #2
    916a:	d11b      	bne.n	91a4 <usb_find_cfg_desc+0x58>
			break;
		}
		if (desc[5] == cfg_value) {
    916c:	7942      	ldrb	r2, [r0, #5]
    916e:	42aa      	cmp	r2, r5
    9170:	d012      	beq.n	9198 <usb_find_cfg_desc+0x4c>
	return (ptr[0] + (ptr[1] << 8));
    9172:	78d9      	ldrb	r1, [r3, #3]
    9174:	789a      	ldrb	r2, [r3, #2]
    9176:	eb02 2201 	add.w	r2, r2, r1, lsl #8
 *  \param[in] cfg_desc Byte pointer to the descriptor start address
 *  \return Byte pointer to descriptor after configuration end
 */
static inline uint8_t *usb_cfg_desc_next(uint8_t *cfg_desc)
{
	return (cfg_desc + usb_cfg_desc_total_len(cfg_desc));
    917a:	fa13 f382 	uxtah	r3, r3, r2
	while (desc < eof) {
    917e:	429c      	cmp	r4, r3
    9180:	d909      	bls.n	9196 <usb_find_cfg_desc+0x4a>
		_desc_len_check();
    9182:	781a      	ldrb	r2, [r3, #0]
    9184:	2a01      	cmp	r2, #1
    9186:	d90f      	bls.n	91a8 <usb_find_cfg_desc+0x5c>
		if (desc[1] != USB_DT_CONFIG) {
    9188:	785a      	ldrb	r2, [r3, #1]
    918a:	2a02      	cmp	r2, #2
    918c:	d10e      	bne.n	91ac <usb_find_cfg_desc+0x60>
		if (desc[5] == cfg_value) {
    918e:	795a      	ldrb	r2, [r3, #5]
    9190:	42aa      	cmp	r2, r5
    9192:	d1ee      	bne.n	9172 <usb_find_cfg_desc+0x26>
    9194:	e000      	b.n	9198 <usb_find_cfg_desc+0x4c>
			return desc;
		}
		desc = usb_cfg_desc_next(desc);
	}
	return NULL;
    9196:	2300      	movs	r3, #0
}
    9198:	4618      	mov	r0, r3
    919a:	bd38      	pop	{r3, r4, r5, pc}
	return NULL;
    919c:	2300      	movs	r3, #0
    919e:	e7fb      	b.n	9198 <usb_find_cfg_desc+0x4c>
		_desc_len_check();
    91a0:	2300      	movs	r3, #0
    91a2:	e7f9      	b.n	9198 <usb_find_cfg_desc+0x4c>
	return NULL;
    91a4:	2300      	movs	r3, #0
    91a6:	e7f7      	b.n	9198 <usb_find_cfg_desc+0x4c>
		_desc_len_check();
    91a8:	2300      	movs	r3, #0
    91aa:	e7f5      	b.n	9198 <usb_find_cfg_desc+0x4c>
	return NULL;
    91ac:	2300      	movs	r3, #0
    91ae:	e7f3      	b.n	9198 <usb_find_cfg_desc+0x4c>
    91b0:	000090cd 	.word	0x000090cd

000091b4 <usb_find_str_desc>:
{
	uint8_t i;

	_param_error_check(desc && eof && (desc < eof));

	for (i = 0; desc < eof;) {
    91b4:	4288      	cmp	r0, r1
    91b6:	d217      	bcs.n	91e8 <usb_find_str_desc+0x34>
{
    91b8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    91bc:	460d      	mov	r5, r1
    91be:	4616      	mov	r6, r2
	for (i = 0; desc < eof;) {
    91c0:	2400      	movs	r4, #0
		desc = usb_find_desc(desc, eof, USB_DT_STRING);
    91c2:	f04f 0803 	mov.w	r8, #3
    91c6:	4f0c      	ldr	r7, [pc, #48]	; (91f8 <usb_find_str_desc+0x44>)
    91c8:	4642      	mov	r2, r8
    91ca:	4629      	mov	r1, r5
    91cc:	47b8      	blx	r7
		if (desc) {
    91ce:	4603      	mov	r3, r0
    91d0:	b170      	cbz	r0, 91f0 <usb_find_str_desc+0x3c>
	return desc[0];
    91d2:	7800      	ldrb	r0, [r0, #0]
			_desc_len_check();
    91d4:	2801      	cmp	r0, #1
    91d6:	d90a      	bls.n	91ee <usb_find_str_desc+0x3a>
			if (i == str_index) {
    91d8:	42a6      	cmp	r6, r4
    91da:	d009      	beq.n	91f0 <usb_find_str_desc+0x3c>
	return (desc + usb_desc_len(desc));
    91dc:	4418      	add	r0, r3
    91de:	3401      	adds	r4, #1
	for (i = 0; desc < eof;) {
    91e0:	4285      	cmp	r5, r0
    91e2:	d8f1      	bhi.n	91c8 <usb_find_str_desc+0x14>
			desc = usb_desc_next(desc);
		} else {
			return NULL;
		}
	}
	return NULL;
    91e4:	2300      	movs	r3, #0
    91e6:	e003      	b.n	91f0 <usb_find_str_desc+0x3c>
    91e8:	2300      	movs	r3, #0
}
    91ea:	4618      	mov	r0, r3
    91ec:	4770      	bx	lr
			_desc_len_check();
    91ee:	2300      	movs	r3, #0
}
    91f0:	4618      	mov	r0, r3
    91f2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    91f6:	bf00      	nop
    91f8:	000090cd 	.word	0x000090cd

000091fc <button_on_PA16_pressed>:

format_t formats[SAVED_CONF];
machine_configuration_t machine_confs[CHANNEL_NUMBER];

static void button_on_PA16_pressed(void)
{
    91fc:	b508      	push	{r3, lr}
	((Port *)hw)->Group[submodule_index].OUTTGL.reg = mask;
    91fe:	f44f 2280 	mov.w	r2, #262144	; 0x40000
    9202:	4b08      	ldr	r3, [pc, #32]	; (9224 <button_on_PA16_pressed+0x28>)
    9204:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
	gpio_toggle_pin_level(LED0);
	//xTaskResumeFromISR(xRoutineTask0);
	xTaskResumeFromISR(xRoutineTask1);
    9208:	4b07      	ldr	r3, [pc, #28]	; (9228 <button_on_PA16_pressed+0x2c>)
    920a:	6818      	ldr	r0, [r3, #0]
    920c:	4b07      	ldr	r3, [pc, #28]	; (922c <button_on_PA16_pressed+0x30>)
    920e:	4798      	blx	r3
	portYIELD_FROM_ISR( pdTRUE);
    9210:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    9214:	4b06      	ldr	r3, [pc, #24]	; (9230 <button_on_PA16_pressed+0x34>)
    9216:	601a      	str	r2, [r3, #0]
    9218:	f3bf 8f4f 	dsb	sy
    921c:	f3bf 8f6f 	isb	sy
    9220:	bd08      	pop	{r3, pc}
    9222:	bf00      	nop
    9224:	41008000 	.word	0x41008000
    9228:	20001688 	.word	0x20001688
    922c:	00007b01 	.word	0x00007b01
    9230:	e000ed04 	.word	0xe000ed04

00009234 <main>:
}


int main(void)
{
    9234:	b508      	push	{r3, lr}
	atmel_start_init();
    9236:	4b23      	ldr	r3, [pc, #140]	; (92c4 <main+0x90>)
    9238:	4798      	blx	r3
	//cdcd_acm_example();
	start_sd();
    923a:	4b23      	ldr	r3, [pc, #140]	; (92c8 <main+0x94>)
    923c:	4798      	blx	r3
		pwm_disable(&PWM_0);
    923e:	4823      	ldr	r0, [pc, #140]	; (92cc <main+0x98>)
    9240:	4e23      	ldr	r6, [pc, #140]	; (92d0 <main+0x9c>)
    9242:	47b0      	blx	r6
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    9244:	4c23      	ldr	r4, [pc, #140]	; (92d4 <main+0xa0>)
    9246:	f44f 7200 	mov.w	r2, #512	; 0x200
    924a:	f8c4 2088 	str.w	r2, [r4, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    924e:	4b22      	ldr	r3, [pc, #136]	; (92d8 <main+0xa4>)
    9250:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
    9254:	f04f 4540 	mov.w	r5, #3221225472	; 0xc0000000
    9258:	f8c4 50a8 	str.w	r5, [r4, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    925c:	f894 30c9 	ldrb.w	r3, [r4, #201]	; 0xc9
	tmp &= ~PORT_PINCFG_PMUXEN;
    9260:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    9264:	f884 30c9 	strb.w	r3, [r4, #201]	; 0xc9
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    9268:	f8c4 2094 	str.w	r2, [r4, #148]	; 0x94
		pwm_disable(&PWM_1);
    926c:	481b      	ldr	r0, [pc, #108]	; (92dc <main+0xa8>)
    926e:	47b0      	blx	r6
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    9270:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    9274:	f8c4 2088 	str.w	r2, [r4, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    9278:	4b19      	ldr	r3, [pc, #100]	; (92e0 <main+0xac>)
    927a:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
    927e:	f8c4 50a8 	str.w	r5, [r4, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    9282:	f894 30cf 	ldrb.w	r3, [r4, #207]	; 0xcf
	tmp &= ~PORT_PINCFG_PMUXEN;
    9286:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    928a:	f884 30cf 	strb.w	r3, [r4, #207]	; 0xcf
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    928e:	f8c4 2094 	str.w	r2, [r4, #148]	; 0x94
	
	close_under(0);
	close_under(1);
	
	machine_confs[0].index_gun=0;
    9292:	4b14      	ldr	r3, [pc, #80]	; (92e4 <main+0xb0>)
    9294:	2200      	movs	r2, #0
    9296:	701a      	strb	r2, [r3, #0]
	machine_confs[0].active=3;
    9298:	2203      	movs	r2, #3
    929a:	705a      	strb	r2, [r3, #1]
	machine_confs[1].index_gun=1;
    929c:	2201      	movs	r2, #1
    929e:	70da      	strb	r2, [r3, #3]
	machine_confs[1].active=4;
    92a0:	2204      	movs	r2, #4
    92a2:	711a      	strb	r2, [r3, #4]
	
	ext_irq_register(PIN_PA16, button_on_PA16_pressed);
    92a4:	4910      	ldr	r1, [pc, #64]	; (92e8 <main+0xb4>)
    92a6:	2010      	movs	r0, #16
    92a8:	4b10      	ldr	r3, [pc, #64]	; (92ec <main+0xb8>)
    92aa:	4798      	blx	r3
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    92ac:	22a0      	movs	r2, #160	; 0xa0
    92ae:	4b10      	ldr	r3, [pc, #64]	; (92f0 <main+0xbc>)
    92b0:	f883 230c 	strb.w	r2, [r3, #780]	; 0x30c
	NVIC_SetPriority(EIC_0_IRQn, 5 );
	SPI_0_example();
    92b4:	4b0f      	ldr	r3, [pc, #60]	; (92f4 <main+0xc0>)
    92b6:	4798      	blx	r3

	start_routine();
    92b8:	4b0f      	ldr	r3, [pc, #60]	; (92f8 <main+0xc4>)
    92ba:	4798      	blx	r3
	vTaskStartScheduler();
    92bc:	4b0f      	ldr	r3, [pc, #60]	; (92fc <main+0xc8>)
    92be:	4798      	blx	r3
    92c0:	e7fe      	b.n	92c0 <main+0x8c>
    92c2:	bf00      	nop
    92c4:	000002d1 	.word	0x000002d1
    92c8:	00005e99 	.word	0x00005e99
    92cc:	200015c0 	.word	0x200015c0
    92d0:	000028cd 	.word	0x000028cd
    92d4:	41008000 	.word	0x41008000
    92d8:	40000200 	.word	0x40000200
    92dc:	2000165c 	.word	0x2000165c
    92e0:	40008000 	.word	0x40008000
    92e4:	200023c8 	.word	0x200023c8
    92e8:	000091fd 	.word	0x000091fd
    92ec:	00002459 	.word	0x00002459
    92f0:	e000e100 	.word	0xe000e100
    92f4:	00006ba5 	.word	0x00006ba5
    92f8:	00005ccd 	.word	0x00005ccd
    92fc:	00007bb9 	.word	0x00007bb9

00009300 <cdc_device_acm_init>:

/**
 * \brief CDC ACM Init
 */
void cdc_device_acm_init(void)
{
    9300:	b508      	push	{r3, lr}
	/* usb stack init */
	usbdc_init(ctrl_buffer);
    9302:	4805      	ldr	r0, [pc, #20]	; (9318 <cdc_device_acm_init+0x18>)
    9304:	4b05      	ldr	r3, [pc, #20]	; (931c <cdc_device_acm_init+0x1c>)
    9306:	4798      	blx	r3

	/* usbdc_register_funcion inside */
	cdcdf_acm_init();
    9308:	4b05      	ldr	r3, [pc, #20]	; (9320 <cdc_device_acm_init+0x20>)
    930a:	4798      	blx	r3

	usbdc_start(single_desc);
    930c:	4805      	ldr	r0, [pc, #20]	; (9324 <cdc_device_acm_init+0x24>)
    930e:	4b06      	ldr	r3, [pc, #24]	; (9328 <cdc_device_acm_init+0x28>)
    9310:	4798      	blx	r3
	usbdc_attach();
    9312:	4b06      	ldr	r3, [pc, #24]	; (932c <cdc_device_acm_init+0x2c>)
    9314:	4798      	blx	r3
    9316:	bd08      	pop	{r3, pc}
    9318:	2000157c 	.word	0x2000157c
    931c:	00008ffd 	.word	0x00008ffd
    9320:	000089ad 	.word	0x000089ad
    9324:	2000003c 	.word	0x2000003c
    9328:	0000906d 	.word	0x0000906d
    932c:	000090a1 	.word	0x000090a1

00009330 <usb_init>:

	cdcdf_acm_register_callback(CDCDF_ACM_CB_STATE_C, (FUNC_PTR)usb_device_cb_state_c);
}

void usb_init(void)
{
    9330:	b508      	push	{r3, lr}

	cdc_device_acm_init();
    9332:	4b01      	ldr	r3, [pc, #4]	; (9338 <usb_init+0x8>)
    9334:	4798      	blx	r3
    9336:	bd08      	pop	{r3, pc}
    9338:	00009301 	.word	0x00009301

0000933c <__aeabi_uldivmod>:
    933c:	b953      	cbnz	r3, 9354 <__aeabi_uldivmod+0x18>
    933e:	b94a      	cbnz	r2, 9354 <__aeabi_uldivmod+0x18>
    9340:	2900      	cmp	r1, #0
    9342:	bf08      	it	eq
    9344:	2800      	cmpeq	r0, #0
    9346:	bf1c      	itt	ne
    9348:	f04f 31ff 	movne.w	r1, #4294967295
    934c:	f04f 30ff 	movne.w	r0, #4294967295
    9350:	f000 b97a 	b.w	9648 <__aeabi_idiv0>
    9354:	f1ad 0c08 	sub.w	ip, sp, #8
    9358:	e96d ce04 	strd	ip, lr, [sp, #-16]!
    935c:	f000 f806 	bl	936c <__udivmoddi4>
    9360:	f8dd e004 	ldr.w	lr, [sp, #4]
    9364:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    9368:	b004      	add	sp, #16
    936a:	4770      	bx	lr

0000936c <__udivmoddi4>:
    936c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    9370:	468c      	mov	ip, r1
    9372:	460d      	mov	r5, r1
    9374:	4604      	mov	r4, r0
    9376:	9e08      	ldr	r6, [sp, #32]
    9378:	2b00      	cmp	r3, #0
    937a:	d151      	bne.n	9420 <__udivmoddi4+0xb4>
    937c:	428a      	cmp	r2, r1
    937e:	4617      	mov	r7, r2
    9380:	d96d      	bls.n	945e <__udivmoddi4+0xf2>
    9382:	fab2 fe82 	clz	lr, r2
    9386:	f1be 0f00 	cmp.w	lr, #0
    938a:	d00b      	beq.n	93a4 <__udivmoddi4+0x38>
    938c:	f1ce 0c20 	rsb	ip, lr, #32
    9390:	fa01 f50e 	lsl.w	r5, r1, lr
    9394:	fa20 fc0c 	lsr.w	ip, r0, ip
    9398:	fa02 f70e 	lsl.w	r7, r2, lr
    939c:	ea4c 0c05 	orr.w	ip, ip, r5
    93a0:	fa00 f40e 	lsl.w	r4, r0, lr
    93a4:	ea4f 4a17 	mov.w	sl, r7, lsr #16
    93a8:	0c25      	lsrs	r5, r4, #16
    93aa:	fbbc f8fa 	udiv	r8, ip, sl
    93ae:	fa1f f987 	uxth.w	r9, r7
    93b2:	fb0a cc18 	mls	ip, sl, r8, ip
    93b6:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
    93ba:	fb08 f309 	mul.w	r3, r8, r9
    93be:	42ab      	cmp	r3, r5
    93c0:	d90a      	bls.n	93d8 <__udivmoddi4+0x6c>
    93c2:	19ed      	adds	r5, r5, r7
    93c4:	f108 32ff 	add.w	r2, r8, #4294967295
    93c8:	f080 8123 	bcs.w	9612 <__udivmoddi4+0x2a6>
    93cc:	42ab      	cmp	r3, r5
    93ce:	f240 8120 	bls.w	9612 <__udivmoddi4+0x2a6>
    93d2:	f1a8 0802 	sub.w	r8, r8, #2
    93d6:	443d      	add	r5, r7
    93d8:	1aed      	subs	r5, r5, r3
    93da:	b2a4      	uxth	r4, r4
    93dc:	fbb5 f0fa 	udiv	r0, r5, sl
    93e0:	fb0a 5510 	mls	r5, sl, r0, r5
    93e4:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
    93e8:	fb00 f909 	mul.w	r9, r0, r9
    93ec:	45a1      	cmp	r9, r4
    93ee:	d909      	bls.n	9404 <__udivmoddi4+0x98>
    93f0:	19e4      	adds	r4, r4, r7
    93f2:	f100 33ff 	add.w	r3, r0, #4294967295
    93f6:	f080 810a 	bcs.w	960e <__udivmoddi4+0x2a2>
    93fa:	45a1      	cmp	r9, r4
    93fc:	f240 8107 	bls.w	960e <__udivmoddi4+0x2a2>
    9400:	3802      	subs	r0, #2
    9402:	443c      	add	r4, r7
    9404:	eba4 0409 	sub.w	r4, r4, r9
    9408:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
    940c:	2100      	movs	r1, #0
    940e:	2e00      	cmp	r6, #0
    9410:	d061      	beq.n	94d6 <__udivmoddi4+0x16a>
    9412:	fa24 f40e 	lsr.w	r4, r4, lr
    9416:	2300      	movs	r3, #0
    9418:	6034      	str	r4, [r6, #0]
    941a:	6073      	str	r3, [r6, #4]
    941c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    9420:	428b      	cmp	r3, r1
    9422:	d907      	bls.n	9434 <__udivmoddi4+0xc8>
    9424:	2e00      	cmp	r6, #0
    9426:	d054      	beq.n	94d2 <__udivmoddi4+0x166>
    9428:	2100      	movs	r1, #0
    942a:	e886 0021 	stmia.w	r6, {r0, r5}
    942e:	4608      	mov	r0, r1
    9430:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    9434:	fab3 f183 	clz	r1, r3
    9438:	2900      	cmp	r1, #0
    943a:	f040 808e 	bne.w	955a <__udivmoddi4+0x1ee>
    943e:	42ab      	cmp	r3, r5
    9440:	d302      	bcc.n	9448 <__udivmoddi4+0xdc>
    9442:	4282      	cmp	r2, r0
    9444:	f200 80fa 	bhi.w	963c <__udivmoddi4+0x2d0>
    9448:	1a84      	subs	r4, r0, r2
    944a:	eb65 0503 	sbc.w	r5, r5, r3
    944e:	2001      	movs	r0, #1
    9450:	46ac      	mov	ip, r5
    9452:	2e00      	cmp	r6, #0
    9454:	d03f      	beq.n	94d6 <__udivmoddi4+0x16a>
    9456:	e886 1010 	stmia.w	r6, {r4, ip}
    945a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    945e:	b912      	cbnz	r2, 9466 <__udivmoddi4+0xfa>
    9460:	2701      	movs	r7, #1
    9462:	fbb7 f7f2 	udiv	r7, r7, r2
    9466:	fab7 fe87 	clz	lr, r7
    946a:	f1be 0f00 	cmp.w	lr, #0
    946e:	d134      	bne.n	94da <__udivmoddi4+0x16e>
    9470:	1beb      	subs	r3, r5, r7
    9472:	0c3a      	lsrs	r2, r7, #16
    9474:	fa1f fc87 	uxth.w	ip, r7
    9478:	2101      	movs	r1, #1
    947a:	fbb3 f8f2 	udiv	r8, r3, r2
    947e:	0c25      	lsrs	r5, r4, #16
    9480:	fb02 3318 	mls	r3, r2, r8, r3
    9484:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
    9488:	fb0c f308 	mul.w	r3, ip, r8
    948c:	42ab      	cmp	r3, r5
    948e:	d907      	bls.n	94a0 <__udivmoddi4+0x134>
    9490:	19ed      	adds	r5, r5, r7
    9492:	f108 30ff 	add.w	r0, r8, #4294967295
    9496:	d202      	bcs.n	949e <__udivmoddi4+0x132>
    9498:	42ab      	cmp	r3, r5
    949a:	f200 80d1 	bhi.w	9640 <__udivmoddi4+0x2d4>
    949e:	4680      	mov	r8, r0
    94a0:	1aed      	subs	r5, r5, r3
    94a2:	b2a3      	uxth	r3, r4
    94a4:	fbb5 f0f2 	udiv	r0, r5, r2
    94a8:	fb02 5510 	mls	r5, r2, r0, r5
    94ac:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
    94b0:	fb0c fc00 	mul.w	ip, ip, r0
    94b4:	45a4      	cmp	ip, r4
    94b6:	d907      	bls.n	94c8 <__udivmoddi4+0x15c>
    94b8:	19e4      	adds	r4, r4, r7
    94ba:	f100 33ff 	add.w	r3, r0, #4294967295
    94be:	d202      	bcs.n	94c6 <__udivmoddi4+0x15a>
    94c0:	45a4      	cmp	ip, r4
    94c2:	f200 80b8 	bhi.w	9636 <__udivmoddi4+0x2ca>
    94c6:	4618      	mov	r0, r3
    94c8:	eba4 040c 	sub.w	r4, r4, ip
    94cc:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
    94d0:	e79d      	b.n	940e <__udivmoddi4+0xa2>
    94d2:	4631      	mov	r1, r6
    94d4:	4630      	mov	r0, r6
    94d6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    94da:	f1ce 0420 	rsb	r4, lr, #32
    94de:	fa05 f30e 	lsl.w	r3, r5, lr
    94e2:	fa07 f70e 	lsl.w	r7, r7, lr
    94e6:	fa20 f804 	lsr.w	r8, r0, r4
    94ea:	0c3a      	lsrs	r2, r7, #16
    94ec:	fa25 f404 	lsr.w	r4, r5, r4
    94f0:	ea48 0803 	orr.w	r8, r8, r3
    94f4:	fbb4 f1f2 	udiv	r1, r4, r2
    94f8:	ea4f 4518 	mov.w	r5, r8, lsr #16
    94fc:	fb02 4411 	mls	r4, r2, r1, r4
    9500:	fa1f fc87 	uxth.w	ip, r7
    9504:	ea45 4504 	orr.w	r5, r5, r4, lsl #16
    9508:	fb01 f30c 	mul.w	r3, r1, ip
    950c:	42ab      	cmp	r3, r5
    950e:	fa00 f40e 	lsl.w	r4, r0, lr
    9512:	d909      	bls.n	9528 <__udivmoddi4+0x1bc>
    9514:	19ed      	adds	r5, r5, r7
    9516:	f101 30ff 	add.w	r0, r1, #4294967295
    951a:	f080 808a 	bcs.w	9632 <__udivmoddi4+0x2c6>
    951e:	42ab      	cmp	r3, r5
    9520:	f240 8087 	bls.w	9632 <__udivmoddi4+0x2c6>
    9524:	3902      	subs	r1, #2
    9526:	443d      	add	r5, r7
    9528:	1aeb      	subs	r3, r5, r3
    952a:	fa1f f588 	uxth.w	r5, r8
    952e:	fbb3 f0f2 	udiv	r0, r3, r2
    9532:	fb02 3310 	mls	r3, r2, r0, r3
    9536:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
    953a:	fb00 f30c 	mul.w	r3, r0, ip
    953e:	42ab      	cmp	r3, r5
    9540:	d907      	bls.n	9552 <__udivmoddi4+0x1e6>
    9542:	19ed      	adds	r5, r5, r7
    9544:	f100 38ff 	add.w	r8, r0, #4294967295
    9548:	d26f      	bcs.n	962a <__udivmoddi4+0x2be>
    954a:	42ab      	cmp	r3, r5
    954c:	d96d      	bls.n	962a <__udivmoddi4+0x2be>
    954e:	3802      	subs	r0, #2
    9550:	443d      	add	r5, r7
    9552:	1aeb      	subs	r3, r5, r3
    9554:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
    9558:	e78f      	b.n	947a <__udivmoddi4+0x10e>
    955a:	f1c1 0720 	rsb	r7, r1, #32
    955e:	fa22 f807 	lsr.w	r8, r2, r7
    9562:	408b      	lsls	r3, r1
    9564:	fa05 f401 	lsl.w	r4, r5, r1
    9568:	ea48 0303 	orr.w	r3, r8, r3
    956c:	fa20 fe07 	lsr.w	lr, r0, r7
    9570:	ea4f 4c13 	mov.w	ip, r3, lsr #16
    9574:	40fd      	lsrs	r5, r7
    9576:	ea4e 0e04 	orr.w	lr, lr, r4
    957a:	fbb5 f9fc 	udiv	r9, r5, ip
    957e:	ea4f 441e 	mov.w	r4, lr, lsr #16
    9582:	fb0c 5519 	mls	r5, ip, r9, r5
    9586:	fa1f f883 	uxth.w	r8, r3
    958a:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
    958e:	fb09 f408 	mul.w	r4, r9, r8
    9592:	42ac      	cmp	r4, r5
    9594:	fa02 f201 	lsl.w	r2, r2, r1
    9598:	fa00 fa01 	lsl.w	sl, r0, r1
    959c:	d908      	bls.n	95b0 <__udivmoddi4+0x244>
    959e:	18ed      	adds	r5, r5, r3
    95a0:	f109 30ff 	add.w	r0, r9, #4294967295
    95a4:	d243      	bcs.n	962e <__udivmoddi4+0x2c2>
    95a6:	42ac      	cmp	r4, r5
    95a8:	d941      	bls.n	962e <__udivmoddi4+0x2c2>
    95aa:	f1a9 0902 	sub.w	r9, r9, #2
    95ae:	441d      	add	r5, r3
    95b0:	1b2d      	subs	r5, r5, r4
    95b2:	fa1f fe8e 	uxth.w	lr, lr
    95b6:	fbb5 f0fc 	udiv	r0, r5, ip
    95ba:	fb0c 5510 	mls	r5, ip, r0, r5
    95be:	ea4e 4405 	orr.w	r4, lr, r5, lsl #16
    95c2:	fb00 f808 	mul.w	r8, r0, r8
    95c6:	45a0      	cmp	r8, r4
    95c8:	d907      	bls.n	95da <__udivmoddi4+0x26e>
    95ca:	18e4      	adds	r4, r4, r3
    95cc:	f100 35ff 	add.w	r5, r0, #4294967295
    95d0:	d229      	bcs.n	9626 <__udivmoddi4+0x2ba>
    95d2:	45a0      	cmp	r8, r4
    95d4:	d927      	bls.n	9626 <__udivmoddi4+0x2ba>
    95d6:	3802      	subs	r0, #2
    95d8:	441c      	add	r4, r3
    95da:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
    95de:	eba4 0408 	sub.w	r4, r4, r8
    95e2:	fba0 8902 	umull	r8, r9, r0, r2
    95e6:	454c      	cmp	r4, r9
    95e8:	46c6      	mov	lr, r8
    95ea:	464d      	mov	r5, r9
    95ec:	d315      	bcc.n	961a <__udivmoddi4+0x2ae>
    95ee:	d012      	beq.n	9616 <__udivmoddi4+0x2aa>
    95f0:	b156      	cbz	r6, 9608 <__udivmoddi4+0x29c>
    95f2:	ebba 030e 	subs.w	r3, sl, lr
    95f6:	eb64 0405 	sbc.w	r4, r4, r5
    95fa:	fa04 f707 	lsl.w	r7, r4, r7
    95fe:	40cb      	lsrs	r3, r1
    9600:	431f      	orrs	r7, r3
    9602:	40cc      	lsrs	r4, r1
    9604:	6037      	str	r7, [r6, #0]
    9606:	6074      	str	r4, [r6, #4]
    9608:	2100      	movs	r1, #0
    960a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    960e:	4618      	mov	r0, r3
    9610:	e6f8      	b.n	9404 <__udivmoddi4+0x98>
    9612:	4690      	mov	r8, r2
    9614:	e6e0      	b.n	93d8 <__udivmoddi4+0x6c>
    9616:	45c2      	cmp	sl, r8
    9618:	d2ea      	bcs.n	95f0 <__udivmoddi4+0x284>
    961a:	ebb8 0e02 	subs.w	lr, r8, r2
    961e:	eb69 0503 	sbc.w	r5, r9, r3
    9622:	3801      	subs	r0, #1
    9624:	e7e4      	b.n	95f0 <__udivmoddi4+0x284>
    9626:	4628      	mov	r0, r5
    9628:	e7d7      	b.n	95da <__udivmoddi4+0x26e>
    962a:	4640      	mov	r0, r8
    962c:	e791      	b.n	9552 <__udivmoddi4+0x1e6>
    962e:	4681      	mov	r9, r0
    9630:	e7be      	b.n	95b0 <__udivmoddi4+0x244>
    9632:	4601      	mov	r1, r0
    9634:	e778      	b.n	9528 <__udivmoddi4+0x1bc>
    9636:	3802      	subs	r0, #2
    9638:	443c      	add	r4, r7
    963a:	e745      	b.n	94c8 <__udivmoddi4+0x15c>
    963c:	4608      	mov	r0, r1
    963e:	e708      	b.n	9452 <__udivmoddi4+0xe6>
    9640:	f1a8 0802 	sub.w	r8, r8, #2
    9644:	443d      	add	r5, r7
    9646:	e72b      	b.n	94a0 <__udivmoddi4+0x134>

00009648 <__aeabi_idiv0>:
    9648:	4770      	bx	lr
    964a:	bf00      	nop

0000964c <__libc_init_array>:
    964c:	b570      	push	{r4, r5, r6, lr}
    964e:	4e0d      	ldr	r6, [pc, #52]	; (9684 <__libc_init_array+0x38>)
    9650:	4c0d      	ldr	r4, [pc, #52]	; (9688 <__libc_init_array+0x3c>)
    9652:	1ba4      	subs	r4, r4, r6
    9654:	10a4      	asrs	r4, r4, #2
    9656:	2500      	movs	r5, #0
    9658:	42a5      	cmp	r5, r4
    965a:	d109      	bne.n	9670 <__libc_init_array+0x24>
    965c:	4e0b      	ldr	r6, [pc, #44]	; (968c <__libc_init_array+0x40>)
    965e:	4c0c      	ldr	r4, [pc, #48]	; (9690 <__libc_init_array+0x44>)
    9660:	f000 fa1c 	bl	9a9c <_init>
    9664:	1ba4      	subs	r4, r4, r6
    9666:	10a4      	asrs	r4, r4, #2
    9668:	2500      	movs	r5, #0
    966a:	42a5      	cmp	r5, r4
    966c:	d105      	bne.n	967a <__libc_init_array+0x2e>
    966e:	bd70      	pop	{r4, r5, r6, pc}
    9670:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
    9674:	4798      	blx	r3
    9676:	3501      	adds	r5, #1
    9678:	e7ee      	b.n	9658 <__libc_init_array+0xc>
    967a:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
    967e:	4798      	blx	r3
    9680:	3501      	adds	r5, #1
    9682:	e7f2      	b.n	966a <__libc_init_array+0x1e>
    9684:	00009aa8 	.word	0x00009aa8
    9688:	00009aa8 	.word	0x00009aa8
    968c:	00009aa8 	.word	0x00009aa8
    9690:	00009aac 	.word	0x00009aac

00009694 <memcpy>:
    9694:	b510      	push	{r4, lr}
    9696:	1e43      	subs	r3, r0, #1
    9698:	440a      	add	r2, r1
    969a:	4291      	cmp	r1, r2
    969c:	d100      	bne.n	96a0 <memcpy+0xc>
    969e:	bd10      	pop	{r4, pc}
    96a0:	f811 4b01 	ldrb.w	r4, [r1], #1
    96a4:	f803 4f01 	strb.w	r4, [r3, #1]!
    96a8:	e7f7      	b.n	969a <memcpy+0x6>

000096aa <memset>:
    96aa:	4402      	add	r2, r0
    96ac:	4603      	mov	r3, r0
    96ae:	4293      	cmp	r3, r2
    96b0:	d100      	bne.n	96b4 <memset+0xa>
    96b2:	4770      	bx	lr
    96b4:	f803 1b01 	strb.w	r1, [r3], #1
    96b8:	e7f9      	b.n	96ae <memset+0x4>
	...

000096bc <ExCvt>:
    96bc:	5543 4145 4141 4341 4545 4945 4949 4141     CUEAAAACEEEIIIAA
    96cc:	9245 4f92 4f4f 5555 4f59 4f55 4f9c 9f9e     E..OOOUUYOUO.O..
    96dc:	4941 554f a5a5 a7a6 a9a8 abaa adac afae     AIOU............
    96ec:	b1b0 b3b2 41b4 4141 b9b8 bbba bdbc bfbe     .....AAA........
    96fc:	c1c0 c3c2 c5c4 4141 c9c8 cbca cdcc cfce     ......AA........
    970c:	d1d1 4545 4945 4949 d949 dbda dddc df49     ..EEEIIII.....I.
    971c:	e14f 4f4f 4f4f e8e6 55e8 5555 5959 efee     O.OOOO...UUUYY..
    972c:	f1f0 f3f2 f5f4 f7f6 f9f8 fbfa fdfc fffe     ................

0000973c <vst.5977>:
    973c:	0400 0200 0100 0080 0040 0020 0010 0008     ........@. .....
    974c:	0004 0002 0000 0000                         ........

00009754 <cst.5978>:
    9754:	8000 4000 2000 1000 0800 4000 2000 1000     ...@. .....@. ..
    9764:	0800 0400 0200 0000 2a22 2c2b 3b3a 3d3c     ........"*+,:;<=
    9774:	3f3e 5d5b 7f7c 0000 feeb 4d90 4453 534f     >?[]|......MSDOS
    9784:	2e35 0030 4f4e 4e20 4d41 2045 2020 4620     5.0.NO NAME    F
    9794:	5441 3233 2020 0020 4f4e 4e20 4d41 2045     AT32   .NO NAME 
    97a4:	2020 4620 5441 2020 2020 0020 2e2e 682f        FAT     .../h
    97b4:	6c61 732f 6372 682f 6c61 635f 6c61 6e65     al/src/hal_calen
    97c4:	6164 2e72 0063 0000 2e2e 682f 6c61 732f     dar.c...../hal/s
    97d4:	6372 682f 6c61 695f 2e6f 0063 2e2e 682f     rc/hal_io.c.../h
    97e4:	6c61 732f 6372 682f 6c61 6d5f 6963 735f     al/src/hal_mci_s
    97f4:	6e79 2e63 0063 0000 2e2e 682f 6c61 732f     ync.c...../hal/s
    9804:	6372 682f 6c61 705f 6d77 632e 0000 0000     rc/hal_pwm.c....
    9814:	2e2e 682f 6c61 732f 6372 682f 6c61 735f     ../hal/src/hal_s
    9824:	6970 735f 615f 7973 636e 632e 0000 0000     pi_s_async.c....
    9834:	2e2e 682f 6c61 752f 6974 736c 732f 6372     ../hal/utils/src
    9844:	752f 6974 736c 6c5f 7369 2e74 0063 0000     /utils_list.c...
    9854:	2e2e 682f 6c61 752f 6974 736c 732f 6372     ../hal/utils/src
    9864:	752f 6974 736c 725f 6e69 6267 6675 6566     /utils_ringbuffe
    9874:	2e72 0063                                   r.c.

00009878 <_map>:
    9878:	0000 0000 0010 0000 0001 0000 0011 0000     ................
    9888:	0002 0000 0012 0000 0003 0000 0013 0000     ................
    9898:	2e2e 682f 6c70 652f 6369 682f 6c70 655f     ../hpl/eic/hpl_e
    98a8:	6369 632e 0000 0000 2e2e 682f 6c70 722f     ic.c....../hpl/r
    98b8:	6374 682f 6c70 725f 6374 632e 0000 0000     tc/hpl_rtc.c....
    98c8:	2e2e 682f 6c70 732f 6864 2f63 7068 5f6c     ../hpl/sdhc/hpl_
    98d8:	6473 6368 632e 0000 3000 4000 3400 4000     sdhc.c...0.@.4.@
    98e8:	2000 4101 4000 4101 0000 4300 0400 4300     . .A.@.A...C...C
    98f8:	0800 4300 0c00 4300                         ...C...C

00009900 <_i2cms>:
	...

00009918 <sercomspi_regs>:
    9918:	0008 0002 0000 0002 0000 0000 0000 0000     ................
    9928:	0000 0000 2e2e 682f 6c70 732f 7265 6f63     ....../hpl/serco
    9938:	2f6d 7068 5f6c 6573 6372 6d6f 632e 0000     m/hpl_sercom.c..
    9948:	3800 4000 3c00 4000 a000 4101 c000 4101     .8.@.<.@...A...A
    9958:	1400 4200 1800 4200 1400 4300 1800 4300     ...B...B...C...C
    9968:	2e2e 682f 6c70 742f 2f63 7068 5f6c 6374     ../hpl/tc/hpl_tc
    9978:	632e 0000                                   .c..

0000997c <_usb_ep_cfgs>:
    997c:	05e0 2000 0000 0000 0040 0000 05a0 2000     ... ....@...... 
    998c:	0000 0000 0040 0000 0560 2000 0000 0000     ....@...`.. ....
    999c:	0040 0000 3043 0000 3143 0000 6f63 666e     @...C0..C1..conf
    99ac:	6769 742e 7478 0000                         ig.txt..

000099b4 <sd_mmc_trans_units>:
    99b4:	000a 0000 0064 0000 03e8 0000 2710 0000     ....d........'..
	...

000099d0 <sd_trans_multipliers>:
    99d0:	0000 0000 000a 0000 000c 0000 000d 0000     ................
    99e0:	000f 0000 0014 0000 0019 0000 001e 0000     ................
    99f0:	0023 0000 0028 0000 002d 0000 0032 0000     #...(...-...2...
    9a00:	0037 0000 003c 0000 0046 0000 0050 0000     7...<...F...P...

00009a10 <mmc_trans_multipliers>:
    9a10:	0000 0000 000a 0000 000c 0000 000d 0000     ................
    9a20:	000f 0000 0014 0000 001a 0000 001e 0000     ................
    9a30:	0023 0000 0028 0000 002d 0000 0034 0000     #...(...-...4...
    9a40:	0037 0000 003c 0000 0046 0000 0050 0000     7...<...F...P...
    9a50:	2e2e 732f 5f64 6d6d 2f63 6473 6d5f 636d     ../sd_mmc/sd_mmc
    9a60:	632e 0000 4449 454c 0000 0000 2509 0963     .c..IDLE.....%c.
    9a70:	7525 2509 0975 7525 0a0d 0000 6d54 2072     %u.%u.%u....Tmr 
    9a80:	7653 0063 2e2e 752f 6273 642f 7665 6369     Svc.../usb/devic
    9a90:	2f65 7375 6462 2e63 0063 0000               e/usbdc.c...

00009a9c <_init>:
    9a9c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    9a9e:	bf00      	nop
    9aa0:	bcf8      	pop	{r3, r4, r5, r6, r7}
    9aa2:	bc08      	pop	{r3}
    9aa4:	469e      	mov	lr, r3
    9aa6:	4770      	bx	lr

00009aa8 <__init_array_start>:
    9aa8:	00000289 	.word	0x00000289

00009aac <_fini>:
    9aac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    9aae:	bf00      	nop
    9ab0:	bcf8      	pop	{r3, r4, r5, r6, r7}
    9ab2:	bc08      	pop	{r3}
    9ab4:	469e      	mov	lr, r3
    9ab6:	4770      	bx	lr

00009ab8 <__fini_array_start>:
    9ab8:	00000265 	.word	0x00000265
